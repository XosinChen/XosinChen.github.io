<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javaSE学习整理</title>
    <url>/2020/09/06/javaSE%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、javSE"><a href="#一、javSE" class="headerlink" title="一、javSE"></a>一、javSE</h1><h3 id="一、流程控制"><a href="#一、流程控制" class="headerlink" title="一、流程控制"></a>一、流程控制</h3><ul>
<li>用户交互</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next方法:</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个扫描器对象，用于接收键盘数据</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//next方式接收字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;Next方式接收:&quot;</span>);</span><br><span class="line"><span class="comment">//判断用户还有没有输入字符</span></span><br><span class="line"><span class="keyword">if</span> (scanner.hasNext())&#123;</span><br><span class="line">String str = scanner.next();</span><br><span class="line">System.out.println(<span class="string">&quot;输入内容：&quot;</span>+str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源.要养成好习惯用完就关掉.就好像你接水完了要关</span></span><br><span class="line"><span class="comment">//水龙头一样.很多下载软件或者视频软件如果你不彻底关,都会自己上传下载从而占用资源,你就会觉得</span></span><br><span class="line"><span class="comment">//卡,这一个道理.</span></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nextLine方法:</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 从键盘接收数据</span></span><br><span class="line"><span class="comment">// nextLine方式接收字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;nextLine方式接收：&quot;</span>);</span><br><span class="line"><span class="comment">// 判断是否还有输入</span></span><br><span class="line"><span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">String str2 = scan.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;输入内容：&quot;</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">next方法和nextLine方法的区别在于:</span><br><span class="line">next():</span><br><span class="line">1、一定要读取到有效字符后才可以结束输入。</span><br><span class="line">2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</span><br><span class="line">3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</span><br><span class="line">4、next() 不能得到带有空格的字符串。</span><br><span class="line">nextLine()：</span><br><span class="line">1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</span><br><span class="line">2、可以获得空白。</span><br></pre></td></tr></table></figure>

<ul>
<li>流程控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流程控制的三种方法:</span><br><span class="line">1.if</span><br><span class="line">2.switch多选择结构</span><br><span class="line"></span><br><span class="line">switch case 语句有如下规则：</span><br><span class="line">switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</span><br><span class="line">switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</span><br><span class="line">case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</span><br><span class="line">当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</span><br><span class="line">当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现break 语句。</span><br><span class="line">switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。如果后续的 case 语句块有 break 语句则会跳出判断。【case穿透】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.循环结构:</span><br><span class="line">while 循环</span><br><span class="line">do…while 循环</span><br><span class="line"></span><br><span class="line">While和do-While的区别：</span><br><span class="line">while先判断后执行。dowhile是先执行后判断！</span><br><span class="line">Do...while总是保证循环体会被至少执行一次！这是他们的主要差别。</span><br><span class="line"></span><br><span class="line">for 循环</span><br><span class="line"></span><br><span class="line">最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span><br><span class="line">然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</span><br><span class="line">执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减)。</span><br><span class="line">再次检测布尔表达式。循环执行上面的过程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增强<span class="keyword">for</span>循环的两种使用方式:</span><br><span class="line"><span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</span><br><span class="line">System.out.print( x );</span><br><span class="line">System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">String [] names =&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>( String name : names ) &#123;</span><br><span class="line">System.out.print( name );</span><br><span class="line">System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break和continue</span><br><span class="line">break:</span><br><span class="line">break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</span><br><span class="line">break 跳出最里层的循环，并且继续执行该循环下面的语句。</span><br><span class="line"></span><br><span class="line">continue:</span><br><span class="line">continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</span><br><span class="line">在 for 循环中，continue 语句使程序立即跳转到更新语句。</span><br><span class="line">在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</span><br><span class="line"></span><br><span class="line">两者的区别:</span><br><span class="line">break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句也在switch语句中使用)</span><br><span class="line">continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h3><ul>
<li>方法的定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分析常见代码:</span><br><span class="line">System.out.println()</span><br><span class="line">System是系统类  out是标准输出对象 println是方法</span><br><span class="line">方法是什么呢:</span><br><span class="line">方法是解决一类问题的步骤的有序组合</span><br><span class="line">方法包含于类或对象中</span><br><span class="line">方法在程序中被创建，在其他地方被引用</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的定义:常见格式</span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰符</strong>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。<br><strong>返回值类型</strong>：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。<br><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。<br><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表:是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p>
<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
</ul>
<hr>
<ul>
<li>方法的重载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</span><br><span class="line">Java编译器根据方法签名判断哪个方法应该被调用。</span><br><span class="line">方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</span><br><span class="line">重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</span><br><span class="line"></span><br><span class="line">方法重载必须满足以下条件</span><br><span class="line">1. 方法名必须相同</span><br><span class="line">2. 参数列表必须不同(参数的类型、个数、顺序的不同)</span><br><span class="line">3. 方法的返回值可以不同，也可以相同。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Strig str)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Strig str,<span class="keyword">double</span> d)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Strig str)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Strig str,<span class="keyword">double</span> d)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> d,Strig str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">idea 移动光标到prontln按下alt查看该方法重载</span><br></pre></td></tr></table></figure>



<p><strong>拓展</strong>:命令行传参</p>
<ul>
<li>可变参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</span><br><span class="line">方法的可变参数的声明如下所示：</span><br><span class="line">在方法声明中，在指定参数类型后加一个省略号(...) 。</span><br><span class="line">一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用可变参数的方法</span></span><br><span class="line">printMax(<span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">56.5</span>);</span><br><span class="line">printMax(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">( <span class="keyword">double</span>... numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//排序！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i] &gt; result) &#123;</span><br><span class="line">result = numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;The max value is &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归算法重点：</span><br><span class="line">递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个</span><br><span class="line">使用递归技术的方法将会直接或者间接的调用自己。</span><br><span class="line">利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计</span><br><span class="line">算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</span><br><span class="line">递归结构包括两个部分：</span><br><span class="line">1. 递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环。</span><br><span class="line">2. 递归体。解答：什么时候需要调用自身方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">案例:</span><br><span class="line">计算<span class="number">5</span>的阶层</span><br><span class="line"><span class="comment">//5*4*3*2*1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(f(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此题中，按照递归的三个条件来分析：</span><br><span class="line">(1)边界条件：阶乘，乘到最后一个数，即1的时候，返回1，程序执行到底；</span><br><span class="line">(2)递归前进段：当前的参数不等于1的时候，继续调用自身；</span><br><span class="line">(3)递归返回段：从最大的数开始乘，如果当前参数是5，那么就是5 4，即5 (5-1)，即n * (n-1)</span><br><span class="line">递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理解，容易编程。但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。（会占用大量的内存空间）</span><br><span class="line">而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但缺点就是不容易理解，编写复杂问题时困难。</span><br><span class="line">能不用递归就不用递归，递归都可以用迭代来代替</span><br></pre></td></tr></table></figure>

<ul>
<li>方法的回顾及加深</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>方法的定义</span><br><span class="line">格式:</span><br><span class="line">修饰符 返回类型 方法名(参数列表)异常抛出类型&#123;...&#125;</span><br><span class="line"></span><br><span class="line">修饰符:</span><br><span class="line"><span class="keyword">public</span>、<span class="keyword">static</span>、<span class="keyword">abstract</span>、<span class="keyword">final</span>等等都是修饰符，一个方法可以有多个修饰符。例如程序入口main方法，就使用了<span class="keyword">public</span> <span class="keyword">static</span>这个俩个修饰符</span><br><span class="line">注:如果一个方法或者属性有多个修饰符,这多个修饰符是没有先后顺序的</span><br><span class="line">    </span><br><span class="line">返回类型:</span><br><span class="line">方法执行完如果有要返回的数据,那么就要声明返回数据的类型,如果没有返回的数据,那么返回类型就必须写<span class="keyword">void</span>.</span><br><span class="line">只有构造方法(构造器)不写任何返回类型也不写<span class="keyword">void</span></span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>和<span class="keyword">return</span>的区别:</span><br><span class="line"><span class="keyword">return</span> 语句的作用</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">return</span> 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">return</span> 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。</span><br><span class="line">(<span class="number">3</span>) <span class="keyword">return</span>后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。</span><br><span class="line"><span class="keyword">break</span>语句的作用</span><br><span class="line">(<span class="number">1</span>)<span class="keyword">break</span>在循环体内，强行结束循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否</span><br><span class="line">成立，直接转向循环语句下面的语句。</span><br><span class="line">(<span class="number">2</span>)当<span class="keyword">break</span>出现在循环体中的<span class="keyword">switch</span>语句体内时，其作用只是跳出该<span class="keyword">switch</span>语句体。</span><br><span class="line"></span><br><span class="line">方法的调用:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>非静态方法:</span><br><span class="line">没有使用<span class="keyword">static</span>修饰符修饰的方法,就是非静态方法.</span><br><span class="line">调用这种方法的时候,是<span class="string">&quot;一定&quot;</span>要使用对象的。因为非静态方法是属于对象的。(非静态属性也是一样的)</span><br><span class="line"> </span><br><span class="line">代码案例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.say();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>静态方法:</span><br><span class="line">使用<span class="keyword">static</span>修饰符修饰的方法,就是静态方法.</span><br><span class="line">调用这种方法的时候,<span class="string">&quot;可以&quot;</span>使用对象调用,也<span class="string">&quot;可以&quot;</span>使用类来调用,但是推荐使用类进行调用,因为静态方法是属于类的。(静态属性也是一样的)</span><br><span class="line">    </span><br><span class="line">[理解:]</span><br><span class="line">    为什么静态变量要使用 类名 去调用??</span><br><span class="line">    因为 只要加载了.class文件 就加载了静态变量(这时 还没有对象产生)</span><br><span class="line"></span><br><span class="line">代码案例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">Student.say();</span><br><span class="line"></span><br><span class="line">类中方法调用注意点:</span><br><span class="line"></span><br><span class="line">注意: 在同一个类中,静态方法内不能直接访问到类中的非静态属性.</span><br><span class="line">总结: 类中方法中的调用，两个方法都是静态或者非静态都可以互相调用，当一个方法是静态，一个方法是非静态的时候，非静态方法可以调用静态方法，反之不能。</span><br><span class="line"></span><br><span class="line">代码案例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//b();报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用方法时的传参:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>形参和实参:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">t.test(x);</span><br><span class="line"></span><br><span class="line">参数列表中的a是方法test的形参(形式上的参数)</span><br><span class="line">调用方法时的x是方法test的实参(实际上的参数)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>值传递和引用传递:</span><br><span class="line"></span><br><span class="line">调用方法进行传参时,分为值传递和引用传递两种。</span><br><span class="line">如果参数的类型是基本数据类型,那么就是值传递。</span><br><span class="line">如果参数的类型是引用数据类型,那么就是引用传递。</span><br><span class="line">值传递是实参把自己变量本身存的简单数值赋值给形参.</span><br><span class="line">引用传递是实参把自己变量本身存的对象内存地址值赋值给形参.</span><br><span class="line">所以值传递和引用传递本质上是一回事,只不过传递的东西的意义不同而已.</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">值传递:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeNum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;before: a = &quot;</span>+a); <span class="comment">//1</span></span><br><span class="line">changeNum(a);</span><br><span class="line">System.out.println(<span class="string">&quot;after: a = &quot;</span>+a); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">引用传递:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">s.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(<span class="string">&quot;before: name = &quot;</span>+s.name); <span class="comment">//null</span></span><br><span class="line">changeName(s);</span><br><span class="line">System.out.println(<span class="string">&quot;after: name = &quot;</span>+s.name); <span class="comment">//tom</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从内存深入理解值传递和引用传递</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法的定义:</span><br><span class="line"></span><br><span class="line">形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</span><br><span class="line"></span><br><span class="line">实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</span><br><span class="line"></span><br><span class="line">形参只有在函数被调用时,他的生命周期才开始,在函数调用结束后形参也就被jvm释放掉.</span><br><span class="line"></span><br><span class="line">java的数据类型:</span><br><span class="line"></span><br><span class="line">数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。</span><br><span class="line"></span><br><span class="line">因此,数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</span><br><span class="line"></span><br><span class="line">基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</span><br><span class="line"></span><br><span class="line">4种整数类型：byte、short、int、long</span><br><span class="line">2种浮点数类型：float、double</span><br><span class="line">1种字符类型：char</span><br><span class="line">1种布尔类型：boolean</span><br><span class="line"></span><br><span class="line">引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</span><br><span class="line"></span><br><span class="line">类</span><br><span class="line">接口</span><br><span class="line">数组</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>java程序的执行过程:</strong></p>
<p><img src="https://i.loli.net/2020/09/10/BKcqorI489swejm.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. 虚拟机栈</span><br><span class="line"></span><br><span class="line">2. 堆</span><br><span class="line"></span><br><span class="line">3. 程序计数器</span><br><span class="line"></span><br><span class="line">4. 方法区</span><br><span class="line"></span><br><span class="line">5. 本地方法栈</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.虚拟机栈:</span><br><span class="line">虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</span><br><span class="line"></span><br><span class="line">栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</span><br><span class="line"></span><br><span class="line">下图表示了一个Java栈的模型以及栈帧的组成：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/gX1KAmIeTi5pusZ.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈帧:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">每个栈帧中包括：</span><br><span class="line"></span><br><span class="line">局部变量表:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</span><br><span class="line"></span><br><span class="line">操作数栈:Java虚拟机的解释执行引擎被称为&quot;基于栈的执行引擎&quot;，其中所指的栈就是指操作数栈。</span><br><span class="line"></span><br><span class="line">指向运行时常量池的引用:存储程序执行时可能用到常量的引用。</span><br><span class="line"></span><br><span class="line">方法返回地址:存储方法执行完成后的返回地址。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.堆:</span><br><span class="line">堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</span><br><span class="line"></span><br><span class="line">个人理解 new完的东西(对象)都在堆里生成.[存疑]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.方法区:</span><br><span class="line">方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</span><br><span class="line"></span><br><span class="line">方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.本地方法栈:</span><br><span class="line"></span><br><span class="line">本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.程序计数器:</span><br><span class="line"></span><br><span class="line">线程私有的。</span><br><span class="line">记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</span><br></pre></td></tr></table></figure>

<ul>
<li>数据如何在内存中存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM在程序运行时的内存分配有三个地方：</span><br><span class="line"></span><br><span class="line">堆</span><br><span class="line"></span><br><span class="line">栈</span><br><span class="line"></span><br><span class="line">静态方法区</span><br><span class="line"></span><br><span class="line">常量区</span><br><span class="line"></span><br><span class="line">每个存储区域的内存分配策略:</span><br><span class="line"></span><br><span class="line">堆式：</span><br><span class="line"></span><br><span class="line">栈式</span><br><span class="line"></span><br><span class="line">静态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据存储的情况:</span><br><span class="line"></span><br><span class="line">1. 基本数据类型的存储：</span><br><span class="line"></span><br><span class="line">A. 基本数据类型的局部变量</span><br><span class="line"></span><br><span class="line">B. 基本数据类型的成员变量</span><br><span class="line"></span><br><span class="line">C. 基本数据类型的静态变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 引用数据类型的存储</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. 基本数据类型的局部变量:</span><br><span class="line"></span><br><span class="line">定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的“虚拟机栈”，数据本身的值就是存储在栈空间里面。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/uK1e4BsfoY3pxi8.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码解释说明:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> weight=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> grade=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">代码“<span class="keyword">int</span> age=<span class="number">50</span>；”，在内存中的理解应为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//定义变量</span></span><br><span class="line">age=<span class="number">50</span>;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为<span class="number">50</span>的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“<span class="number">50</span>”这个内容，并且把age指向这个地址。因此我们可以知道：</span><br><span class="line">我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</span><br><span class="line"></span><br><span class="line">我们再来看“<span class="keyword">int</span> weight=<span class="number">50</span>；”，按照刚才的思路：字面量为<span class="number">50</span>的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：栈中的数据在当前线程下是共享的。</span><br><span class="line">    </span><br><span class="line">假设在执行下面代码:</span><br><span class="line"></span><br><span class="line">weight=<span class="number">40</span>；</span><br><span class="line"></span><br><span class="line">当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为<span class="number">40</span>的内容，发现没有，就会开辟一块内存空间存储<span class="number">40</span>这个内容，并且把weight指向这个地址。由此可知：</span><br><span class="line"></span><br><span class="line">基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">B. 基本数据类型的成员变量:</span><br><span class="line">成员变量就是在类体中定义的变量</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/tipGhIqL2un3m41.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码解释说明:</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line"> <span class="comment">//篇幅较长，省略setter getter方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;run....&quot;</span>); </span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Person per=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C. 基本数据类型的静态变量:</span><br><span class="line"></span><br><span class="line">前面提到方法区用来存储一些共享数据，因此基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> 引用数据类型的存储:</span><br><span class="line"></span><br><span class="line">堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</span><br><span class="line">    </span><br><span class="line">Person per=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">相似的可以在内存中理解为:</span><br><span class="line"></span><br><span class="line">Person per;<span class="comment">//定义变量</span></span><br><span class="line">per=<span class="keyword">new</span> Person();<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">[理解:]Person类型的 per是一个person对象.</span><br><span class="line">在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=<span class="keyword">new</span> Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：</span><br><span class="line">对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</span><br></pre></td></tr></table></figure>

<ul>
<li>重新解释值传递</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">值传递：</span><br><span class="line">在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</span><br><span class="line">    </span><br><span class="line">代码解释说明:</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 值传递进阶 </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valueCrossTest</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的age：&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的weight：&quot;</span>+weight);</span><br><span class="line">        age=<span class="number">33</span>;</span><br><span class="line">        weight=<span class="number">89.5f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法内重新赋值后的age：&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法内重新赋值后的weight：&quot;</span>+weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">float</span> w=<span class="number">77.5f</span>;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后的age：&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后的weight：&quot;</span>+w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        传入的age：25</span></span><br><span class="line"><span class="comment">//        传入的weight：77.5</span></span><br><span class="line"><span class="comment">//        方法内重新赋值后的age：33</span></span><br><span class="line"><span class="comment">//        方法内重新赋值后的weight：89.5</span></span><br><span class="line"><span class="comment">//        方法执行后的age：25</span></span><br><span class="line"><span class="comment">//        方法执行后的weight：77.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/jGekwLE8ldiSHoz.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/oaRxdlBH5Tqw4C2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/wVPgu89kmAHS1ib.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line"></span><br><span class="line">也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。</span><br><span class="line">因此：</span><br><span class="line">值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</span><br></pre></td></tr></table></figure>

<ul>
<li>重新解释引用传递</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引用传递：</span><br><span class="line"></span><br><span class="line">”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码解释说明:</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 引用传递进阶 </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的person的name：&quot;</span>+person.getName());</span><br><span class="line">        person.setName(<span class="string">&quot;我是张小龙&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法内重新赋值后的name：&quot;</span>+person.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p =<span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">&quot;我是马化腾&quot;</span>);</span><br><span class="line">        p.setAge(<span class="number">45</span>);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">       System.out.println(<span class="string">&quot;方法执行后的name：&quot;</span>+p.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        传入的person的name：我是马化腾</span></span><br><span class="line"><span class="comment">//        方法内重新赋值后的name：我是张小龙</span></span><br><span class="line"><span class="comment">//        方法执行后的name：我是张小龙</span></span><br><span class="line"></span><br><span class="line">可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的“引用传递”，对形参的操作，改变了实际对象的内容。</span><br></pre></td></tr></table></figure>

<ul>
<li>值传递引用传递进阶</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 引用传递进阶 </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的person的name：&quot;</span>+person.getName());</span><br><span class="line">        person=<span class="keyword">new</span> Person();<span class="comment">//加多此行代码</span></span><br><span class="line">        person.setName(<span class="string">&quot;我是张小龙&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法内重新赋值后的name：&quot;</span>+person.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p =<span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">&quot;我是马化腾&quot;</span>);</span><br><span class="line">        p.setAge(<span class="number">45</span>);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">       System.out.println(<span class="string">&quot;方法执行后的name：&quot;</span>+p.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        传入的person的name：我是马化腾</span></span><br><span class="line"><span class="comment">//        方法内重新赋值后的name：我是张小龙</span></span><br><span class="line"><span class="comment">//        方法执行后的name：我是马化腾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">发现输出不一样了,问题就在于按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</span><br><span class="line"></span><br><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">&quot;我是马化腾&quot;</span>);</span><br><span class="line">p.setAge(<span class="number">45</span>);</span><br><span class="line">PersonCrossTest(p);</span><br><span class="line"></span><br><span class="line">JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/QFbOz4ZL2CjacRd.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</span><br><span class="line">    </span><br><span class="line">person=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">JVM需要在堆内另外开辟一块内存来存储<span class="keyword">new</span> Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变。</span><br><span class="line"></span><br><span class="line">可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</span><br><span class="line"></span><br><span class="line">然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</span><br><span class="line"></span><br><span class="line">由此可见：引用传递，在Java中并不存在。</span><br><span class="line"></span><br><span class="line">但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</span><br><span class="line"></span><br><span class="line">这是因为：无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/10/35D7YZyqTOgzIrW.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</span><br><span class="line"></span><br><span class="line">p和person都是指向同一个对象。</span><br><span class="line"></span><br><span class="line">因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</span><br><span class="line"></span><br><span class="line">p依旧是指向旧的对象，person指向新对象的地址。</span><br><span class="line"></span><br><span class="line">所以此时对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系。</span><br><span class="line"></span><br><span class="line">结语:</span><br><span class="line">因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。</span><br><span class="line">只是在传递过程中：</span><br><span class="line"></span><br><span class="line">如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</span><br><span class="line"></span><br><span class="line">如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关联知识-----java <span class="keyword">new</span>的对象怎么被内存回收</span><br><span class="line">    </span><br><span class="line">我们在方法内部使用<span class="keyword">new</span>创建对象，并将该对象的引用返回。如果该返回被一个引用接收，由于对象的引用不为<span class="number">0</span>，对象依然存在，不会被垃圾回收</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">如上面代码，简单说就是<span class="keyword">new</span> User()的时候，会返回一个地址，并且将地址赋值给引用u，当这个引用被u持有的时候，java会认为这个对象时有用的，不会回收对象，如果你之后执行了好比说：</span><br><span class="line">    </span><br><span class="line">u = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">u = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">这样的代码，那么这个u就不在持有之前对象的地址了，变成了空或者新的地址，这个时候如果没有其他引用持有了之前对象的地址，之前的对象就没有访问方法了，那么gc(垃圾回收器)运行的时候会认为这个对象没用了，将他从内存中释放掉。</span><br><span class="line">    </span><br><span class="line">总结:如果这个对象没有被任何人引用它,它就会被回收注意回收的是<span class="keyword">new</span>的那个对象.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">String a ; 与String a = <span class="keyword">new</span> String ()有什么区别？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这么形容，String a相当于你说“我想喝水”，但是只是说说，没有水也没有杯子。。。String a = <span class="keyword">new</span> String()就是说“我想喝水”，并且别人给你了一个杯子。。。String a = <span class="string">&quot;This sucks!&quot;</span>，就是你说“我想喝水”，然后给你一个装满水的杯子</span><br><span class="line">    </span><br><span class="line">String a;<span class="comment">//a是一个引用，或者叫别名   </span></span><br><span class="line">a== <span class="keyword">null</span>;</span><br><span class="line">a 没有指向一个对象</span><br><span class="line">String a = <span class="keyword">new</span> String ()</span><br><span class="line">a != <span class="keyword">null</span>;</span><br><span class="line">a 指向了一个对象</span><br><span class="line"></span><br><span class="line">String a，只是声明了一个变量，存储在<span class="string">&quot;栈&quot;</span>中。。。String a = <span class="keyword">new</span> String()，不仅在栈中声明了这个变量，同时在“堆”中划分了一片区域（为空），变量存储只想这片区域的地址。。。String a = <span class="string">&quot;This sucks!&quot;</span>，就是把“堆”中填充上<span class="string">&quot;This sucks!&quot;</span>的内容</span><br><span class="line">    </span><br><span class="line">String a：定义一个字符串类型的变量名为a的变量</span><br><span class="line">String a = <span class="keyword">new</span> String () ：这句活的作用是创建一个对象</span><br><span class="line">String是数据类型，但不是字符串类型，这里指的是引用类型，是一个String类。</span><br><span class="line">String ()是构造函数</span><br><span class="line"><span class="keyword">new</span>在堆内存中开辟一个空间，String ()完成构造函数的初始化动作后，把空间的地 址值赋值给a</span><br><span class="line">a是一个引用类型，通过a可以引用String类中的成员变量和成员方法，因为a有一个地址指向String类    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 </span><br><span class="line"></span><br><span class="line">栈的内存回收：&#123;  里面定义变量  &#125;</span><br><span class="line"></span><br><span class="line">当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。     </span><br><span class="line">    </span><br><span class="line">堆内存回收：</span><br><span class="line"></span><br><span class="line">堆内存用来存放由new创建的对象和数组。   </span><br><span class="line">在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。   </span><br><span class="line">在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。   </span><br><span class="line">引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">java中变量在内存中的分配</span><br><span class="line"></span><br><span class="line">1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期--一直持续到整个&quot;系统&quot;关闭</span><br><span class="line"></span><br><span class="line">2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的&quot;物理位置&quot;。 实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</span><br><span class="line"></span><br><span class="line">3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</span><br></pre></td></tr></table></figure>

<ul>
<li>理解静态变量对应内存关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码分析:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        String name;   <span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">static</span> String country;<span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;  &quot;</span> + <span class="keyword">this</span>.country);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student girl1 = <span class="keyword">new</span> Student();</span><br><span class="line">        girl1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        Student.country = <span class="string">&quot;日本&quot;</span>;</span><br><span class="line">        girl1.sayHi();</span><br><span class="line"></span><br><span class="line">        Student girl2 = <span class="keyword">new</span> Student();</span><br><span class="line">        girl2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        Student.country = <span class="string">&quot;北海道&quot;</span>;</span><br><span class="line">        girl2.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态变量内存示意图如下</strong></p>
<p><img src="https://i.loli.net/2020/09/13/xEjXek9oDdO2caH.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态变量在内存中加载步骤</span><br><span class="line">    1. 加载.class文件(字节码文件) 到方法区</span><br><span class="line">    2. main方法入栈</span><br><span class="line">    3. 要创建Student的对象 先要加载Student.class</span><br><span class="line">          Student.class 中 分为 静态区和非静态区</span><br><span class="line">          这时 初始化静态变量county 初值为 null;</span><br><span class="line">    4. 创建对象(堆区开辟空间) </span><br><span class="line">    5. 把对象的地址 赋值给 girl1 变量 保存</span><br><span class="line">    6. 通过类名 修改 类变量的值</span><br><span class="line">    7. sayHi 方法 入栈 打印</span><br><span class="line">    8. sayHi 出栈</span><br><span class="line">    9. main 出栈   </span><br></pre></td></tr></table></figure>



<h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组的定义：</span><br><span class="line">数组是相同类型数据的有序集合.</span><br><span class="line">数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成。</span><br><span class="line">其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们.</span><br><span class="line"></span><br><span class="line">数组的四个基本特点：</span><br><span class="line">1. 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</span><br><span class="line">2. 其元素必须是相同类型,不允许出现混合类型。</span><br><span class="line">3. 数组中的元素可以是任何数据类型，包括基本类型和引用类型。</span><br><span class="line">4. 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组</span><br><span class="line">本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象</span><br><span class="line">本身是在堆中的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">声明数组:</span><br><span class="line"><span class="keyword">double</span>[] myList; </span><br><span class="line"></span><br><span class="line">创建数组:</span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line">上面语句做的事情是:</span><br><span class="line">一、使用 dataType[arraySize] 创建了一个数组。</span><br><span class="line">二、把新创建的数组的引用赋值给变量 arrayRefVar。</span><br><span class="line"></span><br><span class="line">数组使用案例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.声明一个数组</span></span><br><span class="line"><span class="keyword">int</span>[] myList = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//2.创建一个数组</span></span><br><span class="line">myList = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//3.像数组中存值</span></span><br><span class="line">myList[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myList[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">myList[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">myList[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">myList[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">myList[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">myList[<span class="number">6</span>] = <span class="number">7</span>;</span><br><span class="line">myList[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">myList[<span class="number">8</span>] = <span class="number">9</span>;</span><br><span class="line">myList[<span class="number">9</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 计算所有元素的总和</span></span><br><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">total += myList[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;总和为： &quot;</span> + total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java内存分析</span><br><span class="line">    一.堆</span><br><span class="line">    <span class="number">1.</span>存放<span class="keyword">new</span>的对象和数组</span><br><span class="line">    <span class="number">2.</span>可以被所有的线程共享,不会存放别的对象引用</span><br><span class="line">    二.栈</span><br><span class="line">    <span class="number">1.</span>存放基本变量类型(包含这个基本类型的具体数值)</span><br><span class="line">    <span class="number">2.</span>引用对象的变量(会存放在这个引用在堆里面的具体地址)</span><br><span class="line">    三.方法区</span><br><span class="line">    <span class="number">1.</span>可以被所有线程共享</span><br><span class="line">    <span class="number">2.</span>包含了所有<span class="class"><span class="keyword">class</span>和<span class="title">static</span>变量</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，<span class="title">JVM</span>才分配空间，这时才与长度有关。因此，声明数组时不能指定其长度(数组中元素的个数)，</span></span><br><span class="line"><span class="class">例如： </span></span><br><span class="line">    int a[5]; //非法</span><br><span class="line"><span class="comment">//2.创建一个数组</span></span><br><span class="line">myList = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//合法</span></span><br><span class="line"><span class="number">2.</span> 声明一个数组的时候并没有数组被真正的创建。</span><br><span class="line"><span class="number">3.</span> 构造一个数组，必须指定长度</span><br></pre></td></tr></table></figure>

<ul>
<li>数组初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组默认初始化</span><br><span class="line"><span class="keyword">int</span> 类型为 <span class="number">0</span></span><br><span class="line"><span class="keyword">boolean</span> 类型是 <span class="keyword">false</span></span><br><span class="line">string 类型为 <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">数组是相同数据类型(数据类型可以为任意类型)的有序集合</span><br><span class="line">数组也是对象。数组元素相当于对象的成员变量(详情请见内存图)</span><br><span class="line">数组长度的确定的，不可变的。如果越界，则报：ArrayIndexOutofBounds</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>-each循环遍历数组(jdk1.<span class="number">5</span>新的循环类型)</span><br><span class="line">语法格式:    </span><br><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">案例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"><span class="comment">// 打印所有数组元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> element: myList) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Arrays数组工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打印数组:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">//[I@1b6d3586</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">//[1, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数组升序排序:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二分法查找:</span><br><span class="line">在数组中查找指定元素并返回其下标</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">Arrays.sort(a); <span class="comment">//使用二分法查找，必须先对数组进行排序</span></span><br><span class="line">System.out.println(<span class="string">&quot;该元素的索引：&quot;</span>+Arrays.binarySearch(a, <span class="number">12</span>));</span><br><span class="line">&#125; <span class="comment">//结果为:该元素的索引：2</span></span><br><span class="line"></span><br><span class="line">元素填充:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">Arrays.sort(a); <span class="comment">//使用二分法查找，必须先对数组进行排序</span></span><br><span class="line">Arrays.fill(a, <span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>); <span class="comment">//将2到4索引的元素替换为100</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;<span class="comment">//结果为:[1, 2, 100, 100, 59, 323, 543]  注意是闭区间4取不到</span></span><br><span class="line"></span><br><span class="line">数组转换为list集合:</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<ul>
<li>常见排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">冒泡排序:</span><br><span class="line">冒泡排序算法的原理如下：</span><br><span class="line"><span class="number">1.</span> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><br><span class="line"><span class="number">2.</span> 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span><br><span class="line"><span class="number">3.</span> 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"><span class="number">4.</span> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br><span class="line"></span><br><span class="line">实现代码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 外层循环，它决定一共走几趟 //-1为了防止溢出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span></span><br><span class="line"><span class="comment">//内层循环，它决定每趟走一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">//如果后一个大于前一个,则换位</span></span><br><span class="line"><span class="keyword">if</span> (array[j + <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">temp = array[j];</span><br><span class="line">array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">array[j + <span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bubble bubble = <span class="keyword">new</span> Bubble();</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] sort = bubble.sort(array);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : sort) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">选择排序:</span><br><span class="line">选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</span><br><span class="line">    </span><br><span class="line">实现代码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">// 认为目前的数就是最小的, 记</span></span><br><span class="line">录最小数的下标</span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<span class="comment">// 修改最小值的下标</span></span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 当退出for就找到这次的最小值,就需要交换位置了</span></span><br><span class="line"><span class="keyword">if</span> (i != minIndex) &#123;<span class="comment">//交换当前值和找到的最小值的位置</span></span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[minIndex];</span><br><span class="line">arr[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SelectSort selectSort = <span class="keyword">new</span> SelectSort();</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] sort = selectSort.sort(array);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : sort) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>稀疏数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">稀疏数组举例说明:</span><br><span class="line">原始二维数组:</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">2</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">稀疏数组:</span><br><span class="line">   行  列   值           </span><br><span class="line">[<span class="number">0</span>]<span class="number">11</span>    <span class="number">11</span>    <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]<span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>]<span class="number">2</span>    <span class="number">3</span>    <span class="number">2</span>  </span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line">第一行第一列记录记录原始数组行数，第一行第二列记录原始数组列数，第一行第三列总共有多少个值，第二行记录第一个有效数据，第三行记录第二个有效数据</span><br><span class="line">    </span><br><span class="line">整体思路分析:</span><br><span class="line"><span class="number">1.</span>遍历原始二维数组,得到有效数据的个数sum</span><br><span class="line"><span class="number">2.</span>根据sum创建稀疏数组</span><br><span class="line"><span class="number">3.</span>将二维数组的有效数据存入到稀疏数组中</span><br><span class="line"></span><br><span class="line">稀疏数组转换为原始二维数组的思路:</span><br><span class="line"><span class="number">1.</span>先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line"><span class="number">2.</span>读取稀疏数组的后几行数据,并赋值给原始的二维数组</span><br><span class="line">    </span><br><span class="line">代码实现:</span><br><span class="line"><span class="keyword">package</span> org.westos.sparsearr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个二维数组 11*11</span></span><br><span class="line">        <span class="comment">//0表示没有棋子，1表示黑棋，2表示蓝棋</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始的二维数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArr[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessArr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组转换为稀疏数组</span></span><br><span class="line">        <span class="comment">//1.先遍历二维数组得到非零数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建对应的系数数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给系数数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//遍历二维数组将非零的值存放到稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.println(sparseArr[i][<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>+sparseArr[i][<span class="number">1</span>]+<span class="string">&quot;\t&quot;</span>+sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组恢复成二维数组</span></span><br><span class="line">        <span class="comment">//1.先读取稀疏数组的第一行，根据第一行创建二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.读取稀疏数组后几行赋值给二维数组</span></span><br><span class="line">        <span class="comment">//注意这里是从第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面向对象编程的本质：</span><br><span class="line">以类的方式组织代码，以对象的组织(封装)数据。从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</span><br><span class="line">从代码运行角度考虑是先有类后有对象。类是对象的模板。</span><br><span class="line"></span><br><span class="line">抽象(abstract):</span><br><span class="line">忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用关注细节。</span><br><span class="line">例如:要设计一个学生成绩管理系统，那么对于学生，只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。 抽象是什么?就是将多个物体共同点归纳出来，就是抽出像的部分！</span><br><span class="line"></span><br><span class="line">封装(Encapsulation):</span><br><span class="line">封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过指定的方式。</span><br><span class="line">在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。</span><br><span class="line">通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</span><br><span class="line">信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。</span><br><span class="line">封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</span><br><span class="line"></span><br><span class="line">继承(inheritance):</span><br><span class="line">继承是一种联结类的层次模型，并且允许和支持类的重用，它提供了一种明确表述共性的方法。</span><br><span class="line">新类继承了原始类后,新类就继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)。</span><br><span class="line">派生类(子类)可以从它的基类(父类)那里继承方法和实例变量，并且派生类(子类)中可以修改或增加新的方法使之更适合特殊的需要继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</span><br><span class="line"></span><br><span class="line">多态(polymorphism):</span><br><span class="line">多态性是指允许不同类的对象对同一消息作出响应。</span><br><span class="line">多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类与对象的关系</span><br><span class="line">    </span><br><span class="line">代码说明:</span><br><span class="line">Student s = <span class="keyword">new</span> Student(<span class="number">1L</span>,<span class="string">&quot;tom&quot;</span>,<span class="number">20</span>);</span><br><span class="line">s.study();</span><br><span class="line">Car c = <span class="keyword">new</span> Car(<span class="number">1</span>,<span class="string">&quot;BWM&quot;</span>,<span class="number">500000</span>);</span><br><span class="line">c.run();</span><br><span class="line"></span><br><span class="line">对象s就是Student类的一个实例,对象c就是Car类的一个具体实例,能够使用的是具体实例,而不是类。类只是给对象的创建提供了一个参考的模板而已.</span><br><span class="line">但是在java中,没有类就没有对象,然而类又是根据具体的功能需求,进行实际的分析,最终抽象出来的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>关键字:</span><br><span class="line"></span><br><span class="line">一、<span class="keyword">this</span>在类中的作用:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>区别成员变量和局部变量:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="comment">//this.name表示类中的属性name</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>调用类中的其他方法:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//表示调用当前类中的setName方法</span></span><br><span class="line"><span class="keyword">this</span>.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>调用类中的其他构造器:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用一个参数的构造器,并且参数的类型是String</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意:<span class="keyword">this</span>的这种用法,只能在构造器中使用.普通的方法是不能用的.并且这局调用的代码只能出现在构造器中的第一句</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//编译报错,因为this(&quot;tom&quot;)不是构造器中的第一句代码.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二、<span class="keyword">this</span>关键字在类中的意义</span><br><span class="line">   </span><br><span class="line"><span class="number">1.</span>表示在当前类中创建出来的对象:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this = &quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span>+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行后看结果可知,<span class="keyword">this</span>和s打印的结果是一样的,那么其实也就是变量s是从对象的外部执行对象,而<span class="keyword">this</span>是</span><br><span class="line">在对象的内部执行对象本身.</span><br><span class="line">这样也就能理解为什么<span class="keyword">this</span>.name代表的是成员变量,<span class="keyword">this</span>.setName(<span class="string">&quot;tom&quot;</span>)代表的是调用成员方法,因为</span><br><span class="line">这俩句代码从本质上讲,和在对象外部使用变量s来调用是一样的,s.name和s.setName(<span class="string">&quot;tom&quot;</span>)。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">s1.test();</span><br><span class="line">s2.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">s1对象中的<span class="keyword">this</span>和s1相等,s2对象中的<span class="keyword">this</span>和s2相等,因为类是模板,模板中写的<span class="keyword">this</span>并不是只有一个,每个对象中都有一个属于自己的<span class="keyword">this</span>,就是每个对象中都一个属于自己的name属性一样.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建初始化对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用new关键字创建对象</span><br><span class="line">使用new关键字创建的时候，除了分配内存空间之外，还会给 创建好的对象 进行默认的初始化 以 及对类中构造器的调用。</span><br><span class="line"></span><br><span class="line">那么对main方法中的以下代码:</span><br><span class="line">Student s &#x3D; new Student();</span><br><span class="line">1)为对象分配内存空间,将对象的实例变量自动初始化默认值为0&#x2F;false&#x2F;null。(实例变量的隐式赋值)</span><br><span class="line">2)如果代码中实例变量有显式赋值,那么就将之前的默认值覆盖掉。(之后可以通过例子看到这个现象)</span><br><span class="line">例如:显式赋值</span><br><span class="line">private String name &#x3D; &quot;tom&quot;;</span><br><span class="line">3)调用构造器</span><br><span class="line">4)把对象内存地址值赋值给变量。(&#x3D;号赋值操作)</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造器的作用:</span><br><span class="line"></span><br><span class="line">类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点:</span><br><span class="line"><span class="number">1.</span> 必须和类的名字相同</span><br><span class="line"><span class="number">2.</span> 必须没有返回类型,也不能写<span class="keyword">void</span>构造器的作用:</span><br><span class="line"><span class="number">1.</span> 使用<span class="keyword">new</span>创建对象的时候必须使用类的构造器</span><br><span class="line"><span class="number">2.</span> 构造器中的代码执行后,可以给对象中的属性初始化赋值(构造方法传递参数)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构造器重载:</span><br><span class="line"></span><br><span class="line">除了无参构造器之外,很多时候我们还会使用有参构造器,在创建对象时候可以给属性赋值</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">构造器之间的调用:</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">this</span>关键字,在一个构造器中可以调用另一个构造器的代码。</span><br><span class="line">注意:<span class="keyword">this</span>的这种用法不会产生新的对象,只是调用了构造器中的代码而已.一般情况下只有使用<span class="keyword">new</span>关键字才会创建新对象。</span><br><span class="line">  </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">默认构造器:</span><br><span class="line"></span><br><span class="line">在java中,即使我们在编写类的时候没有写构造器,那么在编译之后也会自动的添加一个无参构造器,这个无参构造器也被称为默认的构造器。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line"><span class="comment">//编译通过,因为有无参构造器</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">但是,如果我们手动的编写了一个构造器,那么编译后就不会添加任何构造器了</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line"><span class="comment">//编译报错,因为没有无参构造器</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<ul>
<li>内存分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA程序运行的内存分析</span><br><span class="line"></span><br><span class="line">栈 stack：</span><br><span class="line">1. 每个线程私有，不能实现线程间的共享！</span><br><span class="line">2. 局部变量放置于栈中。</span><br><span class="line">3. 栈是由系统自动分配，速度快！栈是一个连续的内存空间！</span><br><span class="line"></span><br><span class="line">堆 heap：</span><br><span class="line">1. 放置new出来的对象！</span><br><span class="line">2. 堆是一个不连续的内存空间，分配灵活，速度慢！</span><br><span class="line"></span><br><span class="line">方法区(也是堆)：</span><br><span class="line">1. 被所有线程共享！</span><br><span class="line">2. 用来存放程序中永远是不变或唯一的内容。（类代码信息、静态变量、字符串常量）</span><br><span class="line"></span><br><span class="line">引用类型的概念</span><br><span class="line">1. java中，除了基本数据类型之外的其他类型称之为引用类型。</span><br><span class="line">2. java中的对象是通过引用来操作的。(引用：reference)说白了，引用指的就是对象的地址！</span><br><span class="line"></span><br><span class="line">属性（field，或者叫成员变量）</span><br><span class="line">1. 属性用于定义该类或该类对象包含的数据或者说静态属性。</span><br><span class="line">2. 属性作用范围是整个类体。</span><br><span class="line">3. 属性的默认初始化：</span><br><span class="line"></span><br><span class="line">4.属性定义格式</span><br><span class="line">[修饰符] 属性类型 属性名 &#x3D; [默认值]    &#x2F;&#x2F;默认值为0,或者null</span><br><span class="line"></span><br><span class="line">类的方法</span><br><span class="line">方法是类和对象动态行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序有一个个函数调用组成；面向对象中，整个程序的基本单位是类，方法是从属于类或对象的。</span><br><span class="line"></span><br><span class="line">方法定义格式：</span><br><span class="line">[修饰符] 方法返回值类型 方法名(形参列表) &#123;</span><br><span class="line">&#x2F;&#x2F; n条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java对象的创建和使用</span><br><span class="line">必须使用 <span class="keyword">new</span> 关键字创建对象。</span><br><span class="line">Person person= <span class="keyword">new</span> Person ();</span><br><span class="line">使用对象（引用） . 成员变量来引用对象的成员变量。</span><br><span class="line">person.age</span><br><span class="line">使用对象（引用） . 方法（参数列表）来调用对象的方法。</span><br><span class="line"><span class="number">1.</span> setAge(<span class="number">23</span>)</span><br><span class="line">类中就是：<span class="comment">//静态的数据 //动态的行为</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>java的三大特征:封装、继承、多态</strong></p>
</li>
<li><p>一、封装</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是封装?</span><br><span class="line"></span><br><span class="line">我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗？有必要碰碰显像管吗？</span><br><span class="line">制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：</span><br><span class="line">电源开关。需要让用户知道的暴露出来，不需要让用户了解的全部隐藏起来。这就是封装。</span><br><span class="line">白话：该露的露，该藏的藏</span><br><span class="line">专业：我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</span><br><span class="line">封装（数据的隐藏）</span><br><span class="line">在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。</span><br><span class="line">通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、封装的步骤</span><br><span class="line"><span class="number">1.</span> 使用<span class="keyword">private</span> 修饰需要封装的成员变量</span><br><span class="line"><span class="number">2.</span> 提供一个公开的方法设置或者访问私有的属性</span><br><span class="line">   设置 通过set方法，命名格式： set属性名（）; 属性的首字母要大写</span><br><span class="line">   访问 通过get方法，命名格式： get属性名（）; 属性的首字母要大写    </span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//对象能在类的外部&quot;直接&quot;访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在类中一般不会把数据直接暴露在外部的,而使用<span class="keyword">private</span>(私有)关键字把数据隐藏起来</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//编译报错,在类的外部不能直接访问类中的私有成员</span></span><br><span class="line">s.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果在类的外部需要访问这些私有属性,那么可以在类中提供对于的get和set方法,以便让用户在类的外部可以间接的访问到私有属性(用类提供的set、get方法操作封装对象)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//set负责给属性赋值</span></span><br><span class="line"><span class="comment">//get负责返回属性的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">System.out.println(s.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">封装的作用和意义:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 提高程序的安全性，保护数据。</span><br><span class="line"><span class="number">2.</span> 隐藏代码的实现细节</span><br><span class="line"><span class="number">3.</span> 统一用户的调用接口</span><br><span class="line"><span class="number">4.</span> 提高系统的可维护性</span><br><span class="line"><span class="number">5.</span> 便于调用者调用。</span><br><span class="line">良好的封装，便于修改内部代码，提高可维护性。</span><br><span class="line">良好的封装，可进行数据完整性检测，保证数据的有效性。</span><br></pre></td></tr></table></figure>

<ul>
<li>二、继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是继承?</span><br><span class="line"></span><br><span class="line">现实世界中的继承无处不在。比如：</span><br><span class="line">动物：哺乳动物、爬行动物</span><br><span class="line">哺乳动物：灵长目、鲸目等</span><br><span class="line">继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</span><br><span class="line">为什么需要继承？继承的作用？</span><br><span class="line">第一好处：继承的本质在于抽象。类是对对象的抽象，继承是对某一批类的抽象。</span><br><span class="line">第二好处：为了提高代码的复用性。</span><br><span class="line">extands的意思是“扩展”。子类是父类的扩展。</span><br><span class="line">【注】JAVA中类只有单继承，没有多继承！ 通过接口可以实现多继承！</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、继承</span><br><span class="line"><span class="number">1.</span> 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等。</span><br><span class="line"><span class="number">2.</span> 继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。子类继承父类,使用关键字extends来</span><br><span class="line">表示。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 子类和父类之间,从意义上讲应该具有<span class="string">&quot;is a&quot;</span>的关系.</span><br><span class="line">student is a person</span><br><span class="line">dog is a animal</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 类和类之间的继承是单继承</span><br><span class="line">一个子类只能<span class="string">&quot;直接&quot;</span>继承一个父类,就像是一个人只能有一个亲生父亲</span><br><span class="line">一个父类可以被多子类继承,就像一个父亲可以有多个孩子</span><br><span class="line">注:java中接口和接口之间,有可以继承,并且是多继承。 </span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 父类中的属性和方法可以被子类继承</span><br><span class="line">子类中继承了父类中的属性和方法后,在子类中能不能直接使用这些属性和方法,是和这些属性和方法原有的修饰符(<span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">default</span> <span class="keyword">private</span>)相关的。</span><br><span class="line">例如 :</span><br><span class="line">父类中的属性和方法使用<span class="keyword">public</span>修饰,在子类中继承后<span class="string">&quot;可以直接&quot;</span>使用</span><br><span class="line">父类中的属性和方法使用<span class="keyword">private</span>修饰,在子类中继承后<span class="string">&quot;不可以直接&quot;</span>使用</span><br><span class="line">注：具体细则在修饰符部分详细说明</span><br><span class="line">父类中的构造器是不能被子类继承的,但是子类的构造器中,会隐式的调用父类中的无参构造器(默认使用</span><br><span class="line"><span class="keyword">super</span>关键字)。</span><br><span class="line">注:具体细节在<span class="keyword">super</span>关键字部分详细说明    </span><br></pre></td></tr></table></figure>

<ul>
<li>object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">概述:</span><br><span class="line">java中的每一个类都是<span class="string">&quot;直接&quot;</span> 或者 <span class="string">&quot;间接&quot;</span>的继承了Object类.所以每一个对象都和Object类有<span class="string">&quot;is a&quot;</span>的关系。从API文档中,可以看到任何一个类最上层的父类都是Object。(Object类本身除外)AnyClass is a</span><br><span class="line">Object。</span><br><span class="line"></span><br><span class="line">代码理解</span><br><span class="line">System.out.println(任何对象 <span class="keyword">instanceof</span> Object);</span><br><span class="line"><span class="comment">//输出结果:true</span></span><br><span class="line"><span class="comment">//注:任何对象也包含数组对象</span></span><br><span class="line">例如:</span><br><span class="line"><span class="comment">//编译后,Person类会默认继承Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//Student是间接的继承了Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">在Object类中,提供了一些方法被子类继承,那么就意味着,在java中,任何一个对象都可以调用这些被继承过来的方法。(因为Object是所以类的父类)</span><br><span class="line">例如:toString方法、equals方法、getClass方法等</span><br><span class="line">注:Object类中的每一个方法之后都会使用到.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>super关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类继承父类之后,在子类中可以使用<span class="keyword">this</span>来表示访问或调用子类中的属性或方法,使用<span class="keyword">super</span>就表示访问或调用父类中的属性和方法。</span><br><span class="line"></span><br><span class="line">【访问父类中的属性】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        student hh =<span class="keyword">new</span> student();</span><br><span class="line">        hh.test(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//   结果为  zhangsan</span></span><br><span class="line"><span class="comment">//          lisi</span></span><br><span class="line"><span class="comment">//            zs</span></span><br><span class="line"></span><br><span class="line">【调用父类中的方法】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test hh = <span class="keyword">new</span> test();</span><br><span class="line">        hh.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:    Student</span></span><br><span class="line"><span class="comment">//        Student</span></span><br><span class="line"><span class="comment">//        Person</span></span><br><span class="line"></span><br><span class="line">【调用父类中的构造器】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//编译通过,子类构造器中会隐式的调用父类的无参构造器</span></span><br><span class="line"><span class="comment">//super();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类没有无参构造:</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//编译报错,子类构造器中会隐式的调用父类的无参构造器,但是父类中没有无参构造器</span></span><br><span class="line"><span class="comment">//super();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【显式的调用父类的有参构造器】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//编译通过,子类构造器中显式的调用父类的有参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：不管是显式还是隐式的父类的构造器,<span class="keyword">super</span>语句一定要出现在子类构造器中第一行代码。所以<span class="keyword">this</span>和<span class="keyword">super</span>不可能同时使用它们调用构造器的功能,因为它们都要出现在第一行代码位置。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//编译报错,super调用构造器的语句不是第一行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line"><span class="keyword">super</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【super使用的注意的地方】</span><br><span class="line">1. 用super调用父类构造方法，必须是构造方法中的第一个语句。</span><br><span class="line">2. super只能出现在子类的方法或者构造方法中。</span><br><span class="line">3. super 和 this 不能够同时调用构造方法。（因为this也是在构造方法的第一个语句）</span><br><span class="line"></span><br><span class="line">【super 和 this 的区别】</span><br><span class="line">1. 代表的事物不一样:</span><br><span class="line">this：代表所属方法的调用者对象</span><br><span class="line">super：代表父类对象的引用空间。</span><br><span class="line"></span><br><span class="line">2. 使用前提不一致：</span><br><span class="line">this：在非继承的条件下也可以使用。</span><br><span class="line">super：只能在继承的条件下才能使用</span><br><span class="line"></span><br><span class="line">3. 调用构造方法：</span><br><span class="line">this：调用本类的构造方法。</span><br><span class="line">super：调用的父类的构造方法</span><br></pre></td></tr></table></figure>

<ul>
<li>方法重写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法的重写（override）</span><br><span class="line">1. 方法重写只存在于子类和父类(包括直接父类和间接父类)之间。在同一个类中方法只能被重载，不</span><br><span class="line">能被重写.</span><br><span class="line">2. 静态方法不能重写</span><br><span class="line">1. 父类的静态方法不能被子类重写为非静态方法 &#x2F;&#x2F;编译出错</span><br><span class="line">2. 父类的非静态方法不能被子类重写为静态方法；&#x2F;&#x2F;编译出错</span><br><span class="line">3. 子类可以定义与父类的静态方法同名的静态方法(但是这个不是覆盖)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A类继承B类 A和B中都一个相同的静态方法test</span><br><span class="line">B a = <span class="keyword">new</span> A();</span><br><span class="line">a.test();<span class="comment">//调用到的是B类中的静态方法test</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.test();<span class="comment">//调用到的是A类中的静态方法test</span></span><br><span class="line">可以看出静态方法的调用只和变量声明的类型相关</span><br><span class="line">这个和非静态方法的重写之后的效果完全不同</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span> 私有方法不能被子类重写，子类继承父类后,是不能直接访问父类中的私有方法的,那么就更谈不上</span><br><span class="line">重写了。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译通过,但这不是重写,只是俩个类中分别有自己的私有方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 重写的语法</span><br><span class="line"><span class="number">1.</span> 方法名必须相同</span><br><span class="line"><span class="number">2.</span> 参数列表必须相同</span><br><span class="line"><span class="number">3.</span> 访问控制修饰符可以被扩大,但是不能被缩小： </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">default</span> <span class="keyword">private</span></span><br><span class="line"><span class="number">4.</span> 抛出异常类型的范围可以被缩小,但是不能被扩大</span><br><span class="line">    ClassNotFoundException ---&gt; Exception</span><br><span class="line"><span class="number">5.</span> 返回类型可以相同,也可以不同,如果不同的话,子类重写后的方法返回类型必须是父类方法返回类型的子类型</span><br><span class="line">例如：父类方法的返回类型是Person,子类重写后的返回类可以是Person也可以是Person的子类型</span><br><span class="line">注：一般情况下,重写的方法会和父类中的方法的声明完全保持一致,只有方法的实现不同。(也就是大括号中代码不一样)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译通过,子类继承父类,重写了run和test方法.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为什么要重写？</span><br><span class="line">子类继承父类,继承了父类中的方法,但是父类中的方法并不一定能满足子类中的功能需要,所以子类中需要把方法进行重写。</span><br><span class="line"><span class="number">1.</span> 总结：</span><br><span class="line">方法重写的时候，必须存在继承关系。</span><br><span class="line">方法重写的时候，方法名和形式参数 必须跟父类是一致的。</span><br><span class="line">方法重写的时候，子类的权限修饰符必须要大于或者等于父类的权限修饰符。</span><br><span class="line"> ( <span class="keyword">private</span> &lt; <span class="keyword">protected</span> &lt; <span class="keyword">public</span>，friendly &lt; <span class="keyword">public</span> )</span><br><span class="line">方法重写的时候，子类的返回值类型必须小于或者等于父类的返回值类型。( 子类 &lt; 父类 ) 数据类型没有明确的上下级关系</span><br><span class="line">方法重写的时候，子类的异常类型要小于或者等于父类的异常类型。</span><br></pre></td></tr></table></figure>

<ul>
<li>多态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、认识多态</span><br><span class="line">多态性是OOP中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。</span><br><span class="line">多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程，提高系统的可扩展性。</span><br><span class="line">允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</span><br><span class="line">相同类域的不同对象,调用相同的方法,执行结果是不同的</span><br><span class="line">    </span><br><span class="line">[理解<span class="number">1</span>:]多态是用来区别相同的对象的,比如都叫student对象.却也会有不同.    </span><br><span class="line">[理解<span class="number">2</span>:]</span><br><span class="line">    Person p = <span class="keyword">new</span> Sutdent()</span><br><span class="line">   在代码里声明成Person类型变量，是让我们忘记它的具体实现类型，将做什么和怎么做分离，这就是java的多态。当然这些如果运用的好的话，将会非常有效的改善我们代码的组织结构和可读性并且提升程序的扩展性。</span><br><span class="line">[理解<span class="number">3</span>:]</span><br><span class="line">    Person p = <span class="keyword">new</span> Sutdent()</span><br><span class="line">    p.getArea()</span><br><span class="line">    在运行期的时候取决于是哪个对象调用他的，规则是优先调用自己的这个getArea方法，如果自己没有这个方法就调用父类的getArea方法(------联系到反射的知识)  </span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span> 一个对象的实际类型是确定的</span><br><span class="line">例如: <span class="keyword">new</span> Student(); <span class="keyword">new</span> Person();等</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 可以指向对象的引用的类型有很多  </span><br><span class="line">一个对象的实现类型虽然是确定的,但是这个对象所属的类型可能有很多种</span><br><span class="line">例如: Student继承了Person类</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Person s2 = <span class="keyword">new</span> Student();</span><br><span class="line">Object s3 = <span class="keyword">new</span> Student();</span><br><span class="line">注:一个对象的实际类型是确定,但是可以指向这个对象的引用的类型,却是可以是这对象实际类型的任意</span><br><span class="line">    </span><br><span class="line">父类型。</span><br><span class="line"><span class="number">1.</span> 一个父类引用可以指向它的任何一个子类对象</span><br><span class="line">例如：  </span><br><span class="line">Object o = <span class="keyword">new</span> AnyClass();</span><br><span class="line">Person p = <span class="keyword">null</span>;</span><br><span class="line">p = <span class="keyword">new</span> Student();</span><br><span class="line">p = <span class="keyword">new</span> Teacher();</span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 多态中的方法调用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> 调用到的run方法,是Student从Person继承过来的run方法</span><br><span class="line">main:</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类有重写方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//重写run方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用到的run方法,是Student中重写的run方法</span></span><br><span class="line">main:</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run();</span><br><span class="line">注：子类继承父类,调用a方法，如果a方法在子类中没有重写,那么就是调用的是子类继承父类的a方法,</span><br><span class="line">如果重写了,那么调用的就是重写之后的方法。</span><br><span class="line">    </span><br><span class="line">子类中独有方法的调用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//调用到继承的run方法</span></span><br><span class="line">p.run();</span><br><span class="line"><span class="comment">//编译报错,因为编译器检查变量p的类型是Person,但是在Person类中并没有发现test方法,所以编</span></span><br><span class="line">译报错.</span><br><span class="line">p.test();</span><br><span class="line"></span><br><span class="line">注:一个变量x,调用一个方法test,编译器是否能让其编译通过,主要是看声明变量x的类型中有没有定义test方法,如果有则编译通过,如果没有则编译报错.而不是看x所指向的对象中有没有test方法.</span><br><span class="line"></span><br><span class="line">理解:     <span class="keyword">int</span> a =<span class="number">10</span></span><br><span class="line">         Person p = <span class="keyword">new</span> Student();</span><br><span class="line">创建一个叫a的<span class="keyword">int</span>类型,并给他赋值为<span class="number">10</span></span><br><span class="line">可预见的,创建一个叫做p的person类型,并给他赋值一个叫做student的对象,student对象是一个模板不是具体的值</span><br><span class="line">    </span><br><span class="line">原理：编译看左边，运行不一定看右边。</span><br><span class="line">编译看左边的意思：java 编译器在编译的时候会检测引用类型中含有指定的成员，如果没有就会报错。子类的成员是特有的，父类的没有的，所以他是找不到的。</span><br><span class="line"></span><br><span class="line">子类引用和父类引用指向对象的区别:</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">变量s能调用的方法是Student中有的方法(包括继承过来的),变量p能调用的方法是Person中有的方法(包括继承过来的)。</span><br><span class="line">但是变量p是父类型的,p不仅可以指向Student对象,还可以指向Teacher类型对象等,但是变量s只能指Studnet类型对象,及Student子类型对象。变量p能指向对象的范围是比变量s大的。</span><br><span class="line"> Object类型的变量o,能指向所有对象,它的范围最大,但是使用变量o能调用到的方法也是最少的,只能调用到Object中的声明的方法,因为变量o声明的类型就是Object.</span><br><span class="line">注：java中的方法调用,是运行时动态和对象绑定的,不到运行的时候,是不知道到底哪个方法被调用的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>重写、重载和多态的关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重载是编译时多态:</span><br><span class="line">调用重载的方法,在编译期间就要确定调用的方法是谁,如果不能确定则编译报错</span><br><span class="line"></span><br><span class="line">重写是运行时多态:</span><br><span class="line">调用重写的方法,在运行期间才能确定这个方法到底是哪个对象中的。这个取决于调用方法的引用,在运行期间所指向的对象是谁,这个引用指向哪个对象那么调用的就是哪个对象中的方法。(java中的方法调用,是运行时动态和对象绑定的)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多态的注意事项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 多态是方法的多态，属性没有多态性。</span><br><span class="line">2. 编写程序时，如果想调用运行时类型的方法，只能进行类型转换。不然通不过编译器的检查。但是如果两个没有关联的类进行强制转换，会报：ClassCastException。 </span><br><span class="line">比如：本来是狗，我把它转成猫。就会报这个异常。</span><br><span class="line">3. 多态的存在要有3个必要条件：要有继承，要有方法重写，父类引用指向子类对象</span><br></pre></td></tr></table></figure>

<ul>
<li>多态存在的条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 有继承关系</span><br><span class="line">2. 子类重写父类方法</span><br><span class="line">3. 父类引用指向子类对象</span><br><span class="line">补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没</span><br><span class="line">有办法表现出多态特性的（因为不能被重写）：</span><br><span class="line">1. static方法，因为被static修饰的方法是属于类的，而不是属于实例的</span><br><span class="line">2. final方法，因为被final修饰的方法无法被子类重写</span><br><span class="line">3. private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被</span><br><span class="line">protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个不能被外部引用的方法，怎么能谈多态呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>方法绑定(method binding)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行调用方法时，系统根据相关信息，能够执行内存地址中代表该方法的代码。分为静态绑定和动态绑</span><br><span class="line">定。</span><br><span class="line">静态绑定：</span><br><span class="line">在编译期完成，可以提高代码执行速度。</span><br><span class="line">动态绑定：</span><br><span class="line">通过对象调用的方法，采用动态绑定机制。这虽然让我们编程灵活，但是降低了代码的执行速度。这也</span><br><span class="line">是JAVA比C&#x2F;C++速度慢的主要因素之一。JAVA中除了final类、final方、static方法，所有方法都是JVM在</span><br><span class="line">运行期才进行动态绑定的。</span><br><span class="line">-----相关知识解释性语言,编译型语言(前面的笔记有)</span><br><span class="line">多态：如果编译时类型和运行时类型不一致，就会造成多态。</span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof和类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码解释:</span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">instanceof</span>类型转换 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">---------------------------</span><br><span class="line">        Person o = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> String);</span><br><span class="line">---------------------------</span><br><span class="line">        Student o = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Teacher);</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> String)</span><br><span class="line"> --------------------------</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【分析<span class="number">1</span>】:</span><br><span class="line">System.out.println(x <span class="keyword">instanceof</span> Y);</span><br><span class="line">该代码能否编译通过,主要是看声明变量x的类型和Y是否存在子父类的关系.有<span class="string">&quot;子父类关&quot;</span>系就编译通过,</span><br><span class="line">没有子父类关系就是编译报错.</span><br><span class="line">与接口类型是有区别的。</span><br><span class="line"></span><br><span class="line">【分析<span class="number">2</span>】:</span><br><span class="line">System.out.println(x <span class="keyword">instanceof</span> Y);</span><br><span class="line">输出结果是<span class="keyword">true</span>还是<span class="keyword">false</span>,主要是看变量x所指向的对象实际类型是不是Y类型的<span class="string">&quot;子类型&quot;</span>    </span><br><span class="line">Object o = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(o <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">System.out.println(o <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">System.out.println(o <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">System.out.println(o <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">类型转换:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【为什么要类型转换】</span><br><span class="line"><span class="comment">//编译报错,因为p声明的类型Person中没有go方法</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.go();</span><br><span class="line"><span class="comment">//需要把变量p的类型进行转换</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">Student s = (Student)p;</span><br><span class="line">s.go();</span><br><span class="line">或者</span><br><span class="line"><span class="comment">//注意这种形式前面必须要俩个小括号</span></span><br><span class="line">((Student)p).go();</span><br><span class="line"></span><br><span class="line">[理解:]没有<span class="keyword">new</span>就没有创建一个新对象,所以是吧之前的对象p进行了类型转换,用新的类型s调用</span><br><span class="line">[疑问<span class="number">1</span>:]转换完的类型s,调用go方法,和直接创建一个类型s调用go方法有什么区别</span><br><span class="line">上型转换对象使用的函数，是按照原子类对象来调用的，意思就是虽然student上型转换成了person，但是它指向的对象实质还是一个student对象，只是有部分person范围之外的变量或函数被过屏蔽了，但并没有被过滤到，被屏蔽的实际上还在，留下来可以和person兼容的部分，所以在上型转换后，如调用一个被student重写的person中的方法，则还是调用student中重写的那个</span><br><span class="line">[理解解答<span class="number">1</span>:]实际上p还是那个p对象,只是他能够用student类型的方法,如果person有一个go方法,那么他调用的还是person本身的方法.</span><br><span class="line"></span><br><span class="line">[详细理解<span class="number">1</span>]:子类重写父类的方法，子类对象在上溯类型转换后是调用子类重写的还是父类的方法</span><br><span class="line"></span><br><span class="line">代码分析:</span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"><span class="comment">//子类重写父类的方法，子类对象在上溯类型转换后是调用子类重写的还是父类的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.print(); <span class="comment">//调用B的print方法</span></span><br><span class="line">        b.prints(); <span class="comment">//调用B的prints方法</span></span><br><span class="line">        A a = (A)b;<span class="comment">//把b对象从B类型转换为A类型</span></span><br><span class="line">        a.print(); <span class="comment">//调用B的print方法</span></span><br><span class="line"><span class="comment">//a.prints(); //这里如果这样写,无法通过编译</span></span><br><span class="line">        a = <span class="keyword">new</span> B();</span><br><span class="line">        a.print(); <span class="comment">//调用B的print方法</span></span><br><span class="line">        <span class="comment">//a.prints();//Cannot resolve method &#x27;prints&#x27; in &#x27;A&#x27;</span></span><br><span class="line">        a = <span class="keyword">new</span> A();</span><br><span class="line">        a.print(); <span class="comment">//调用A的print方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父类类型调用子类对象重写的方法</span></span><br><span class="line">        A c = <span class="keyword">new</span> B();</span><br><span class="line">        c.print();<span class="comment">//B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prints</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BA~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line"><span class="comment">//B~~~~~~~~</span></span><br><span class="line"><span class="comment">//BA~~~~~~~~</span></span><br><span class="line"><span class="comment">//B~~~~~~~~</span></span><br><span class="line"><span class="comment">//B~~~~~~~~</span></span><br><span class="line"><span class="comment">//A~~~~~~~~</span></span><br><span class="line"><span class="comment">//B~~~~~~~~</span></span><br><span class="line">[总结:]调用的还是子类重写的方法~ 继承时,重写的多态只要记住一点就行..</span><br><span class="line">声明是什么,就只能调用它的方法,即 声明是父类,就只能调用父类的方法~</span><br><span class="line">实例化是什么,就执行它的方法,即 实例化是子类,那就执行子类的方法~实例化是父类,就执行父类的方法~</span><br><span class="line">(一个是声明,一个是实例.)    </span><br><span class="line">[要点:]总而言之一句话,父类类型转换后,用不了子类类型自定义方法,重写的可以用</span><br><span class="line">    </span><br><span class="line">【类型转换中的问题】:</span><br><span class="line"><span class="comment">//编译通过 运行没问题</span></span><br><span class="line">Object o = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = (Person)o;<span class="comment">//o转换成p</span></span><br><span class="line"><span class="comment">//编译通过 运行没问题</span></span><br><span class="line">Object o = <span class="keyword">new</span> Student();</span><br><span class="line">Student s = (Student)o;<span class="comment">//o转换成s</span></span><br><span class="line"><span class="comment">//编译通过,运行报错</span></span><br><span class="line">Object o = <span class="keyword">new</span> Teacher();</span><br><span class="line">Student s = (Student)o;<span class="comment">//student和teacher是同类型,例如猫和狗的例子,不可以强制转换</span></span><br><span class="line">即:</span><br><span class="line">X x = (X)o;</span><br><span class="line">运行是否报错,主要是变量o所指向的对象实现类型,是不是X类型的子类型,如果不是则运行就会报错。</span><br><span class="line">    </span><br><span class="line">【总结】</span><br><span class="line"><span class="number">1</span>、父类引用可以指向子类对象，子类引用不能指向父类对象。</span><br><span class="line"><span class="number">2</span>、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。</span><br><span class="line">如Father father = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="number">3</span>、把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。</span><br><span class="line">如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Son son =（Son）</span><br><span class="line">father；</span><br><span class="line">其中father前面的（Son）必须添加，进行强制转换。</span><br><span class="line"><span class="number">4</span>、upcasting 会丢失子类特有的方法,但是子类overriding 父类的方法，子类方法有效</span><br><span class="line"><span class="number">5</span>、向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样</span><br><span class="line">使代码变得简洁。体现了JAVA的抽象编程思想。</span><br><span class="line"></span><br><span class="line">[详细理解<span class="number">2</span>]   </span><br><span class="line"></span><br><span class="line">初始代码:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;  <span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtend</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">子类对象可以声明为父类类型，父类对象不可以声明为子类类型</span><br><span class="line">    </span><br><span class="line">代码分析:</span><br><span class="line">Test a=<span class="keyword">new</span> TestExtend();   <span class="comment">//正确</span></span><br><span class="line">TestExtend b=<span class="keyword">new</span> Test();   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">在子类对象声明为父类类型后，可以通过强制转型，转型回来</span><br><span class="line">    </span><br><span class="line">代码分析:</span><br><span class="line">Test a=<span class="keyword">new</span> TestExtend();</span><br><span class="line">TestExtend a=(TestExtend) b;         <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">而父类对象声明为父类类型之后，并不能执行强制类型转化</span><br><span class="line">    </span><br><span class="line">代码分析:</span><br><span class="line">Test a=<span class="keyword">new</span> Test();</span><br><span class="line">TestExtend a=(TestExtend) a;                  <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">因为在子类对象声明为父类类型后，其实对象的真实意义还是子类对象</span><br><span class="line">    </span><br><span class="line">Test a=<span class="keyword">new</span> Test();</span><br><span class="line">Test b=<span class="keyword">new</span> TestExtend();</span><br><span class="line"></span><br><span class="line">System.out.println(a <span class="keyword">instanceof</span> TestExtend) ;              <span class="comment">//输出false</span></span><br><span class="line">System.out.println(b <span class="keyword">instanceof</span> TestExtend);                 <span class="comment">//输出为true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>static修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">static</span>变量[在方法区中]</span><br><span class="line">在类中,使用<span class="keyword">static</span>修饰的成员变量,就是静态变量,反之为非静态变量。</span><br><span class="line">静态变量和非静态变量的区别</span><br><span class="line">静态变量属于类的,<span class="string">&quot;可以&quot;</span>使用类名来访问,非静态变量是属于对象的,<span class="string">&quot;必须&quot;</span>使用对象来访问</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//推荐使用类名访问静态成员</span></span><br><span class="line">System.out.println(Student.age);</span><br><span class="line">System.out.println(s.age);</span><br><span class="line">System.out.println(s.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态变量对于类而言在内存中只有一个,能被类的所有实例所共享。实例变量对于类的每个实例都有一份,</span><br><span class="line">它们之间互不影响.</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">            Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">            Student s3 = <span class="keyword">new</span> Student();</span><br><span class="line">            Student s4 = <span class="keyword">new</span> Student();</span><br><span class="line">            <span class="comment">//因为还是在类中,所以可以直接访问私有属性</span></span><br><span class="line">            System.out.println(s1.num);<span class="comment">//1</span></span><br><span class="line">            System.out.println(s2.num);<span class="comment">//1</span></span><br><span class="line">            System.out.println(s3.num);<span class="comment">//1</span></span><br><span class="line">            System.out.println(s4.num);<span class="comment">//1</span></span><br><span class="line">            <span class="comment">//System.out.println(Student.num);</span></span><br><span class="line">            <span class="comment">//Non-static field &#x27;num&#x27; cannot be referenced from a static context</span></span><br><span class="line">            <span class="comment">//不能从静态上下文中引用非静态字段“num”</span></span><br><span class="line">            <span class="comment">//造成原因：无实例化对象后，直接通过对象引用了非静态属性。</span></span><br><span class="line">            <span class="comment">//解决方法1：先实例化一个对象,通过对象调用该属性</span></span><br><span class="line">            <span class="comment">//解决方法2：将非静态属性改为静态属性（增加static关键字）。</span></span><br><span class="line">            System.out.println(Student.count);<span class="comment">//4</span></span><br><span class="line">            System.out.println(s1.count);<span class="comment">//4</span></span><br><span class="line">            System.out.println(s2.count);<span class="comment">//4</span></span><br><span class="line">            System.out.println(s3.count);<span class="comment">//4</span></span><br><span class="line">            System.out.println(s4.count);<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[解决困惑:]这边count跟着++的原因是静态变量从属于类,Student类加载他就加载,所以是执行了四次,而num从属于对象,对象只执行一次,所以就加载一次</span><br><span class="line"></span><br><span class="line">在加载类的过程中为静态变量分配内存,实例变量在创建对象时分配内存，所以静态变量可以使用类名来</span><br><span class="line">直接访问,而不需要使用对象来访问.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="keyword">static</span>方法</span><br><span class="line">在类中,使用<span class="keyword">static</span>修饰的成员方法,就是静态方法,反之为非静态方法。</span><br><span class="line">    </span><br><span class="line">静态方法和非静态方法的区别:</span><br><span class="line">静态方法数属于类的,<span class="string">&quot;可以&quot;</span>使用类名来调用,非静态方法是属于对象的,<span class="string">&quot;必须&quot;</span>使用对象来调用.</span><br><span class="line">静态方法<span class="string">&quot;不可以&quot;</span>直接访问类中的非静态变量和非静态方法,但是<span class="string">&quot;可以&quot;</span>直接访问类中的静态变量和静态</span><br><span class="line">方法</span><br><span class="line">注意:<span class="keyword">this</span>和<span class="keyword">super</span>在类中属于非静态的变量.(静态方法中不能使用)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">System.out.println(count);</span><br><span class="line">go();</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">非静态方法<span class="string">&quot;可以&quot;</span>直接访问类中的非静态变量和非静态方法,也<span class="string">&quot;可以&quot;</span>直接访问类中的静态变量和静态方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">System.out.println(count);</span><br><span class="line">go();</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">思考:为什么静态方法和非静态方法不能直接相互访问? 加载顺序的问题！</span><br><span class="line">[思考:]一个是伴随类加载的,一个是在加载后才创建的,静态方法不能使用非静态属性是因为静态方法加载在前,同理,非静态方法可以使用静态属性</span><br><span class="line">相关知识点--------方法区域</span><br><span class="line">    </span><br><span class="line">父类的静态方法可以被子类继承,但是不能被子类重写(包括写为非静态)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类可定义父类同名静态方法,但不是重写</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译通过,但不是重写</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.test();<span class="comment">//输出Person</span></span><br><span class="line">        p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.test();<span class="comment">//输出Perosn</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   结果为:   Person</span></span><br><span class="line"><span class="comment">//            Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是非静态的重写的话,结果应为   Student</span></span><br><span class="line"><span class="comment">//                               Person</span></span><br><span class="line"></span><br><span class="line">父类的非静态方法不能被子类重写为静态方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//父类的非静态不能被子类重写为静态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法&#x27;test()&#x27;无法覆盖实例方法&#x27;test()&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关于静态方法<span class="string">&#x27;test()&#x27;</span>无法覆盖实例方法<span class="string">&#x27;test()&#x27;</span></span><br><span class="line"></span><br><span class="line">[理解<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">在Java中我们静态方法的的选择是编译期就选择好的，是编译器自动根据声明类型帮我们选择的，它不依赖与任何对象。所以说从语义就可以看出<span class="keyword">static</span>、<span class="keyword">final</span>、<span class="keyword">private</span>方法本身都是编译期绑定的（也叫前期绑定）这些方法不存在多态，他们是在还没有运行的时候，程序在编译器里面就知道该调用哪个类的哪个方法了，而其他可观察的普通方法的绑定是在运行的时候根据具体的对象决定的，因为从语义上看这些方法是可被继承的，有了多态而造成了不确定性。</span><br><span class="line">    </span><br><span class="line">[理解<span class="number">2</span>:]父类和子类对比,父类先创建的.静态和非静态对比,静态先有的,所以对于子类来说,不能存在比父类先的东西,不符合先后逻辑.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码块和静态代码块</span><br><span class="line">    </span><br><span class="line">【类中可以编写代码块和静态代码块】</span><br><span class="line">    </span><br><span class="line">代码示例:    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//代码块(匿名代码块)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【匿名代码块和静态代码块的执行】</span><br><span class="line">因为没有名字,在程序并不能主动调用这些代码块。</span><br><span class="line">匿名代码块是在创建对象的时候自动执行的,并且在构造器执行之前。同时匿名代码块在每次创建对象的</span><br><span class="line">时候都会自动执行.</span><br><span class="line">静态代码块是在类加载完成之后就自动执行,并且只执行一次.</span><br><span class="line">注:每个类在第一次被使用的时候就会被加载,并且一般只会加载一次</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  结果         静态代码块</span></span><br><span class="line"><span class="comment">//              匿名代码块</span></span><br><span class="line"><span class="comment">//              构造器</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//              匿名代码块</span></span><br><span class="line"><span class="comment">//              构造器</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//              匿名代码块</span></span><br><span class="line"><span class="comment">//              构造器</span></span><br><span class="line"></span><br><span class="line">[疑问:]构造器和构造方法和类方法的不同点,以及<span class="keyword">static</span>修饰符那边的构造方法为什么调用静态变量count++执行成功,而成员变量num++没有执行成功</span><br><span class="line">    </span><br><span class="line">[解决:]这边count跟着++的原因是静态变量从属于类,Student类加载他就加载,所以是执行了四次,而num从属于对象,对象只执行一次,所以就加载一次(之前有遇到这个知识点,没想到是这么用的.....)</span><br><span class="line">    </span><br><span class="line">【匿名代码块和静态代码块的作用】    </span><br><span class="line">匿名代码块的作用是给对象的成员变量初始化赋值,但是因为构造器也能完成这项工作,所以匿名代码块</span><br><span class="line">使用的并不多。</span><br><span class="line">静态代码块的作用是给类中的静态成员变量初始化赋值。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">System.out.println(Person.name);<span class="comment">//tom</span></span><br><span class="line"></span><br><span class="line">注：在构造器中给静态变量赋值,并不能保证能赋值成功,因为构造器是在创建对象的时候才指向,但是静</span><br><span class="line">态变量可以不创建对象而直接使用类名来访问.(原因是经典的加载顺序)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建和初始化对象的过程</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">【Student类之前没有进行类加载】</span><br><span class="line"><span class="number">1.</span> 类加载,同时初始化类中静态的属性</span><br><span class="line"><span class="number">2.</span> 执行静态代码块</span><br><span class="line"><span class="number">3.</span> 分配内存空间,同时初始化非静态的属性(赋默认值,<span class="number">0</span>/<span class="keyword">false</span>/<span class="keyword">null</span>)</span><br><span class="line"><span class="number">4.</span> 调用Student的父类构造器</span><br><span class="line"><span class="number">5.</span> 对Student中的属性进行显示赋值(如果有的话)</span><br><span class="line"><span class="number">6.</span> 执行匿名代码块</span><br><span class="line"><span class="number">7.</span> 执行构造器</span><br><span class="line"><span class="number">8.</span> 返回内存地址</span><br><span class="line">注:子类中非静态属性的显示赋值是在父类构造器执行完之后和子类中的匿名代码块执行之前的时候</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person构造器&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person print方法: name = &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student匿名代码块&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student静态代码块&quot;</span>);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student构造器&quot;</span>);<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student print方法: name = &quot;</span>+name);<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为:  Student静态代码块</span></span><br><span class="line"><span class="comment">//        Person构造器</span></span><br><span class="line"><span class="comment">//        student print方法: name = null</span></span><br><span class="line"><span class="comment">//        Student匿名代码块</span></span><br><span class="line"><span class="comment">//        Student构造器</span></span><br><span class="line"></span><br><span class="line">静态导入</span><br><span class="line">    </span><br><span class="line">静态导包就是java包的静态导入，用<span class="keyword">import</span> <span class="keyword">static</span>代替<span class="keyword">import</span>静态导入包是JDK1.<span class="number">5</span>中的新特性。</span><br><span class="line">意思是导入这个类里的静态方法。</span><br><span class="line">好处：这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//之前是需要Math.random()调用的</span></span><br><span class="line">System.out.println(random());</span><br><span class="line">System.out.println(PI);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>final修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、修饰类</span><br><span class="line">用<span class="keyword">final</span>修饰的类不能被继承,没有子类。</span><br><span class="line">例如:我们是无法写一个类去继承String类,然后对String类型扩展的,因为API中已经被String类定义为<span class="keyword">final</span></span><br><span class="line">的了.</span><br><span class="line">我们也可以定义<span class="keyword">final</span>修饰的类:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Go</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、修饰方法</span><br><span class="line">用<span class="keyword">final</span>修饰的方法可以被继承,但是不能被子类的重写。</span><br><span class="line">例如:每个类都是Object类的子类,继承了Object中的众多方法,在子类中可以重写toString方法、equals方</span><br><span class="line">法等,但是不能重写getClass方法 wait方法等,因为这些方法都是使用fianl修饰的。</span><br><span class="line">我们也可以定义<span class="keyword">final</span>修饰的方法:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、修饰变量</span><br><span class="line">用<span class="keyword">final</span>修饰的变量表示常量,只能被赋一次值.其实使用<span class="keyword">final</span>修饰的变量也就成了常量了,因为值不会再变</span><br><span class="line">了。</span><br><span class="line">【修饰局部变量】</span><br><span class="line">    </span><br><span class="line"> 代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="comment">//编译报错,不能再次赋值,传参的时候已经赋过了</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译报错,不能再次赋值</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[疑惑点:]局部变量用<span class="keyword">final</span>修饰有啥用不?好像没什么用,生成的<span class="class"><span class="keyword">class</span>字节码是一样的,也许存在延长生命周期的可能,也可能调用完方法就被<span class="title">jvm</span>内存回收掉了.</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">【修饰成员变量-非静态成员变量】</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line">只有一次机会,可以给此变量a赋值的位置:</span><br><span class="line">声明的同时赋值</span><br><span class="line">匿名代码块中赋值</span><br><span class="line">构造器中赋值(类中出现的所有构造器都要写)</span><br><span class="line">    </span><br><span class="line">【修饰成员变量-静态成员变量】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line">只有一次机会,可以给此变量a赋值的位置:</span><br><span class="line">声明的同时赋值</span><br><span class="line">静态代码块中赋值</span><br><span class="line">    </span><br><span class="line">【修饰引用变量】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">main:</span><br><span class="line"><span class="keyword">final</span> Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">s.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">s.setName(<span class="string">&quot;zs&quot;</span>);</span><br><span class="line"><span class="comment">//编译报错,不能修改引用s指向的内存地址</span></span><br><span class="line">s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">总结 <span class="keyword">final</span>的作用就是延长生命周期和指定内存地址一旦声明就不能修改的作用.    </span><br></pre></td></tr></table></figure>

<ul>
<li>abstract修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span>修饰符可以用来修饰方法也可以修饰类,如果修饰方法,那么该方法就是抽象方法;如果修饰类,那</span><br><span class="line">么该类就是抽象类。</span><br><span class="line"><span class="number">1</span>、抽象类和抽象方法的关系</span><br><span class="line">抽象类中可以没有抽象方法,但是有抽象方法的类一定要声明为抽象类。</span><br><span class="line"><span class="number">2</span>、语法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">对于这个普通方法来讲:</span><br><span class="line"> <span class="string">&quot;public void doSomething()&quot;</span>这部分是方法的声明</span><br><span class="line"> <span class="string">&quot;&#123;...&#125;&quot;</span>这部分是方法的实现,如果大括号中什么都没写,就叫方法的空实现</span><br><span class="line">声明类的同时,加上<span class="keyword">abstract</span>修饰符就是抽象类</span><br><span class="line">声明方法的时候,加上<span class="keyword">abstract</span>修饰符,并且去掉方法的大口号,同时结尾加上分号,该方法就是抽象方法。</span><br><span class="line"><span class="number">3</span>、特点及作用</span><br><span class="line">抽象类,不能使用<span class="keyword">new</span>关键字来创建对象,它是用来让子类继承的。</span><br><span class="line">抽象方法,只有方法的声明,没有方法的实现,它是用来让子类实现的。</span><br><span class="line">注:子类继承抽象类后,需要实现抽象类中没有实现的抽象方法,否则这个子类也要声明为抽象类。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line"><span class="comment">//编译报错,抽象类不能new对象</span></span><br><span class="line">Action a = <span class="keyword">new</span> Action();</span><br><span class="line"><span class="comment">//子类继承抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eat</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line"><span class="comment">//实现父类中没有实现的抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">Action a = <span class="keyword">new</span> Eat();</span><br><span class="line">a.doSomething();</span><br><span class="line"></span><br><span class="line">注:子类继承抽象类,那么就必须要实现抽象类没有实现的抽象方法,否则该子类也要声明为抽象类。</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、思考</span><br><span class="line">    </span><br><span class="line">思考<span class="number">1</span> : 抽象类不能<span class="keyword">new</span>对象,那么抽象类中有没有构造器?</span><br><span class="line">    抽象类是不能被实例化,抽象类的目的就是为实现多态中的共同点,抽象类的构造器会在子类实例化时调</span><br><span class="line">用,因此它也是用来实现多态中的共同点构造，不建议这样使用！</span><br><span class="line">    </span><br><span class="line">思考<span class="number">2</span> : 抽象类和抽象方法意义(为什么要编写抽象类、抽象方法)</span><br><span class="line">    打个比方，要做一个游戏。如果要创建一个角色，如果反复创建类和方法会很繁琐和麻烦。建一个抽象类</span><br><span class="line">后。若要创建角色可直接继承抽象类中的字段和方法，而抽象类中又有抽象方法。如果一个角色有很多种</span><br><span class="line">职业，每个职业又有很多技能，要是依次实例这些技能方法会显得想当笨拙。定义抽象方法，在需要时继</span><br><span class="line">承后重写调用，可以省去很多代码。</span><br><span class="line">总之抽象类和抽象方法起到一个框架作用。很方便后期的调用和重写</span><br><span class="line">抽象方法是为了程序的可扩展性。重写抽象方法时即可实现同名方法但又非同目的的要求</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口的本质</span><br><span class="line"></span><br><span class="line">普通类：只有具体实现</span><br><span class="line">抽象类：具体实现和规范(抽象方法) 都有！</span><br><span class="line">接口：只有规范！</span><br><span class="line"></span><br><span class="line">【为什么需要接口?接口和抽象类的区别?】</span><br><span class="line">接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：</span><br><span class="line">规范和具体实现的分离。</span><br><span class="line">抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面</span><br><span class="line">向规范的，规定了一批类具有的公共方法规范。</span><br><span class="line">从接口的实现者角度看，接口定义了可以向外部提供的服务。</span><br><span class="line">从接口的调用者角度看，接口定义了实现者能提供那些服务。</span><br><span class="line">接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的系统之间模块之间的接口定义</span><br><span class="line">好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系</span><br><span class="line">统时往往就是使用“面向接口”的思想来设计系统。</span><br><span class="line"></span><br><span class="line">【接口的本质探讨】</span><br><span class="line">接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天</span><br><span class="line">使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则</span><br><span class="line">必须欺负好人。</span><br><span class="line">接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计 模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。</span><br><span class="line"></span><br><span class="line">接口与抽象类的区别</span><br><span class="line"></span><br><span class="line">抽象类也是类,除了可以写抽象方法以及不能直接new对象之外,其他的和普通类没有什么不一样的。接</span><br><span class="line">口已经是另一种类型了,和类是有本质的区别的,所以不能用类的标准去衡量接口。</span><br><span class="line">声明类的关键字是class,声明接口的关键字是interface。</span><br><span class="line">抽象类是用来被继承的,java中的类是单继承。</span><br><span class="line">类A继承了抽象类B,那么类A的对象就属于B类型了,可以使用多态</span><br><span class="line">一个父类的引用,可以指向这个父类的任意子类对象</span><br><span class="line">注:继承的关键字是extends</span><br><span class="line">接口是用来被类实现的,java中的接口可以被多实现。</span><br><span class="line">类A实现接口B、C、D、E..,那么类A的对象就属于B、C、D、E等类型了,可以使用多态</span><br><span class="line">一个接口的引用,可以指向这个接口的任意实现类对象</span><br><span class="line">注:实现的关键字是implements</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口中的方法都是抽象方法</span><br><span class="line">接口中可以不写任何方法,但如果写方法了,该方法必须是抽象方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//默认就是public abstract修饰的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接口中的变量都是静态常量(<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>修饰)</span><br><span class="line">接口中可以不写任何属性,但如果写属性了,该属性必须是<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>修饰的静态常量。</span><br><span class="line">注:可以直接使用接口名访问其属性。因为是<span class="keyword">public</span> <span class="keyword">static</span>修饰的</span><br><span class="line">注:声明的同时就必须赋值.(因为接口中不能编写静态代码块)</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line"><span class="comment">//默认就是public static final修饰的</span></span><br><span class="line"><span class="keyword">int</span> AGE = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">System.out.println(Action.NAME);</span><br><span class="line">System.out.println(Action.AGE);</span><br><span class="line"></span><br><span class="line">一个类可以实现多个接口</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,<span class="title">D</span></span>&#123;</span><br><span class="line"><span class="comment">//Student需要实现接口A B C D中所有的抽象方法</span></span><br><span class="line"><span class="comment">//否则Student类就要声明为抽象类,因为有抽象方法没实现</span></span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">A s1 = <span class="keyword">new</span> Student();</span><br><span class="line">B s2 = <span class="keyword">new</span> Student();</span><br><span class="line">C s3 = <span class="keyword">new</span> Student();</span><br><span class="line">D s4 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">s1只能调用接口A中声明的方法以及Object中的方法</span><br><span class="line">s2只能调用接口B中声明的方法以及Object中的方法</span><br><span class="line">s3只能调用接口C中声明的方法以及Object中的方法</span><br><span class="line">s4只能调用接口D中声明的方法以及Object中的方法</span><br><span class="line">注:必要时可以类型强制转换</span><br><span class="line">例如 : 接口A 中有test() ， 接口B 中有run()</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">A s1 = <span class="keyword">new</span> Student();</span><br><span class="line">s1.test();</span><br><span class="line">B s2 = <span class="keyword">new</span> Student();</span><br><span class="line">s2.run();</span><br><span class="line"><span class="keyword">if</span>(s1 <span class="keyword">instanceof</span> B)&#123;</span><br><span class="line">((B)s1).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一个接口可以继承多个父接口</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口C把接口A B中的方法都继承过来了</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student相当于实现了A B C三个接口,需要实现所有的抽象方法</span></span><br><span class="line"><span class="comment">//Student的对象也就同时属于A类型 B类型 C类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        C o = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> A);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> B);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> C);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//System.out.println(o instanceof Teacher);//false</span></span><br><span class="line"><span class="comment">//编译报错</span></span><br><span class="line">        <span class="comment">//System.out.println(o instanceof String);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注:System.out.println(o <span class="keyword">instanceof</span> X);</span><br><span class="line">如果o是一个接口类型声明的变量,那么只要X不是一个<span class="keyword">final</span>修饰的类,该代码就能通过编译,至于其结果</span><br><span class="line">是不是<span class="keyword">true</span>,就要看变量o指向的对象的实际类型,是不是X的子类或者实现类了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口的作用:</span><br><span class="line">接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建</span><br><span class="line">【接口名】 【对象名】= <span class="keyword">new</span> 【实现接口的类】</span><br><span class="line">这样你想用哪个类的对象就可以<span class="keyword">new</span>哪个对象了，不需要改原来的代码。</span><br><span class="line">假如我们两个类中都有个function()的方法，如果我用接口，那样我<span class="keyword">new</span> a()；就是用a的方法，<span class="keyword">new</span></span><br><span class="line">b（）就是用b的方法</span><br><span class="line">这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同</span><br><span class="line">总结：</span><br><span class="line"><span class="number">1</span>、Java接口中的成员变量默认都是<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span>类型的(都可省略),必须被显示初始化,即接</span><br><span class="line">口中的成员变量为常量(大写,单词之间用<span class="string">&quot;_&quot;</span>分隔)</span><br><span class="line"><span class="number">2</span>、Java接口中的方法默认都是<span class="keyword">public</span>,<span class="keyword">abstract</span>类型的(都可省略),没有方法体,不能被实例化</span><br><span class="line"><span class="number">3</span>、Java接口中只能包含<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span>类型的成员变量和<span class="keyword">public</span>,<span class="keyword">abstract</span>类型的成员方法</span><br><span class="line"><span class="number">4</span>、接口中没有构造方法,不能被实例化</span><br><span class="line"><span class="number">5</span>、一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口</span><br><span class="line"><span class="number">6</span>、Java接口必须通过类来实现它的抽象方法</span><br><span class="line"><span class="number">7</span>、当类实现了某个Java接口时,它必须实现接口中的所有抽象方法,否则这个类必须声明为抽象类</span><br><span class="line"><span class="number">8</span>、不允许创建接口的实例(实例化),但允许定义接口类型的引用变量,该引用变量引用实现了这个接口的类的实例</span><br><span class="line"><span class="number">9</span>、 一个类只能继承一个直接的父类,但可以实现多个接口,间接的实现了多继承.</span><br><span class="line">    </span><br><span class="line">[疑问:]继承里面为什么不能多继承</span><br></pre></td></tr></table></figure>

<ul>
<li>内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、内部类概述</span><br><span class="line">内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内</span><br><span class="line">部类，而A类相对B类来说就是外部类了。</span><br><span class="line">内部类不是在一个java源文件中编写俩个平行的俩个类,而是在一个类的内部再定义另外一个类。 我们</span><br><span class="line">可以把外边的类称为外部类,在其内部编写的类称为内部类。</span><br><span class="line">内部类分为四种：</span><br><span class="line"><span class="number">1.</span> 成员内部类</span><br><span class="line"><span class="number">2.</span> 静态内部类</span><br><span class="line"><span class="number">3.</span> 局部内部类</span><br><span class="line"><span class="number">4.</span> 匿名内部类</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、成员内部类（实例内部类、非静态内部类）</span><br><span class="line">注：成员内部类中不能写静态属性和方法</span><br><span class="line">【定义一个内部类】</span><br><span class="line"></span><br><span class="line">实现代码:</span><br><span class="line"><span class="comment">//在A类中申明了一个B类，此B类就在A的内部，并且在成员变量的位置上，所以就称为成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【实例化内部类】</span><br><span class="line">实例化内部类，首先需要实例化外部类，通过外部类去调用内部类</span><br><span class="line">    </span><br><span class="line">实现代码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化成员内部类分两步</span></span><br><span class="line"><span class="comment">//1、实例化外部类</span></span><br><span class="line">        Outer outObject = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">//2、通过外部类调用内部类</span></span><br><span class="line">        <span class="comment">// Person       p    =     new       Person();</span></span><br><span class="line">        Outer.Inner inObject = outObject.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//测试，调用内部类中的方法</span></span><br><span class="line">        inObject.in();<span class="comment">//结果：这是内部类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分析：想想如果你要使用一个类中方法或者属性，你就必须要先有该类的一个对象，同理，一个类在另</span><br><span class="line">一个类的内部，那么想要使用这个内部类，就必须先要有外部类的一个实例对象，然后在通过该对象去</span><br><span class="line">使用内部类。</span><br><span class="line">    </span><br><span class="line">【成员内部类能干什么？】</span><br><span class="line"><span class="number">1.</span> 访问外部类的所有属性(这里的属性包括私有的成员变量，方法) </span><br><span class="line">    </span><br><span class="line">实现代码:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部类访问外部类私有的成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useId</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id+<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部类访问外部类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">            out();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化成员内部类分两步</span></span><br><span class="line"><span class="comment">//1、实例化外部类</span></span><br><span class="line">        Outer outObject = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">//2、通过外部类调用内部类</span></span><br><span class="line">        Outer.Inner inObject = outObject.new Inner();</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">        inObject.useId();<span class="comment">//打印3，因为id初始化值为0，0+3就为3，其中在内部类就使用了外部类的私有成员变量id。</span></span><br><span class="line">        inObject.useOut();<span class="comment">//打印：这是外部类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如果内部类中的变量名和外部类的成员变量名一样，要通过创建外部类对象 <span class="string">&quot;.&quot;</span>属性来访问外部类属性，通过<span class="keyword">this</span>.属性访问内部类成员属性</span><br><span class="line"></span><br><span class="line">实现代码:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//默认初始化0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id=<span class="number">8</span>; <span class="comment">//这个id跟外部类的属性id名称一样。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(id);<span class="comment">//输出8，内部类中的变量会暂时将外部类的成员变量给隐藏</span></span><br><span class="line"><span class="comment">//如何调用外部类的成员变量呢？通过Outer.this，想要知道为什么能通过这个来调用，</span></span><br><span class="line"><span class="comment">//就得明白下面这个原理</span></span><br><span class="line"><span class="comment">//想实例化内部类对象，就必须通过外部类对象，当外部类对象来new出内部类对象时，会把自己(外部类对象)的引用传到了内部类中，所以内部类就可以通过</span></span><br><span class="line"><span class="comment">//Outer.this来访问外部类的属性和方法，到这里，你也就可以知道为什么内部类可以访问外部类</span></span><br><span class="line"><span class="comment">//的属性和方法，这里由于有两个相同的</span></span><br><span class="line"><span class="comment">//属性名称，所以需要显示的用Outer.this来调用外部类的属性，平常如果属性名</span></span><br><span class="line"><span class="comment">//不重复，那么我们在内部类中调用外部类的属性和方法时，前面就隐式的调用了Outer.this。</span></span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.id);<span class="comment">//输出外部类的属性id。也</span></span><br><span class="line"><span class="comment">//就是输出0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">借助成员内部类，来总结内部类(包括<span class="number">4</span>种内部类)的通用用法：</span><br><span class="line"> <span class="number">1</span>、要想访问内部类中的内容，必须通过外部类对象来实例化内部类。</span><br><span class="line"> <span class="number">2</span>、内部类能够访问外部类所有的属性和方法，原理就是在通过外部类对象实例化内部类对象时，外部类对象</span><br><span class="line">把自己的引用传进了内部类，使内部类可以用通过Outer.<span class="keyword">this</span>去调用外部类的属性和方法，</span><br><span class="line">一般都是隐式调用了，但是当内部类中有属性或者方法名和外部类中的属性或方法名相同的时候，就需</span><br><span class="line">要通过显式调用Outer.<span class="keyword">this</span>了。</span><br><span class="line">    </span><br><span class="line">[理解:]隐式调用的意思有点像是在接口中默认定义的变量都是<span class="keyword">public</span> <span class="keyword">static</span> Final,所以可以不写</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.javaSE.面向对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 内部类示例 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MemberInnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberInnerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">//内部类和外部类name变量重名</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">//内部类访问外部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="comment">//            mic.name=&quot;jik&quot;; mic是一个内部类对象</span></span><br><span class="line"><span class="comment">//            mic.test(&quot;kkk&quot;);</span></span><br><span class="line">            System.out.println(name);<span class="comment">//访问内部类name变量  结果 kkk</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);<span class="comment">//结果jik</span></span><br><span class="line">            System.out.println(MemberInnerClassTest.<span class="keyword">this</span>.name);<span class="comment">//访问外部类name变量 结果null</span></span><br><span class="line">            System.out.println(MemberInnerClassTest.age);<span class="comment">// 结果 0</span></span><br><span class="line">            MemberInnerClassTest.<span class="keyword">this</span>.run();</span><br><span class="line">            MemberInnerClassTest.go();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//外部类访问成员内部类</span></span><br><span class="line"><span class="comment">//成员内部类的对象要 依赖于外部类的对象的存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//MemberInnerClass mic = MemberInnerClassTest.this.new</span></span><br><span class="line">        <span class="keyword">new</span> MemberInnerClass();</span><br><span class="line"><span class="comment">//MemberInnerClass mic = this.new MemberInnerClass();</span></span><br><span class="line">        MemberInnerClass mic = <span class="keyword">new</span> MemberInnerClass();</span><br><span class="line">        mic.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">        mic.test(<span class="string">&quot;hua&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//MemberInnerClass mic = new MemberInnerClass();这个是不行的，this是动态的。</span></span><br><span class="line"><span class="comment">//所以要使用要先创建外部类对象，才能使用</span></span><br><span class="line">        MemberInnerClassTest out = <span class="keyword">new</span> MemberInnerClassTest();</span><br><span class="line">        <span class="comment">//out.name = &quot;hhh&quot;;  测试外部类名字</span></span><br><span class="line">        MemberInnerClass mic = out.new MemberInnerClass();</span><br><span class="line"><span class="comment">//如果内部类是private,则不能访问，只能通过内部方法来调用内部类</span></span><br><span class="line"></span><br><span class="line">        mic.name=<span class="string">&quot;jik&quot;</span>;</span><br><span class="line">        mic.test(<span class="string">&quot;kkk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态内部类:</span><br><span class="line">看到名字就知道，使用你<span class="keyword">static</span>修饰的内部类就叫静态内部类。</span><br><span class="line">既然提到了<span class="keyword">static</span>，那我们就来复习一下它的用法：一般只修饰变量和方法，平常不可以修饰类，但是内</span><br><span class="line">部类却可以被<span class="keyword">static</span>修饰。</span><br><span class="line"> <span class="number">1</span>）<span class="keyword">static</span>修饰成员变量：整个类的实例共享静态变量</span><br><span class="line"> <span class="number">2</span>）<span class="keyword">static</span>修饰方法：静态方法，只能够访问用<span class="keyword">static</span>修饰的属性或方法，而非静态方法可以访问<span class="keyword">static</span>修</span><br><span class="line">饰的方法或属性</span><br><span class="line"> <span class="number">3</span>）被<span class="keyword">static</span>修饰了的成员变量和方法能直接被类名调用。</span><br><span class="line"> <span class="number">4</span>）<span class="keyword">static</span>不能修饰局部变量，切记，不要搞混淆了，<span class="keyword">static</span>平常就用来修饰成员变量和方法。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//外部类访问静态内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StaticInnerClass sic = <span class="keyword">new</span> StaticInnerClass(); <span class="comment">//静态的内部类不需要依赖外部类，所以不用this</span></span><br><span class="line">        sic.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">        sic.test1(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        StaticInnerClass.age=<span class="number">10</span>;</span><br><span class="line">        StaticInnerClass.test2(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(StaticInnerClass.age);</span><br><span class="line">            System.out.println(StaticInnerClassTest.age);</span><br><span class="line"><span class="comment">//System.out.println(StaticInnerClassTest.this.name);静态类不能访问非静态属性</span></span><br><span class="line">            StaticInnerClassTest.go();</span><br><span class="line"><span class="comment">//StaticInnerClassTest.this.run();静态类不能访问非静态方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="comment">//只能访问自己和外部类的静态属性和方法</span></span><br><span class="line">            System.out.println(name);</span><br><span class="line"><span class="comment">//System.out.println(this.name);静态方法里面连自己类的非静态属性都不能访问</span></span><br><span class="line">            System.out.println(StaticInnerClass.age);</span><br><span class="line">            System.out.println(StaticInnerClassTest.age);</span><br><span class="line"><span class="comment">//System.out.println(StaticInnerClassTest.this.name);静态方法不能访问非静态属性</span></span><br><span class="line">            StaticInnerClassTest.go();</span><br><span class="line"><span class="comment">//StaticInnerClassTest.this.run();静态方法不能访问非静态方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"> <span class="number">1</span>、我们上面说的内部类能够调用外部类的方法和属性，在静态内部类中就行了，因为静态内部类没有</span><br><span class="line">了指向外部类对象的引用。除非外部类中的方法或者属性也是静态的。这就回归到了<span class="keyword">static</span>关键字的用</span><br><span class="line">法。</span><br><span class="line"> <span class="number">2</span>、静态内部类能够直接被外部类给实例化，不需要使用外部类对象</span><br><span class="line"> Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line"> <span class="number">3</span>、静态内部类中可以声明静态方法和静态变量，但是非静态内部类中就不可以声明静态方法和静态变</span><br><span class="line">量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>局部内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">局部内部类是在一个方法内部声明的一个类</span><br><span class="line">局部内部类中可以访问外部类的成员变量及方法</span><br><span class="line">局部内部类中如果要访问该内部类所在方法中的局部变量,那么这个局部变量就必须是<span class="keyword">final</span>修饰的</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">//在method01方法中有一个Inner内部类，这个内部类就称为局部内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是局部内部类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">局部内部类一般的作用跟在成员内部类中总结的差不多，但是有两个要注意的地方：</span><br><span class="line"><span class="number">1.</span> 在局部内部类中，如果要访问局部变量，那么该局部变量要用<span class="keyword">final</span>修饰</span><br><span class="line">    </span><br><span class="line">为什么需要使用<span class="keyword">final</span>？</span><br><span class="line"><span class="keyword">final</span>修饰变量：变为常量，会在常量池中放着，逆向思维想这个问题，如果不实用<span class="keyword">final</span>修饰，当局部内部类被实例化后，方法弹栈，局部变量随着跟着消失，这个时候局部内部类对象在想去调用该局部变量，就会报错，因为该局部变量已经没了，当局部变量用fanal修饰后，就会将其加入常量池中，即使方法弹栈了，该局部变量还在常量池中呆着，局部内部类也就是够调用。所以局部内部类想要调用局部变量时，需要使用<span class="keyword">final</span>修饰，不使用，编译度通不过。</span><br><span class="line"></span><br><span class="line">[进阶:]思考之前的问题,在在方法里用<span class="keyword">final</span>修饰局部变量是否延长生命周期?是的,这个变量放到常量池去了,不会随着栈消失而消失.</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> cid = <span class="number">3</span>; <span class="comment">//这个就是局部变量cid。要让局部内部类使用，就得变为</span></span><br><span class="line"><span class="keyword">final</span>并且赋值，如果不使用<span class="keyword">final</span>修饰，就会报错</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="comment">//内部类的第一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是局部内部类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类中的使用局部变量cid的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useCid</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(cid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象</span><br><span class="line">调用自己类中的方法。看下面例子就知道如何用了。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是局部内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//关键在这里，如需要在method01方法中自己创建内部类实例，然后调用内部类中的方法，等待外部类调用method01方法，就可以执行到内部类中的方法了。</span></span><br><span class="line">        Inner In = <span class="keyword">new</span> Inner();</span><br><span class="line">        In.in();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.method01();<span class="comment">//结果:这是局部内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用局部内部类需要注意的地方就刚才上面说的：</span><br><span class="line"> <span class="number">1</span>、在局部内部类中，如果要访问局部变量，那么该局部变量要用<span class="keyword">final</span>修饰</span><br><span class="line"> <span class="number">2</span>、如何调用局部内部类方法。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部内部类要定义在方法中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String myname=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="comment">// private static int age;不能定义静态属性</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="comment">//                lic.name=&quot;tom&quot;;</span></span><br><span class="line"><span class="comment">//                lic.test(&quot;test&quot;);</span></span><br><span class="line"><span class="comment">//     结果为:     test</span></span><br><span class="line"><span class="comment">//                tom</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                null</span></span><br><span class="line">                System.out.println(name);<span class="comment">//test</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name);<span class="comment">//tom</span></span><br><span class="line">                System.out.println(myname);<span class="comment">//这个是外部类的  没有定义与调用</span></span><br><span class="line">                System.out.println(LocalInnerClassTest.<span class="keyword">this</span>.name);<span class="comment">//null</span></span><br><span class="line">                LocalInnerClassTest.<span class="keyword">this</span>.run();</span><br><span class="line">                LocalInnerClassTest.go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//局部内部类只能在自己的方法中用,因为局部内部类相当于一个局部变量，除了方法就找不到了。</span></span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        lic.name=<span class="string">&quot;tom&quot;</span>;</span><br><span class="line">        lic.test(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClassTest o =<span class="keyword">new</span> LocalInnerClassTest();</span><br><span class="line">        o.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在这四种内部类中，以后的工作可能遇到最多的是匿名内部类，所以说匿名内部类是最常用的一种</span><br><span class="line">内部类。</span><br><span class="line">什么是匿名对象？如果一个对象只要使用一次，那么我们就是需要<span class="keyword">new</span> Object().method()。 就可以</span><br><span class="line">了，而不需要给这个实例保存到该类型变量中去。这就是匿名对象。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将new出来的Apple实例赋给apple变量保存起来，但是我们只需要用一次，就可以这样写</span></span><br><span class="line">Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">apple.eat();</span><br><span class="line"><span class="comment">//这种就叫做匿名对象的使用，不把实例保存到变量中。</span></span><br><span class="line"><span class="keyword">new</span> Apple().eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我要被吃了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">匿名内部类跟匿名对象是一个道理：</span><br><span class="line">匿名对象：我只需要用一次，那么我就不用声明一个该类型变量来保存对象了，</span><br><span class="line">匿名内部类：我也只需要用一次，那我就不需要在类中先定义一个内部类，而是等待需要用的时候，我</span><br><span class="line">就在临时实现这个内部类，因为用次数少，可能就这一次，那么这样写内部类，更方便。不然先写出一</span><br><span class="line">个内部类的全部实现来，然后就调用它一次，岂不是用完之后就一直将其放在那，那就没必要那样。</span><br><span class="line"><span class="number">1.</span> 匿名内部类需要依托于其他类或者接口来创建</span><br><span class="line">如果依托的是类,那么创建出来的匿名内部类就默认是这个类的子类</span><br><span class="line">如果依托的是接口,那么创建出来的匿名内部类就默认是这个接口的实现类。</span><br><span class="line"><span class="number">2.</span> 匿名内部类的声明必须是在使用<span class="keyword">new</span>关键字的时候</span><br><span class="line">匿名内部类的声明及创建对象必须一气呵成,并且之后能反复使用,因为没有名字。</span><br><span class="line">【示例】</span><br><span class="line">A是一个类(普通类、抽象类都可以)，依托于A类创建一个匿名内部类对象</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">main:</span><br><span class="line">A a = <span class="keyword">new</span> A()&#123;</span><br><span class="line"><span class="comment">//实现A中的抽象方法</span></span><br><span class="line"><span class="comment">//或者重写A中的普通方法</span></span><br><span class="line">&#125;;</span><br><span class="line">注:这个大括号里面其实就是这个内部类的代码,只不过是声明该内部类的同时就是要<span class="keyword">new</span>创建了其对象,</span><br><span class="line">并且不能反复使用,因为没有名字。</span><br><span class="line">例如:</span><br><span class="line">B是一个接口，依托于B接口创建一个匿名内部类对象</span><br><span class="line">B b = <span class="keyword">new</span> B()&#123;</span><br><span class="line"><span class="comment">//实现B中的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 匿名内部类除了依托的类或接口之外,不能指定继承或者实现其他类或接口,同时也不能被其他类所</span><br><span class="line">继承,因为没有名字。</span><br><span class="line"><span class="number">2.</span> 匿名内部类中,我们不能写出其构造器,因为没有名字。</span><br><span class="line"><span class="number">3.</span> 匿名内部类中,除了重写上面的方法外,一般不会再写其他独有的方法,因为从外部不能直接调用到。(间</span><br><span class="line">接是调用到的) </span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Work</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousOutterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">90</span>;</span><br><span class="line">        Work w = <span class="keyword">new</span> Work()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(AnonymousOutterClass.<span class="keyword">this</span>.name);<span class="comment">// 结果:null</span></span><br><span class="line">                System.out.println(AnonymousOutterClass.age);<span class="comment">// 结果: 0</span></span><br><span class="line">                AnonymousOutterClass.<span class="keyword">this</span>.say();</span><br><span class="line">                AnonymousOutterClass.go();</span><br><span class="line">                System.out.println(i);<span class="comment">// 结果: 90</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        w.doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         AnonymousOutterClass o = <span class="keyword">new</span> AnonymousOutterClass();</span><br><span class="line">         o.test();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们可以试一下不用匿名内部类和用匿名内部类实现一个接口中的方法的区别</span><br><span class="line">【不用匿名内部类】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果我们需要使用接口中的方法，我们就需要走3步，1、实现接口 2、创建实现接口类的实例对象 3、通过对象调用方法</span></span><br><span class="line"><span class="comment">//第二步</span></span><br><span class="line">        Test02 test = <span class="keyword">new</span> Test02();</span><br><span class="line"><span class="comment">//第三步</span></span><br><span class="line">        test.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口Test1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步、实现Test01接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test02</span> <span class="keyword">implements</span> <span class="title">Test01</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了Test接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【使用匿名内部类】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果我们需要使用接口中的方法，我们只需要走一步，就是使用匿名内部类，直接将其类的对象创建出来。</span></span><br><span class="line">        <span class="keyword">new</span> Test1()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现了Test接口的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解析：其实只要明白一点，<span class="keyword">new</span> Test1()&#123;实现接口中方法的代码&#125;; Test1()&#123;...&#125;这个的作用就是将接口给实现了，只不过这里实现该接口的是一个匿名类，也就是说这个类没名字，只能使用这一次，我们知道了这是一个类， 将其<span class="keyword">new</span>出来，就能获得一个实现了Test1接口的类的实例对象，通过该实例对象，就能调用该类中的方法了，因为其匿名类是在一个类中实现的，所以叫其匿名内部类</span><br></pre></td></tr></table></figure>

<h3 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常概念:</span><br><span class="line">在我们日常生活中,有时会出现各种各样的异常,例如:职工小王开车去上班,在正常情况下,小王会准时到达</span><br><span class="line">单位。但是天有不测风云,在小王去上班时,可能会遇到一些异常情况,比如小王的车子出了故障,小王只能</span><br><span class="line">改为步行.</span><br><span class="line">实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要</span><br><span class="line">求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据</span><br><span class="line">可能是空的等。我们的程序再跑着，内存或硬盘可能满了,等等。</span><br><span class="line">软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，</span><br><span class="line">意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</span><br><span class="line"></span><br><span class="line">异常指程序运行中出现的不期而至的各种状况,如:文件找不到、网络连接失败、非法参数等。</span><br><span class="line">异常发生在程序运行期间,它影响了正常的程序执行流程。</span><br><span class="line">比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error ；如果你用</span><br><span class="line">System.out.println(11&#x2F;0) ，那么你是因为你用0做了除数，会抛出</span><br><span class="line">java.lang.ArithmeticException 的异常。</span><br><span class="line">异常发生的原因有很多，通常包含以下几大类：</span><br><span class="line">用户输入了非法数据。</span><br><span class="line">要打开的文件不存在。</span><br><span class="line">网络通信时连接中断，或者JVM内存溢出。</span><br><span class="line">这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</span><br><span class="line">要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</span><br><span class="line"></span><br><span class="line">1.检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如</span><br><span class="line">要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</span><br><span class="line">2.运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译</span><br><span class="line">时被忽略。</span><br><span class="line">3.错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出</span><br><span class="line">时，一个错误就发生了，它们在编译也检查不到的。</span><br><span class="line"></span><br><span class="line">异常指不期而至的各种状况，如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个</span><br><span class="line">事件，它发生在程序运行期间，干扰了正常的指令流程。</span><br><span class="line">Java语言在设计的当初就考虑到这些问题，提出异常处理的框架的方案，所有的异常都可以用一个</span><br><span class="line">异常类来表示，不同类型的异常对应不同的子类异常（目前我们所说的异常包括错误概念），定义异常</span><br><span class="line">处理的规范，在 JDK1.4 版本以后增加了异常链机制，从而便于跟踪异常。</span><br><span class="line">Java异常是一个描述在代码段中发生异常的对象，当发生异常情况时，一个代表该异常的对象被创</span><br><span class="line">建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常体系结构</span><br><span class="line">Java把异常当作对象来处理，并定义一个基类 java.lang.Throwable 作为所有异常的超类。</span><br><span class="line">在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。</span><br><span class="line">Java异常层次结构图：</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/15/3ijA9xobKSuFD1P.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从图中可以看出所有异常类型都是内置类 Throwable 的子类，因而 Throwable 在异常类的层次结</span><br><span class="line">构的顶层。</span><br><span class="line">接下来 Throwable 分成了两个不同的分支，一个分支是Error，它表示不希望被程序捕获或者是程序</span><br><span class="line">无法处理的错误。另一个分支是Exception，它表示用户程序可能捕捉的异常情况或者说是程序可以处</span><br><span class="line">理的异常。</span><br><span class="line">其中异常类 Exception 又分为运行时异常( RuntimeException )和非运行时异常。Java异常又可以</span><br><span class="line">分为不受检查异常（ Unchecked Exception ）和检查异常（ Checked Exception ）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常之间的区别与联系</span><br><span class="line"></span><br><span class="line">1、Error</span><br><span class="line">Error 类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</span><br><span class="line">比如说：</span><br><span class="line"> Java虚拟机运行错误（ Virtual MachineError ），当JVM不再有继续执行操作所需的内存资源时，</span><br><span class="line">将出现 OutOfMemoryError 。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；</span><br><span class="line">还有发生在虚拟机试图执行应用时，如类定义错误（ NoClassDefFoundError ）、链接错误</span><br><span class="line">（ LinkageError ）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大</span><br><span class="line">多数是程序运行时不允许出现的状况。</span><br><span class="line">对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状</span><br><span class="line">况。在Java中，错误通常是使用 Error 的子类描述。</span><br><span class="line"></span><br><span class="line">2、Exception</span><br><span class="line">在 Exception 分支中有一个重要的子类 RuntimeException （运行时异常），该类型的异常自动</span><br><span class="line">为你所编写的程序定义 ArrayIndexOutOfBoundsException （数组下标越界）、</span><br><span class="line">NullPointerException （空指针异常）、ArithmeticException （算术异常）、 MissingResourceException （丢失资源）、ClassNotFoundException （找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</span><br><span class="line">这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而</span><br><span class="line">RuntimeException 之外的异常我们统称为非运行时异常，类型上属于 Exception 类及其子类，</span><br><span class="line">从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如</span><br><span class="line">IOException 、 SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检</span><br><span class="line">查异常。</span><br><span class="line">注意： Error 和 Exception 的区别： Error 通常是灾难性的致命的错误，是程序无法控制和</span><br><span class="line">处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程； Exception 通常情况下是可</span><br><span class="line">以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</span><br><span class="line"></span><br><span class="line">3、检查异常和不受检查异常</span><br><span class="line">检查异常：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的</span><br><span class="line">发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。</span><br><span class="line">解析：除了RuntimeException及其子类以外，其他的Exception类及其子类都属于检查异常，当程序</span><br><span class="line">中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通</span><br><span class="line">过。</span><br><span class="line">不受检查异常：包括RuntimeException及其子类和Error。</span><br><span class="line">分析： 不受检查异常 为编译器不要求强制处理的异常， 检查异常 则是编译器要求必须处置的异</span><br><span class="line">常。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java异常处理机制</span><br><span class="line"></span><br><span class="line">java异常处理本质：抛出异常和捕获异常</span><br><span class="line"><span class="number">1</span>、抛出异常</span><br><span class="line">要理解抛出异常，首先要明白什么是异常情形（exception condition），它是指阻止当前方法或作用域</span><br><span class="line">继续执行的问题。其次把异常情形和普通问题相区分，普通问题是指在当前环境下能得到足够的信息，</span><br><span class="line">总能处理这个错误。</span><br><span class="line">对于异常情形，已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，你所能做的</span><br><span class="line">就是从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，</span><br><span class="line">会有几件事随之发生。</span><br><span class="line">首先，是像创建普通的java对象一样将使用 <span class="keyword">new</span> 在堆上创建一个异常对象；然后，当前的执行路径</span><br><span class="line">（已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管</span><br><span class="line">程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。</span><br><span class="line">举例：</span><br><span class="line">假使我们创建了一个学生对象Student的一个引用stu,在调用的时候可能还没有初始化。所以在使用这个</span><br><span class="line">对象引用调用其他方法之前，要先对它进行检查，可以创建一个代表错误信息的对象，并且将它从当前</span><br><span class="line">环境中抛出，这样就把错误信息传播到更大的环境中。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">if</span>(stu == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、捕获异常</span><br><span class="line">在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常</span><br><span class="line">处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出</span><br><span class="line">的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的</span><br><span class="line">方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理</span><br><span class="line">器，则运行时系统终止。同时，意味着Java程序的终止。</span><br><span class="line">注意：</span><br><span class="line">对于 运行时异常 、 错误 和 检查异常 ，Java技术所要求的异常处理方式有所不同</span><br><span class="line">由于运行时异常及其子类的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将</span><br><span class="line">由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</span><br><span class="line">对于方法运行中可能出现的 Error ，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因</span><br><span class="line">为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</span><br><span class="line">    </span><br><span class="line">对于所有的检查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法</span><br><span class="line">选择不捕捉检查异常时，它必须声明将抛出异常。</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、异常处理五个关键字</span><br><span class="line">分别是： <span class="keyword">try</span> 、 <span class="keyword">catch</span> 、 <span class="keyword">finally</span> 、 <span class="keyword">throw</span> 、 <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">try</span> -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在<span class="keyword">try</span>语句块之内，当<span class="keyword">try</span>语句块内发生异常</span><br><span class="line">时，异常就被抛出。</span><br><span class="line"><span class="keyword">catch</span> -- 用于捕获异常。<span class="keyword">catch</span>用来捕获<span class="keyword">try</span>语句块中发生的异常。</span><br><span class="line"><span class="keyword">finally</span> -- <span class="keyword">finally</span>语句块总是会被执行。它主要用于回收在<span class="keyword">try</span>块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有<span class="keyword">finally</span>块，执行完成之后，才会回来执行<span class="keyword">try</span>或者<span class="keyword">catch</span>块中的<span class="keyword">return</span>或<span class="keyword">throw</span>语句，如果<span class="keyword">finally</span>中使用了<span class="keyword">return</span>或者<span class="keyword">throw</span>等终止方法的语句，则就不会跳回执行，直接停止。</span><br><span class="line"><span class="keyword">throw</span> -- 用于抛出异常。</span><br><span class="line"><span class="keyword">throws</span> -- 用在方法签名中，用于声明该方法可能抛出的异常。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">处理异常</span><br><span class="line"><span class="number">1</span>、<span class="keyword">try</span> -<span class="keyword">catch</span></span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//code that might generate exceptions</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//the code of handling exception1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//the code of handling exception2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">要明白异常捕获，还要理解 监控区域 （guarded region）的概念。它是一段可能产生异常的代码，</span><br><span class="line">并且后面跟着处理这些异常的代码。</span><br><span class="line">因而可知，上述 <span class="keyword">try</span>-<span class="keyword">catch</span> 所描述的即是监控区域，关键词 <span class="keyword">try</span> 后的一对大括号将一块可能发生</span><br><span class="line">异常的代码包起来，即为监控区域。Java方法在运行过程中发生了异常，则创建异常对象。</span><br><span class="line">将异常抛出监控区域之外，由Java运行时系统负责寻找匹配的 <span class="keyword">catch</span> 子句来捕获异常。若有一个</span><br><span class="line"><span class="keyword">catch</span> 语句匹配到了，则执行该 <span class="keyword">catch</span> 块中的异常处理代码，就不再尝试匹配别的 <span class="keyword">catch</span> 块</span><br><span class="line">了。</span><br><span class="line">匹配原则：如果抛出的异常对象属于 <span class="keyword">catch</span> 子句的异常类，或者属于该异常类的子类，则认为生成</span><br><span class="line">的异常对象与 <span class="keyword">catch</span> 块捕获的异常类型相匹配。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// try监控区域</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(); <span class="comment">// 通过throw语句抛出异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a/b的值是：&quot;</span> + a / b);</span><br><span class="line">            System.out.println(<span class="string">&quot;this will not be printed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">// catch捕捉异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常，变量b不能为0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序正常结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:    程序出现异常，变量b不能为0！</span></span><br><span class="line"><span class="comment">//        程序正常结束。</span></span><br><span class="line"></span><br><span class="line">注意：显示一个异常的描述， Throwable 重载了 toString() 方法（由 Object 定义），所以</span><br><span class="line">它将返回一个包含异常描述的字符串。例如，将前面的 <span class="keyword">catch</span> 块重写成：</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">// catch捕捉异常</span></span><br><span class="line">System.out.println(<span class="string">&quot;程序出现异常&quot;</span>+e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">程序出现异常java.lang.ArithmeticException</span><br><span class="line">程序正常结束。</span><br><span class="line"></span><br><span class="line">算术异常属于运行时异常，因而实际上该异常不需要程序抛出，运行时系统自动抛出。如果不用trycatch程序就不会往下执行了。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a/b的值是：&quot;</span> + a / b);</span><br><span class="line">System.out.println(<span class="string">&quot;this will not be printed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at TestException.main(TestException.java:<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">使用多重的<span class="keyword">catch</span>语句：很多情况下，由单个的代码段可能引起多个异常。处理这种情况，我们需要定</span><br><span class="line">义两个或者更多的 <span class="keyword">catch</span> 子句，每个子句捕获一种类型的异常，当异常被引发时，每个 <span class="keyword">catch</span> 子</span><br><span class="line">句被依次检查，第一个匹配异常类型的子句执行，当一个 <span class="keyword">catch</span> 子句执行以后，其他的子句将不被执行。</span><br><span class="line">编写多重<span class="keyword">catch</span>语句块注意事项：</span><br><span class="line">顺序问题：先小后大，即先子类后父类</span><br><span class="line">    </span><br><span class="line">注意：</span><br><span class="line">Java通过异常类描述异常类型。对于有多个 <span class="keyword">catch</span> 子句的异常程序而言，应该尽量将捕获底层异常类</span><br><span class="line">的 <span class="keyword">catch</span> 子句放在前面，同时尽量将捕获相对高层的异常类的 <span class="keyword">catch</span> 子句放在后面。否则，捕获</span><br><span class="line">底层异常类的 <span class="keyword">catch</span> 子句将可能会被屏蔽。</span><br><span class="line">    </span><br><span class="line">嵌套<span class="keyword">try</span>语句： <span class="keyword">try</span> 语句可以被嵌套。也就是说，一个 <span class="keyword">try</span> 语句可以在另一个 <span class="keyword">try</span> 块的内部。每</span><br><span class="line">次进入 <span class="keyword">try</span> 语句，异常的前后关系都会被推入堆栈。如果一个内部的 <span class="keyword">try</span> 语句不含特殊异常的</span><br><span class="line"><span class="keyword">catch</span> 处理程序，堆栈将弹出，下一个 <span class="keyword">try</span> 语句的 <span class="keyword">catch</span> 处理程序将检查是否与之匹配。这个</span><br><span class="line">过程将继续直到一个 <span class="keyword">catch</span> 语句被匹配成功，或者是直到所有的嵌套 <span class="keyword">try</span> 语句被检查完毕。如果</span><br><span class="line">没有 <span class="keyword">catch</span> 语句匹配，Java运行时系统将处理这个异常。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestTry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = args.length;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">42</span> / a;</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span>+ a);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">                    a = a/(a-a);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> c[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">                    c[<span class="number">42</span>] =<span class="number">99</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ArrayIndexOutOfBounds :&quot;</span>+e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Divide by 0&quot;</span>+ e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析运行：</span></span><br><span class="line">D:\java&gt;java NestTry one</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">Divide by <span class="number">0</span>java.lang.ArithmeticException: / by zero</span><br><span class="line">    </span><br><span class="line">D:\java&gt;java NestTry one two</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">ArrayIndexOutOfBounds :java.lang.ArrayIndexOutOfBoundsException: <span class="number">42</span></span><br><span class="line">    </span><br><span class="line">分析：正如程序中所显示的，该程序在一个<span class="keyword">try</span>块中嵌套了另一个 <span class="keyword">try</span> 块。程序工作如下：当你在没</span><br><span class="line">有命令行参数的情况下执行该程序，外面的 <span class="keyword">try</span> 块将产生一个被<span class="number">0</span>除的异常。</span><br><span class="line">程序在有一个命令行参数条件下执行，由嵌套的 <span class="keyword">try</span> 块产生一个被<span class="number">0</span>除的异常，由于内部的 <span class="keyword">catch</span></span><br><span class="line">块不匹配这个异常，它将把异常传给外部的 <span class="keyword">try</span> 块，在外部异常被处理。如果你在具有两个命令行参</span><br><span class="line">数的条件下执行该程序，将由内部 <span class="keyword">try</span> 块产生一个数组边界异常。</span><br><span class="line">    </span><br><span class="line">注意：当有方法调用时， <span class="keyword">try</span> 语句的嵌套可以很隐蔽的发生。例如，我们可以将对方法的调用放在一</span><br><span class="line">个 <span class="keyword">try</span> 块中。在该方法的内部，有另一个 <span class="keyword">try</span> 语句。</span><br><span class="line">在这种情况下，方法内部的 <span class="keyword">try</span> 仍然是嵌套在外部调用该方法的 <span class="keyword">try</span> 块中的。下面我们将对上述</span><br><span class="line">例子进行修改，嵌套的 <span class="keyword">try</span> 块移到方法nesttry()的内部：结果依旧相同！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestTry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nesttry</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">                a = a/(a-a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> c[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">                c[<span class="number">42</span>] =<span class="number">99</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayIndexOutOfBounds :&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = args.length;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">42</span> / a;</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span>+ a);</span><br><span class="line">            nesttry(a);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Divide by 0&quot;</span>+ e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过方法实现语句嵌套</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、thorw</span><br><span class="line">到目前为止，我们只是获取了被Java运行时系统引发的异常。然而，我们还可以用 <span class="keyword">throw</span> 语句抛出明</span><br><span class="line">确的异常。</span><br><span class="line">语法形式:</span><br><span class="line"><span class="keyword">throw</span> ThrowableInstance;</span><br><span class="line">这里的ThrowableInstance一定是 Throwable 类类型或者 Throwable 子类类型的一个对象。简单</span><br><span class="line">的数据类型，例如 <span class="keyword">int</span> ， <span class="keyword">char</span> ,以及非 Throwable 类，例如 String 或 Object ，不能用</span><br><span class="line">作异常。</span><br><span class="line">有两种方法可以获取 Throwable 对象：在 <span class="keyword">catch</span> 子句中使用参数或者使用 <span class="keyword">new</span> 操作符创建。程</span><br><span class="line">序执行完 <span class="keyword">throw</span> 语句之后立即停止； <span class="keyword">throw</span> 后面的任何语句不被执行，最邻近的 <span class="keyword">try</span> 块用来检</span><br><span class="line">查它是否含有一个与异常类型匹配的 <span class="keyword">catch</span> 语句。</span><br><span class="line">如果发现了匹配的块，控制转向该语句；如果没有发现，次包围的 <span class="keyword">try</span> 块来检查，以此类推。如果没</span><br><span class="line">有发现匹配的 <span class="keyword">catch</span> 块，默认异常处理程序中断程序的执行并且打印堆栈轨迹。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThrow</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught inside proc&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            proc();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Recaught: &quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为: Caught inside proc</span></span><br><span class="line"><span class="comment">//       Recaught: java.lang.NullPointerException: demo</span></span><br><span class="line"></span><br><span class="line">该程序两次处理相同的错误，首先， main() 方法设立了一个异常关系然后调用proc()。proc()方法设</span><br><span class="line">立了另一个异常处理关系并且立即抛出一个 NullPointerException 实例，</span><br><span class="line">NullPointerException 在 main() 中被再次捕获。</span><br><span class="line">该程序阐述了怎样创建Java的标准异常对象，特别注意这一行:</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">分析：此处 <span class="keyword">new</span> 用来构造一个 NullPointerException 实例，所有的Java内置的运行时异常有两</span><br><span class="line">个构造方法：一个没有参数，一个带有一个字符串参数。</span><br><span class="line">当用第二种形式时，参数指定描述异常的字符串。如果对象用作 print() 或者 println() 的参数</span><br><span class="line">时，该字符串被显示。这同样可以通过调用getMessage()来实现，getMessage()是由 Throwable 定</span><br><span class="line">义的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、<span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line">如果一个方法可以抛出一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己</span><br><span class="line">而不发生异常。要做到这点，我们可以在方法声明中包含一个 <span class="keyword">throws</span> 子句。</span><br><span class="line">一个 <span class="keyword">throws</span> 子句列举了一个方法可能引发的所有异常类型。这对于除了 Error 或</span><br><span class="line">RuntimeException 及它们子类以外类型的所有异常是必要的。一个方法可以引发的所有其他类型的</span><br><span class="line">异常必须在 <span class="keyword">throws</span> 子句中声明，否则会导致编译错误。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//body of method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception 是该方法可能引发的所有的异常,也可以是异常列表，中间以逗号隔开</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThrows</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throw1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Inside throw1 . &quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">throw1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line">上述例子中有两个地方存在错误，你能看出来吗？</span><br><span class="line">该例子中存在两个错误，首先，throw1()方法不想处理所导致的异常，因而它必须声明 <span class="keyword">throws</span> 子句</span><br><span class="line">来列举可能引发的异常即 IllegalAccessException ；其次， main() 方法必须定义</span><br><span class="line"><span class="keyword">try</span>/<span class="keyword">catch</span> 语句来捕获该异常。</span><br><span class="line">正确例子如下：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThrows</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throw1</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside throw1 . &quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            throw1();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IllegalAccessException e )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为:  Inside throw1 .</span></span><br><span class="line"><span class="comment">//        Caught java.lang.IllegalAccessException: demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">throws</span> 抛出异常的规则：</span><br><span class="line">如果是不受检查异常（ unchecked exception ），即 Error 、 RuntimeException 或它</span><br><span class="line">们的子类，那么可以不使用 <span class="keyword">throws</span> 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行</span><br><span class="line">时会被系统抛出。</span><br><span class="line">必须声明方法可抛出的任何检查异常（ checked exception ）。即如果一个方法可能出现,可</span><br><span class="line">查异常，要么用 <span class="keyword">try</span>-<span class="keyword">catch</span> 语句捕获，要么用 <span class="keyword">throws</span> 子句声明将它抛出，否则会导致编译错</span><br><span class="line">误</span><br><span class="line">仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异</span><br><span class="line">常的时候，应该继续抛出，而不是囫囵吞枣。</span><br><span class="line">调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同</span><br><span class="line">的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>、<span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">当异常发生时，通常方法的执行将做一个陡峭的非线性的转向，它甚至会过早的导致方法返回。例如，</span><br><span class="line">如果一个方法打开了一个文件并关闭，然后退出，你不希望关闭文件的代码被异常处理机制搁置。</span><br><span class="line"><span class="keyword">finally</span> 关键字为处理这种意外而设计。</span><br><span class="line"><span class="keyword">finally</span> 创建的代码块在 <span class="keyword">try</span>/<span class="keyword">catch</span> 块完成之后另一个 <span class="keyword">try</span>/<span class="keyword">catch</span> 出现之前执行。</span><br><span class="line"><span class="keyword">finally</span> 块无论有没有异常抛出都会执行。如果抛出异常，即使没有 <span class="keyword">catch</span> 子句匹配，</span><br><span class="line"><span class="keyword">finally</span> 也会执行。</span><br><span class="line">一个方法将从一个 <span class="keyword">try</span>/<span class="keyword">catch</span> 块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明</span><br><span class="line">确的返回语句， <span class="keyword">finally</span> 子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时</span><br><span class="line">被分配的其他资源是很有用。</span><br><span class="line">注意： <span class="keyword">finally</span> 子句是可选项，可以有也可以无，但是每个 <span class="keyword">try</span> 语句至少需要一个 <span class="keyword">catch</span> 或</span><br><span class="line">者 <span class="keyword">finally</span> 子句。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFinally</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inside proc1&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proc1&#x27;s finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inside proc2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proc2&#x27;s finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inside proc3&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proc3&#x27;s finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            proc1();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proc2();</span><br><span class="line">        proc3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为:  inside proc1</span></span><br><span class="line"><span class="comment">//        proc1&#x27;s finally</span></span><br><span class="line"><span class="comment">//        Exception caught</span></span><br><span class="line"><span class="comment">//        inside proc2</span></span><br><span class="line"><span class="comment">//        proc2&#x27;s finally</span></span><br><span class="line"><span class="comment">//        inside proc3</span></span><br><span class="line"><span class="comment">//        proc3&#x27;s finally</span></span><br><span class="line"></span><br><span class="line">注：如果 <span class="keyword">finally</span> 块与一个 <span class="keyword">try</span> 联合使用， <span class="keyword">finally</span> 块将在 <span class="keyword">try</span> 结束之前执行。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>, <span class="keyword">catch</span>,<span class="keyword">finally</span> ,<span class="keyword">return</span> 执行顺序</span><br><span class="line"><span class="number">1</span>．执行<span class="keyword">try</span>，<span class="keyword">catch</span> ， 给返回值赋值</span><br><span class="line"><span class="number">2</span>．执行<span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span>．<span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">自定义异常</span><br><span class="line">    </span><br><span class="line">使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。</span><br><span class="line">用户自定义异常类，只需继承 Exception 类即可。</span><br><span class="line">在程序中使用自定义异常类，大体可分为以下几个步骤:</span><br><span class="line">创建自定义异常类。</span><br><span class="line">在方法中通过 <span class="keyword">throw</span> 关键字抛出异常对象。</span><br><span class="line">如果在当前抛出异常的方法中处理异常，可以使用 <span class="keyword">try</span>-<span class="keyword">catch</span> 语句捕获并处理；否则在方法的</span><br><span class="line">声明处通过 <span class="keyword">throws</span> 关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</span><br><span class="line">在出现异常方法的调用者中捕获并处理异常。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line">    MyException(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        detail = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException [&quot;</span>+ detail + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TestMyException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Called compute(&quot;</span> + a + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Normal exit!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            compute(<span class="number">1</span>);</span><br><span class="line">            compute(<span class="number">20</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(MyException me)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught &quot;</span> + me);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为:  Called compute(1)</span></span><br><span class="line"><span class="comment">//        Normal exit!</span></span><br><span class="line"><span class="comment">//        Called compute(20)</span></span><br><span class="line"><span class="comment">//        Caught MyException [20]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://i.loli.net/2020/09/15/r5nflZ72EvbBsuD.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际应用中的经验与总结:</span><br><span class="line"></span><br><span class="line">1.处理运行时异常时,采用逻辑去合理规避同时辅助try-catch处理</span><br><span class="line">2.在多重catch块的后面,可以加一个catch(Exception)来处理可能会被遗漏的异常</span><br><span class="line">3.对于不确定的代码,也可以加上try-catch,处理潜在的异常</span><br><span class="line">4.尽量去除异常,切忌只是简单的调用printStackTrace()去打印输出</span><br><span class="line">5.具体如何处理异常,要根据不同的业务需求和异常类型去决定</span><br><span class="line">6.尽量添加finnal语句块去释放占用的资源</span><br></pre></td></tr></table></figure>

<h1 id="二、javaSE高级学习"><a href="#二、javaSE高级学习" class="headerlink" title="二、javaSE高级学习"></a>二、javaSE高级学习</h1><h3 id="一、常用类"><a href="#一、常用类" class="headerlink" title="一、常用类"></a>一、常用类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类</span><br><span class="line">    </span><br><span class="line">大家都知道Object是所有类的父类，任何类都默认继承Object。</span><br><span class="line">理论上Object类是所有类的父类，即直接或间接的继承java.lang.Object类。</span><br><span class="line">由于所有的类都继承在Object类，因此省略了extends Object关键字。</span><br><span class="line">该类中主要有以下方法:</span><br><span class="line">toString()</span><br><span class="line">getClass()</span><br><span class="line">equals()</span><br><span class="line">clone()</span><br><span class="line">finalize(</span><br><span class="line">其中toString(),getClass(),equals是其中最重要的方法。</span><br><span class="line"></span><br><span class="line">注意： Object类中的getClass(),notify(),notifyAll(),wait()等方法被定义为<span class="keyword">final</span>类型，因此不能重写。</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、clone() 方法</span><br><span class="line">    </span><br><span class="line">clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，</span><br><span class="line">首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几</span><br><span class="line">种方式可以创建对象呢？</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>使用<span class="keyword">new</span>操作符创建一个对象</span><br><span class="line"><span class="number">2.</span>使用clone方法复制一个对象</span><br><span class="line">    </span><br><span class="line">那么这两种方式有什么相同和不同呢？ <span class="keyword">new</span>操作符的本意是分配内存。程序执行到<span class="keyword">new</span>操作符时， 首</span><br><span class="line">先去看<span class="keyword">new</span>操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，</span><br><span class="line">再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完</span><br><span class="line">毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步</span><br><span class="line">是和<span class="keyword">new</span>相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）</span><br><span class="line">相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新</span><br><span class="line">的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</span><br><span class="line">    </span><br><span class="line">clone与copy的区别</span><br><span class="line">假设现在有一个Employee对象，Employee tobby =<span class="keyword">new</span> Employee(“CMTobby”,<span class="number">5000</span>)</span><br><span class="line">通常我们会有这样的赋值Employee cindyelf=tobby，这个时候只是简单了copy了一下reference(引用)，cindyelf和tobby都指向内存中同一个object，这样cindyelf或者tobby的一个操作都可能影响到对方。打个比方，如果我们通过cindyelf.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。我们希望得到tobby的一个精确拷贝，同时两者互不影响，这时候， 我们就可以使用Clone来满足我们的需求。Employee</span><br><span class="line">cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法。</span><br><span class="line">    </span><br><span class="line">[思考:]<span class="keyword">new</span>一个对象是浅拷贝,clone可以实现深拷贝.两者得区别是一个是引用拷贝,一个是创建了一个一样的对象,两者互不影响</span><br><span class="line">    </span><br><span class="line">Shallow Clone与Deep Clone</span><br><span class="line">主要是JAVA里除了<span class="number">8</span>种基本类型传参数是值传递，其他的类对象传参数都是引用，我们有时候不希望在</span><br><span class="line">方法里将参数改变，这时候就需要在类中复写clone方法（实现深复制）。</span><br><span class="line"> Clone是如何完成的呢？Object在对某个对象实施Clone时对其是一无所知的，它仅仅是简单地执行域</span><br><span class="line">对域的copy，这就是Shallow Clone。这样，问题就来了咯。</span><br><span class="line">以Employee为例，它里面有一个域hireDay不是基本数据类型的变量，而是一个reference变量，经过</span><br><span class="line">Clone之后就会产生一个新的Date型的reference，</span><br><span class="line">它和原始对象中对应的域指向同一个Date对象，这样克隆类就和原始类共享了一部分信息，而这样显然</span><br><span class="line">是不利的，过程下图所示：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/20/bfxJKCcYt9AiXZz.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个时候我们就需要进行deep Clone了，对那些非基本类型的域进行特殊的处理，例如本例中的</span><br><span class="line">hireDay。我们可以重新定义Clone方法，对hireDay做特殊处理，如下代码所示：</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Employee cloned = (Employee) <span class="keyword">super</span>.clone();</span><br><span class="line">cloned.hireDay = (Date) hireDay.clone()</span><br><span class="line"><span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone方法的保护机制</span><br><span class="line">在Object中Clone()是被声明为<span class="keyword">protected</span>的，这样做是有一定的道理的，以Employee类为例，通过声明</span><br><span class="line">为<span class="keyword">protected</span>，就可以保证只有Employee类里面才能“克隆”Employee对象.</span><br><span class="line">    </span><br><span class="line">clone方法的使用</span><br><span class="line">什么时候使用shallow Clone，什么时候使用deep Clone，这个主要看具体对象的域是什么性质的，基</span><br><span class="line">本还是reference variable再用deep Clone</span><br><span class="line">调用Clone()方法的对象所属的类(Class)必须implements Clonable接口，否则在调用Clone方法的时候</span><br><span class="line">会抛出CloneNotSupportedException</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>toString()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”</span><br><span class="line">和此对象哈希码的无符号十六进制表示组成。</span><br><span class="line">该方法用得比较多，一般子类都有覆盖。</span><br><span class="line">推荐在学习阶段所有有属性的类都加上toString() 方法！</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tostring</span>的使用 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(o1.toString());</span><br><span class="line">        <span class="comment">//输出的是01对象的地址</span></span><br><span class="line">        <span class="comment">//java.lang.Object@28d93b30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、getClass()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">返回的是Object的运行时类类型。</span><br><span class="line">不可重写，要调用的话，一般和getName()联合使用，如getClass().getName();</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(o.getClass());</span><br><span class="line"><span class="comment">//class java.lang.Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.f</span>inalize()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</span><br><span class="line">Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用</span><br><span class="line">的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用</span><br><span class="line">的内存。</span><br><span class="line">    </span><br><span class="line">关于垃圾回收，有三点需要记住：</span><br><span class="line"><span class="number">1</span>、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不</span><br><span class="line">到释放。</span><br><span class="line"><span class="number">2</span>、垃圾回收并不等于“析构”。</span><br><span class="line">【科普：析构函数(destructor) 与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完</span><br><span class="line">毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用<span class="keyword">new</span>开辟</span><br><span class="line">了一片内存空间，delete会自动调用析构函数后释放内存）。】</span><br><span class="line"><span class="number">3</span>、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。</span><br><span class="line">    </span><br><span class="line">finalize()的用途：</span><br><span class="line">无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。</span><br><span class="line">这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储</span><br><span class="line">空间。不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方</span><br><span class="line">式。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>equals()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object中的equals方法是直接判断<span class="keyword">this</span>和obj本身的值是否相等，即用来判断调用equals的对象和形参</span><br><span class="line">obj所引用的对象是否是同一对象，</span><br><span class="line">所谓同一对象就是指内存中同一块存储单元，如果<span class="keyword">this</span>和obj指向的hi同一块内存对象，则返回<span class="keyword">true</span>,如果</span><br><span class="line"><span class="keyword">this</span>和obj指向的不是同一块内存，则返回<span class="keyword">false</span>。</span><br><span class="line">注意：即便是内容完全相等的两块不同的内存对象，也返回<span class="keyword">false</span>。</span><br><span class="line">如果是同一块内存，则object中的equals方法返回<span class="keyword">true</span>,如果是不同的内存，则返回<span class="keyword">false</span></span><br><span class="line">如果希望不同内存但相同内容的两个对象equals时返回<span class="keyword">true</span>,则我们需要重写父类的equal方法</span><br><span class="line"> String类已经重写了object中的equals方法（这样就是比较内容是否相等了）</span><br><span class="line">【演示：查看String类源码equals方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String anotherString = (String)anObject;</span><br><span class="line"><span class="keyword">int</span> n = value.length;</span><br><span class="line"><span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"><span class="keyword">char</span> v1[] = value;</span><br><span class="line"><span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、hashCode()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">返回该对象的哈希码值。</span><br><span class="line">该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写</span><br><span class="line">hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</span><br><span class="line">一般必须满足obj1.equals(obj2)==<span class="keyword">true</span>。可以推出obj1.<span class="function">hash <span class="title">Code</span><span class="params">()</span> </span>== obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</span><br><span class="line">    </span><br><span class="line"><span class="number">7</span> wait()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">timeout++;</span><br><span class="line">&#125;</span><br><span class="line">wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/20/hM6TCN2wuB1eQtf.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。</span><br><span class="line">wait()方法一直等待，直到获得锁或者被中断。wait(<span class="keyword">long</span> timeout)设定一个超时间隔，</span><br><span class="line">如果在规定时间内没有获得锁就返回。</span><br><span class="line">调用该方法后当前线程进入睡眠状态，直到以下事件发生。</span><br><span class="line">（<span class="number">1</span>）其他线程调用了该对象的notify方法。</span><br><span class="line">（<span class="number">2</span>）其他线程调用了该对象的notifyAll方法。</span><br><span class="line">（<span class="number">3</span>）其他线程调用了interrupt中断该线程。</span><br><span class="line">（<span class="number">4</span>）时间间隔到了。</span><br><span class="line">此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>notify()方法</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">该方法唤醒在该对象上等待的某个线程。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">该方法唤醒在该对象上等待的所有线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包装类</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、包装类介绍</span><br><span class="line">虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类</span><br><span class="line">型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固</span><br><span class="line">的习惯，并的确能简单、有效地进行常规数据处理。</span><br><span class="line">这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要</span><br><span class="line">转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的</span><br><span class="line">类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</span><br><span class="line">    </span><br><span class="line">基本数据类型与对应的包装类如下图所示:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/20/YAZHNiq1Dyo98ta.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一</span><br><span class="line">经创建，其内容（所封装的基本类型数据值）不可改变。</span><br><span class="line">    </span><br><span class="line">基本类型和对应的包装类可以相互装换：</span><br><span class="line">由基本类型向对应的包装类转换称为装箱，例如把 <span class="keyword">int</span> 包装成 Integer 类的对象；</span><br><span class="line">包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 <span class="keyword">int</span>。</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、包装类的应用</span><br><span class="line">【<span class="number">1</span>、 实现 <span class="keyword">int</span> 和 Integer 的相互转换】</span><br><span class="line">可以通过 Integer 类的构造方法将 <span class="keyword">int</span> 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">int</span>的装箱和拆箱 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</span><br><span class="line">        Integer obj = <span class="keyword">new</span> Integer(m); <span class="comment">// 手动装箱 把int类型转换为Integer包装类类型</span></span><br><span class="line">        <span class="keyword">int</span> n = obj.intValue(); <span class="comment">// 手动拆箱 把Integer包装类类型转化为inr类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">        Integer obj1 = <span class="keyword">new</span> Integer(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));<span class="comment">//true 判断内容是否相等</span></span><br><span class="line">        System.out.println(obj1.toString()); <span class="comment">//500</span></span><br><span class="line">        System.out.println(obj1);<span class="comment">//500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[思考:]string重写了object的equals方法,如果说其中的属性是基本数据类型就只能用==比较值。如果是引用数据类型equals和==都行，比较内存地址和内容。如果是String类型equals比较内容，==比较内存地址和内容</span><br><span class="line">[疑惑:]什么时候equals是比较内容,什么时候是比较值和内容</span><br><span class="line"></span><br><span class="line">【<span class="number">2</span>、将字符串转换为整数】</span><br><span class="line">Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">parseInt(String s, <span class="keyword">int</span> radix);</span><br><span class="line"></span><br><span class="line">s 为要转换的字符串，radix 为进制，可选，默认为十进制。</span><br><span class="line">下面的代码将会告诉你什么样的字符串可以转换为整数：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 字符串整数的转换 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123abc&quot;</span>, <span class="string">&quot;abc123&quot;</span>, <span class="string">&quot;abcxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String str1 : str)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> m = Integer.parseInt(str1, <span class="number">10</span>);</span><br><span class="line">                System.out.println(str1 + <span class="string">&quot; 可以转换为整数 &quot;</span> + m);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(str1 + <span class="string">&quot; 无法转换为整数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">123</span> 可以转换为整数 <span class="number">123</span></span><br><span class="line"><span class="number">123</span>abc 无法转换为整数</span><br><span class="line">abc123 无法转换为整数</span><br><span class="line">abcxyz 无法转换为整数</span><br><span class="line">    </span><br><span class="line">[学习:]异常的使用方式</span><br><span class="line">    </span><br><span class="line">【 <span class="number">3</span>、将整数转换为字符串】</span><br><span class="line">Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。或者直接在整数后面加空字符串即可！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 将整数转换为字符串 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</span><br><span class="line">        String s = Integer.toString(m);</span><br><span class="line">        String s2 = m+<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);</span><br><span class="line">        <span class="comment">//结果为: s = 500</span></span><br><span class="line">        <span class="comment">//       s2 = 500a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、自动拆箱和装箱</span><br><span class="line">   </span><br><span class="line">上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java <span class="number">1.5</span>(<span class="number">5.0</span>) 之前必须手动拆箱装箱。</span><br><span class="line">Java <span class="number">1.5</span> 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进</span><br><span class="line">行，这将大大方便程序员的代码书写。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 自动拆箱装箱 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</span><br><span class="line">        Integer obj = m; <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="keyword">int</span> n = obj; <span class="comment">// 自动拆箱</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">        Integer obj1 = <span class="number">500</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));</span><br><span class="line">        <span class="comment">// 结果为:  n = 500</span></span><br><span class="line">        <span class="comment">//         obj 等价于 obj1？true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自动装箱与拆箱的功能事实上是编译器来帮您的忙，编译器在编译时期依您所编写的语法，决定是否进</span><br><span class="line">行装箱或拆箱动作。例如：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">相当于编译器自动为您作以下的语法编译：</span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">所以自动装箱与拆箱的功能是所谓的“编译器蜜糖”(Compiler Sugar)，虽然使用这个功能很方便，但在程</span><br><span class="line">序运行阶段您得了解Java的语义。例如下面的程序是可以通过编译的：</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">这样的语法在编译时期是合法的，但是在运行时期会有错误，因为这种写法相当于：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i.intValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>表示i 没有参考至任何的对象实体，它可以合法地指定给对象参考名称。由于实际上i并没有参考至任</span><br><span class="line">何的对象，所以也就不可能操作intValue()方法，这样上面的写法在运行时会出现NullPointerException</span><br><span class="line">错误。</span><br><span class="line">    </span><br><span class="line">自动拆箱装箱是常用的一个功能，需要重点掌握。</span><br><span class="line">一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：<span class="keyword">byte</span>、<span class="keyword">int</span>、<span class="keyword">long</span>、<span class="keyword">double</span> 等。然</span><br><span class="line">而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问</span><br><span class="line">题，Java 语言为每一个内置数据类型提供了对应的包装类。</span><br><span class="line">    </span><br><span class="line">所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math类</span><br><span class="line">    </span><br><span class="line">Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</span><br><span class="line">Math 的方法都被定义为 <span class="keyword">static</span> 形式，通过 Math 类可以在主函数中直接调用。</span><br><span class="line">【演示：查看Math类的源码】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line"><span class="comment">//数学方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【常用值与函数】</span><br><span class="line">Math.PI 记录的圆周率</span><br><span class="line">Math.E 记录e的常量</span><br><span class="line">Math中还有一些类似的常量，都是一些工程数学常用量。</span><br><span class="line">Math.abs 求绝对值</span><br><span class="line">Math.sin 正弦函数 Math.asin 反正弦函数</span><br><span class="line">Math.cos 余弦函数 Math.acos 反余弦函数</span><br><span class="line">Math.tan 正切函数 Math.atan 反正切函数 Math.atan2 商的反正切函数</span><br><span class="line">Math.toDegrees 弧度转化为角度 Math.toRadians 角度转化为弧度</span><br><span class="line">Math.ceil 得到不小于某数的最大整数</span><br><span class="line">Math.floor 得到不大于某数的最大整数</span><br><span class="line">Math.IEEEremainder 求余</span><br><span class="line">Math.max 求两数中最大</span><br><span class="line">Math.min 求两数中最小</span><br><span class="line">Math.sqrt 求开方</span><br><span class="line">Math.pow 求某数的任意次方, 抛出ArithmeticException处理溢出异常</span><br><span class="line">Math.exp 求e的任意次方</span><br><span class="line">Math.log10 以<span class="number">10</span>为底的对数</span><br><span class="line">Math.log 自然对数</span><br><span class="line">Math.rint 求距离某数最近的整数（可能比某数大，也可能比它小）</span><br><span class="line">Math.round 同上，返回<span class="keyword">int</span>型或者<span class="keyword">long</span>型（上一个函数返回<span class="keyword">double</span>型）</span><br><span class="line">Math.random 返回<span class="number">0</span>，<span class="number">1</span>之间的一个随机数</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">math</span>类的示例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *Math.sqrt()//计算平方根</span></span><br><span class="line"><span class="comment"> *Math.cbrt()//计算立方根</span></span><br><span class="line"><span class="comment"> *Math.pow(a, b)//计算a的b次方</span></span><br><span class="line"><span class="comment"> *Math.max( , );//计算最大值</span></span><br><span class="line"><span class="comment"> *Math.min( , );//计算最小值</span></span><br><span class="line"><span class="comment"> * 有意思的一些东西,源代码PI的定义只有到小数点后20位数,源代码只读不可更改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">16</span>)); <span class="comment">//4.0</span></span><br><span class="line">        System.out.println(Math.cbrt(<span class="number">8</span>)); <span class="comment">//2.0</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">3</span>,<span class="number">2</span>)); <span class="comment">//9.0</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">2.3</span>,<span class="number">4.5</span>));<span class="comment">//4.5</span></span><br><span class="line">        System.out.println(Math.min(<span class="number">2.3</span>,<span class="number">4.5</span>));<span class="comment">//2.3</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * abs求绝对值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.4</span>)); <span class="comment">//10.4</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10.1</span>)); <span class="comment">//10.1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ceil天花板的意思，就是返回大的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">10.1</span>)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">10.7</span>)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">0.7</span>)); <span class="comment">//-0.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">0.0</span>)); <span class="comment">//0.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">0.0</span>)); <span class="comment">//-0.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">1.7</span>)); <span class="comment">//-1.0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * floor地板的意思，就是返回小的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">10.1</span>)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">10.7</span>)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">0.7</span>)); <span class="comment">//-1.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">0.0</span>)); <span class="comment">//0.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">0.0</span>)); <span class="comment">//-0.0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * random 取得一个大于或者等于0.0小于不等于1.0的随机数 [0,1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.random()); <span class="comment">//小于1大于0的double类型的数</span></span><br><span class="line">        System.out.println(Math.random()+<span class="number">1</span>);<span class="comment">//大于1小于2的double类型的数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rint 四舍五入，返回double值</span></span><br><span class="line"><span class="comment"> * 注意.5的时候会取偶数 异常的尴尬=。=</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.rint(<span class="number">10.1</span>)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.rint(<span class="number">10.7</span>)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.rint(<span class="number">11.5</span>)); <span class="comment">//12.0</span></span><br><span class="line">        System.out.println(Math.rint(<span class="number">10.5</span>)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.rint(<span class="number">10.51</span>)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.rint(-<span class="number">10.5</span>)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(Math.rint(-<span class="number">11.5</span>)); <span class="comment">//-12.0</span></span><br><span class="line">        System.out.println(Math.rint(-<span class="number">10.51</span>)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(Math.rint(-<span class="number">10.6</span>)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(Math.rint(-<span class="number">10.2</span>)); <span class="comment">//-10.0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * round 四舍五入，float时返回int值，double时返回long值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.1</span>)); <span class="comment">//10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.7</span>)); <span class="comment">//11</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>)); <span class="comment">//11</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.51</span>)); <span class="comment">//11</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">10.5</span>)); <span class="comment">//-10</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">10.51</span>)); <span class="comment">//-11</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">10.6</span>)); <span class="comment">//-11</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">10.2</span>)); <span class="comment">//-10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random类</span><br><span class="line">    </span><br><span class="line">Java中存在着两种Random函数：</span><br><span class="line">一、java.lang.Math.Random;</span><br><span class="line">调用这个Math.Random()函数能够返回带正号的<span class="keyword">double</span>值，该值大于等于<span class="number">0.0</span>且小于<span class="number">1.0</span>，即取值范围是</span><br><span class="line">[<span class="number">0.0</span>,<span class="number">1.0</span>)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。例子如下：</span><br><span class="line"> </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 结果是个double类型的值，区间为[0.0,1.0）</span></span><br><span class="line">System.out.println(<span class="string">&quot;Math.random()=&quot;</span> + Math.random());</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 注意不要写成(int)Math.random()*3，这个结果为0或1，因为先执行了强制转换</span></span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Math.random()=0.44938147153848396</span></span><br><span class="line"><span class="comment">//num=1</span></span><br><span class="line"></span><br><span class="line"> 二、java.util.Random</span><br><span class="line">下面是Random()的两种构造方法：</span><br><span class="line"> Random()：创建一个新的随机数生成器。</span><br><span class="line"> Random(<span class="keyword">long</span> seed)：使用单个 <span class="keyword">long</span> 种子创建一个新的随机数生成器。</span><br><span class="line">你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，</span><br><span class="line">和生成的随机数的区间没有任何关系。</span><br><span class="line">如下面的Java代码：</span><br><span class="line">【演示一】</span><br><span class="line">在没带参数构造函数生成的Random对象的种子缺省是当前系统时间的毫秒数。</span><br><span class="line">rand.nextInt(<span class="number">100</span>)中的<span class="number">100</span>是随机数的上限,产生的随机数为<span class="number">0</span>-<span class="number">100</span>的整数,不包括<span class="number">100</span>。</span><br><span class="line"> </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">random</span>类的使用2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand =<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> i=rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[疑惑:种子是什么?]随机函数产生的是一种伪随机数，它实际是一种序列发生器，有固定的算法，只有当种子不同时，序列才不同，所以不应该把种子固定在程序中，应该用随机产生的数做种子，如程序运行时的时间等。</span><br><span class="line">以c++为例，应先用srand()设置不同种子，否则每次调用rand()得到的值是一样的。</span><br><span class="line"> </span><br><span class="line">【演示二】</span><br><span class="line">对于种子相同的Random对象，生成的随机数序列是一样的。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">random</span>类的使用3 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random ran1 = <span class="keyword">new</span> Random(<span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用种子为25的Random对象生成[0,100)内随机整数序列: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(ran1.nextInt(<span class="number">100</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">【方法摘要】</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span>：生成下一个伪随机数。</span></span><br><span class="line"><span class="function">2. <span class="keyword">boolean</span> <span class="title">nextBoolean</span><span class="params">()</span>：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>值。</span></span><br><span class="line"><span class="function">3. <span class="keyword">void</span> <span class="title">nextBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span>：生成随机字节并将其置于用户提供的 <span class="keyword">byte</span> 数组中。</span></span><br><span class="line"><span class="function">4. <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span>：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间</span></span><br><span class="line"><span class="function">均匀分布的 <span class="keyword">double</span>值。</span></span><br><span class="line"><span class="function">5. <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span>：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分</span></span><br><span class="line"><span class="function">布<span class="keyword">float</span>值。</span></span><br><span class="line"><span class="function">6. <span class="keyword">double</span> <span class="title">nextGaussian</span><span class="params">()</span>：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正</span></span><br><span class="line"><span class="function">态”）分布的<span class="keyword">double</span>值，其平均值是0.0标准差是1.0。</span></span><br><span class="line"><span class="function">7. <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span>：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 <span class="keyword">int</span> 值。</span></span><br><span class="line"><span class="function">8. <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span>：返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不</span></span><br><span class="line"><span class="function">包括）之间均匀分布的<span class="keyword">int</span>值。</span></span><br><span class="line"><span class="function">9. <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span>：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 <span class="keyword">long</span> 值。</span></span><br><span class="line"><span class="function">10. <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span>：使用单个 <span class="keyword">long</span> 种子设置此随机数生成器的种子。</span></span><br><span class="line"><span class="function">【例子】</span></span><br><span class="line"><span class="function">1. 生成[0,1.0)区间的小数：<span class="keyword">double</span> d1 </span>= r.nextDouble();</span><br><span class="line"><span class="number">2.</span> 生成[<span class="number">0</span>,<span class="number">5.0</span>)区间的小数：<span class="keyword">double</span> d2 = r.nextDouble() * <span class="number">5</span>;</span><br><span class="line"><span class="number">3.</span> 生成[<span class="number">1</span>,<span class="number">2.5</span>)区间的小数：<span class="keyword">double</span> d3 = r.nextDouble() * <span class="number">1.5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="number">4.</span> 生成[<span class="number">0</span>,<span class="number">10</span>)区间的整数：<span class="keyword">int</span> n2 = r.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">日期时间类</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、Date类</span><br><span class="line">java.util 包提供了 Date 类来封装当前的日期和时间。</span><br><span class="line">Date 类提供两个构造函数来实例化 Date 对象。</span><br><span class="line">第一个构造函数使用当前日期和时间来初始化对象。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">Date()</span><br><span class="line">    </span><br><span class="line">第二个构造函数接收一个参数，该参数是从<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日起的毫秒数。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">Date(<span class="keyword">long</span> millisec)</span><br><span class="line">    </span><br><span class="line">Date对象创建以后，可以调用下面的方法。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/cJmi8buoxDqsz5B.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【演示：获取当前日期时间】</span><br><span class="line">Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间</span><br><span class="line">如下所示：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 获取当前时间日期 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化 Date 对象</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 使用 toString() 函数显示日期时间</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line"><span class="comment">//结果为:   Mon Sep 21 08:14:15 GMT 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【演示：日期比较】</span><br><span class="line">使用 getTime() 方法获取两个日期（自<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日经历的毫秒数值），然后比较这两个值。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 日期比较 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> time3 ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化 Date 对象</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> time = date.getTime();</span><br><span class="line">        <span class="keyword">long</span> time2 = date.getTime();</span><br><span class="line">        time3=date.getTime();</span><br><span class="line">        System.out.println(time==time2);</span><br><span class="line">        System.out.println(time2==time3);</span><br><span class="line">        <span class="comment">// 结果为  true  创建对象是在同一时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[思考:]学会了休眠后,又重新尝试了下,发现只要不重新定义一个date2,那么用同一个获取的date无论调用的是time3还是time4结果都是返回的<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">使用方法 before()，after() 和 equals()。例如，一个月的<span class="number">12</span>号比<span class="number">18</span>号早，则 <span class="keyword">new</span> Date(<span class="number">99</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>).before(<span class="keyword">new</span> Date (<span class="number">99</span>, <span class="number">2</span>, <span class="number">18</span>)) 返回<span class="keyword">true</span>。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> before = <span class="keyword">new</span> Date(<span class="number">97</span>, <span class="number">01</span>, <span class="number">05</span>).before(<span class="keyword">new</span> Date(<span class="number">99</span>, <span class="number">11</span>, <span class="number">16</span>));</span><br><span class="line">System.out.println(before);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、SimpleDateFormat</span><br><span class="line">【演示：使用 SimpleDateFormat 格式化日期】</span><br><span class="line">SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许</span><br><span class="line">你选择任何用户自定义日期时间格式来运行。例如：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Date dNow = <span class="keyword">new</span> Date( );</span><br><span class="line">SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间为: &quot;</span> + ft.format(dNow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。</span><br><span class="line">注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 <span class="number">24</span> 小时制，而 hh 是 <span class="number">12</span> 小时</span><br><span class="line">制。</span><br><span class="line">时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/pMRLwGQVqmFN3rC.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[演示:使用printf方法格式化日期]</span><br><span class="line"></span><br><span class="line">printf方法使用说明:</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用printf输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**关键技术点</span></span><br><span class="line"><span class="comment"> * 使用java.io.PrintStream的printf方法实现C风格的输出</span></span><br><span class="line"><span class="comment"> * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printf</span>类的使用规范 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*** 输出字符串 ***/</span></span><br><span class="line">        <span class="comment">// %s表示输出字符串，也就是将后面的字符串替换模式中的%s</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%s&quot;</span>, <span class="keyword">new</span> Integer(<span class="number">1212</span>));</span><br><span class="line">        <span class="comment">// %n表示换行</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%s%n&quot;</span>, <span class="string">&quot;end line&quot;</span>);</span><br><span class="line">        <span class="comment">// 还可以支持多个参数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%s = %s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">// %S将字符串以大写形式输出</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%S = %s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">// 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$s = %3$s %2$s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;san&quot;</span>, <span class="string">&quot;Zhang&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出boolean类型 ***/</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;true = %b; false = &quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%b%n&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出整数类型***/</span></span><br><span class="line">        Integer iObj = <span class="number">342</span>;</span><br><span class="line">        <span class="comment">// %d表示将整数格式化为10进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d; %d; %d%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">        <span class="comment">// %o表示将整数格式化为8进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%o; %o; %o%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">        <span class="comment">// %x表示将整数格式化为16进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%x; %x; %x%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">        <span class="comment">// %X表示将整数格式化为16进制整数，并且字母变成大写形式</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%X; %X; %X%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出浮点类型***/</span></span><br><span class="line">        Double dObj = <span class="number">45.6d</span>;</span><br><span class="line">        <span class="comment">// %e表示以科学技术法输出浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%e; %e; %e%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">        <span class="comment">// %E表示以科学技术法输出浮点数，并且为大写形式</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%E; %E; %E%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">        <span class="comment">// %f表示以十进制格式化输出浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%f; %f; %f%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">        <span class="comment">// 还可以限制小数点后的位数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%.1f; %.3f; %f%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出日期类型***/</span></span><br><span class="line">        <span class="comment">// %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> dataL = date.getTime();</span><br><span class="line">        <span class="comment">// 格式化年月日</span></span><br><span class="line">        <span class="comment">// %t之后用y表示输出日期的年份（2位数的年，如99）</span></span><br><span class="line">        <span class="comment">// %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n&quot;</span>, date, dataL);</span><br><span class="line">        <span class="comment">// %t之后用Y表示输出日期的年份（4位数的年），</span></span><br><span class="line">        <span class="comment">// %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n&quot;</span>, date, dataL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下是常见的日期组合</span></span><br><span class="line">        <span class="comment">// %t之后用D表示以 &quot;%tm/%td/%ty&quot;格式化日期</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tD%n&quot;</span>, date);</span><br><span class="line">        <span class="comment">//%t之后用F表示以&quot;%tY-%tm-%td&quot;格式化日期</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tF%n&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出时间类型***/</span></span><br><span class="line">        <span class="comment">// 输出时分秒</span></span><br><span class="line">        <span class="comment">// %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制），</span></span><br><span class="line">        <span class="comment">// %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n&quot;</span>, date, dataL);</span><br><span class="line">        <span class="comment">// %t之后用L表示输出时间的秒中的毫秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS %1$tL%n&quot;</span>, date);</span><br><span class="line">        <span class="comment">// %t之后p表示输出时间的上午或下午信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS %1$tL %1$tp%n&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下是常见的时间组合</span></span><br><span class="line">        <span class="comment">// %t之后用R表示以&quot;%tH:%tM&quot;格式化时间</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tR%n&quot;</span>, date);</span><br><span class="line">        <span class="comment">// %t之后用T表示以&quot;%tH:%tM:%tS&quot;格式化时间</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tT%n&quot;</span>, date);</span><br><span class="line">        <span class="comment">// %t之后用r表示以&quot;%tI:%tM:%tS %Tp&quot;格式化时间</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tr%n&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** 输出星期***/</span></span><br><span class="line">        <span class="comment">// %t之后用A表示得到星期几的全称</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tF %1$tA%n&quot;</span>, date);</span><br><span class="line">        <span class="comment">// %t之后用a表示得到星期几的简称</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tF %1$ta%n&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出时间日期的完整信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%1$tc%n&quot;</span>, date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *printf方法中,格式为&quot;%s&quot;表示以字符串的形式输出第二个可变长参数的第一个参数值;</span></span><br><span class="line"><span class="comment"> *格式为&quot;%n&quot;表示换行;格式为&quot;%S&quot;表示将字符串以大写形式输出;在&quot;%s&quot;之间用&quot;n$&quot;表示</span></span><br><span class="line"><span class="comment"> *输出可变长参数的第n个参数值.格式为&quot;%b&quot;表示以布尔值的形式输出第二个可变长参数</span></span><br><span class="line"><span class="comment"> *的第一个参数值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式为&quot;%d&quot;表示以十进制整数形式输出;&quot;%o&quot;表示以八进制形式输出;&quot;%x&quot;表示以十六进制</span></span><br><span class="line"><span class="comment"> * 输出;&quot;%X&quot;表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为&quot;%e&quot;表</span></span><br><span class="line"><span class="comment"> * 以科学计数法输出浮点数;格式为&quot;%E&quot;表示以科学计数法输出浮点数,而且将e大写;格式为</span></span><br><span class="line"><span class="comment"> * &quot;%f&quot;表示以十进制浮点数输出,在&quot;%f&quot;之间加上&quot;.n&quot;表示输出时保留小数点后面n位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式为&quot;%t&quot;表示输出时间日期类型.&quot;%t&quot;之后用y表示输出日期的二位数的年份(如99)、用m</span></span><br><span class="line"><span class="comment"> * 表示输出日期的月份,用d表示输出日期的日号;&quot;%t&quot;之后用Y表示输出日期的四位数的年份</span></span><br><span class="line"><span class="comment"> * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.&quot;%t&quot;之后用D</span></span><br><span class="line"><span class="comment"> * 表示以&quot;%tm/%td/%ty&quot;的格式输出日期、用F表示以&quot;%tY-%tm-%td&quot;的格式输出日期.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;%t&quot;之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间</span></span><br><span class="line"><span class="comment"> * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是</span></span><br><span class="line"><span class="comment"> * 下午.&quot;%t&quot;之后用R表示以&quot;%tH:%tM&quot;的格式输出时间、用T表示以&quot;%tH:%tM:%tS&quot;的格式输出</span></span><br><span class="line"><span class="comment"> * 时间、用r表示以&quot;%tI:%tM:%tS %Tp&quot;的格式输出时间.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;%t&quot;之后用A表示输出日期的全称,用a表示输出日期的星期简称.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一</span><br><span class="line">个字母结尾。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 格式化输出日期 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化 Date 对象</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//c的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;全部日期和时间信息：%tc%n&quot;</span>,date);</span><br><span class="line"><span class="comment">//f的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;年-月-日格式：%tF%n&quot;</span>,date);</span><br><span class="line"><span class="comment">//d的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;月/日/年格式：%tD%n&quot;</span>,date);</span><br><span class="line"><span class="comment">//r的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;</span>,date);</span><br><span class="line"><span class="comment">//t的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;HH:MM:SS格式（24时制）：%tT%n&quot;</span>,date);</span><br><span class="line"><span class="comment">//R的使用</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;HH:MM格式（24时制）：%tR&quot;</span>,date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line">全部日期和时间信息：星期一 九月 <span class="number">21</span> <span class="number">08</span>:<span class="number">24</span>:<span class="number">57</span> GMT <span class="number">2020</span></span><br><span class="line">年-月-日格式：<span class="number">2020</span>-<span class="number">09</span>-<span class="number">21</span></span><br><span class="line">月/日/年格式：<span class="number">09</span>/<span class="number">21</span>/<span class="number">20</span></span><br><span class="line">HH:MM:SS PM格式（<span class="number">12</span>时制）：<span class="number">08</span>:<span class="number">24</span>:<span class="number">57</span> 上午</span><br><span class="line">HH:MM:SS格式（<span class="number">24</span>时制）：<span class="number">08</span>:<span class="number">24</span>:<span class="number">57</span></span><br><span class="line">HH:MM格式（<span class="number">24</span>时制）：<span class="number">08</span>:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">【时间休眠：休眠(sleep)】</span><br><span class="line">sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该</span><br><span class="line">进程所获的CPU资源，以留一定时间给其他线程执行的机会。</span><br><span class="line">你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠<span class="number">3</span></span><br><span class="line">秒：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 程序休眠 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date( ) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date( ) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Got an exception!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果为:  Mon Sep 21 08:26:31 GMT 2020</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//        Mon Sep 21 08:26:34 GMT 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、Calendar类</span><br><span class="line">我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分</span><br><span class="line">呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar</span><br><span class="line">类。Date中有很多方法都已经废弃了！</span><br><span class="line">Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</span><br><span class="line">Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明</span><br><span class="line">的，只需要使用getInstance方法创建即可。</span><br><span class="line">    </span><br><span class="line">创建一个代表系统当前日期的Calendar对象</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calandar</span>类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();<span class="comment">//默认是当前日期</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">//  结果为: java.util.GregorianCalendar[time=1600677269961,</span></span><br><span class="line">        <span class="comment">//  areFieldsSet=true,areAllFieldsSet=true,lenient=true,</span></span><br><span class="line">        <span class="comment">//  zone=sun.util.calendar.ZoneInfo[id=&quot;GMT&quot;,offset=0,</span></span><br><span class="line">        <span class="comment">//  dstSavings=0,useDaylight=false,transitions=0,</span></span><br><span class="line">        <span class="comment">//  lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,</span></span><br><span class="line">        <span class="comment">//  ERA=1,YEAR=2020,MONTH=8,WEEK_OF_YEAR=39,WEEK_OF_MONTH=4,DAY_OF_MONTH=21,</span></span><br><span class="line">        <span class="comment">//  DAY_OF_YEAR=265,DAY_OF_WEEK=2,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,</span></span><br><span class="line">        <span class="comment">//  HOUR=8,HOUR_OF_DAY=8,MINUTE=34,SECOND=29,MILLISECOND=961,ZONE_OFFSET=0,DST_OFFSET=0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建一个指定日期的Calendar对象</span><br><span class="line">使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参</span><br><span class="line">数来完成。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//创建一个代表2019年4月27日的Calendar对象</span></span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(<span class="number">2019</span>, <span class="number">4</span> - <span class="number">1</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">Calendar类对象字段类型</span><br><span class="line">Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/lferZW34EmiHvKA.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="comment">// 获得年份</span></span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);</span><br><span class="line"><span class="comment">// 获得月份</span></span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 获得日期</span></span><br><span class="line"><span class="keyword">int</span> date = c1.get(Calendar.DATE);</span><br><span class="line"><span class="comment">// 获得小时</span></span><br><span class="line"><span class="keyword">int</span> hour = c1.get(Calendar.HOUR_OF_DAY);</span><br><span class="line"><span class="comment">// 获得分钟</span></span><br><span class="line"><span class="keyword">int</span> minute = c1.get(Calendar.MINUTE);</span><br><span class="line"><span class="comment">// 获得秒</span></span><br><span class="line"><span class="keyword">int</span> second = c1.get(Calendar.SECOND);</span><br><span class="line"><span class="comment">// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类</span></span><br><span class="line">推）</span><br><span class="line"><span class="keyword">int</span> day = c1.get(Calendar.DAY_OF_WEEK);</span><br><span class="line"></span><br><span class="line">【演示：设置完整日期】</span><br><span class="line">代码示例:</span><br><span class="line">c1.set(<span class="number">2009</span>, <span class="number">6</span> - <span class="number">1</span>, <span class="number">12</span>);<span class="comment">//把Calendar对象c1的年月日分别设这为：2009、6、12</span></span><br><span class="line"></span><br><span class="line">【演示：设置某个字段】</span><br><span class="line">代码示例:</span><br><span class="line">c1.set(Calendar.DATE,<span class="number">10</span>);</span><br><span class="line">c1.set(Calendar.YEAR,<span class="number">2008</span>);</span><br><span class="line"><span class="comment">//其他字段属性set的意义以此类推</span></span><br><span class="line"></span><br><span class="line">【add设置】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算</span></span><br><span class="line">c1.add(Calendar.DATE, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//把c1对象的日期减去10，也就是c1也就</span></span><br><span class="line"></span><br><span class="line">【演示：GregorianCalendar】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 演示<span class="title">calandar</span>类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String months[] = &#123;</span><br><span class="line">                <span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>,</span><br><span class="line">                <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, <span class="string">&quot;Jul&quot;</span>, <span class="string">&quot;Aug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Sep&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> year;</span><br><span class="line"><span class="comment">// 初始化 Gregorian 日历</span></span><br><span class="line"><span class="comment">// 使用当前时间和日期</span></span><br><span class="line"><span class="comment">// 默认为本地时间和时区</span></span><br><span class="line">        GregorianCalendar gcalendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line"><span class="comment">// 显示当前时间和日期的信息</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Date: &quot;</span>);</span><br><span class="line">        System.out.print(months[gcalendar.get(Calendar.MONTH)]);</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span> + gcalendar.get(Calendar.DATE) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(year = gcalendar.get(Calendar.YEAR));</span><br><span class="line">        System.out.print(<span class="string">&quot;Time: &quot;</span>);</span><br><span class="line">        System.out.print(gcalendar.get(Calendar.HOUR) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        System.out.print(gcalendar.get(Calendar.MINUTE) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        System.out.println(gcalendar.get(Calendar.SECOND));</span><br><span class="line"><span class="comment">// 测试当前年份是否为闰年</span></span><br><span class="line">        <span class="keyword">if</span>(gcalendar.isLeapYear(year)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前年份是闰年&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前年份不是闰年&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Date: Sep <span class="number">21</span> <span class="number">2020</span></span><br><span class="line">Time: <span class="number">8</span>:<span class="number">38</span>:<span class="number">37</span></span><br><span class="line">当前年份是闰年</span><br><span class="line">    </span><br><span class="line">注意：Calender的月份是从<span class="number">0</span>开始的，但日期和年份是从<span class="number">1</span>开始的</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(c1.get(Calendar.YEAR)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.MONTH)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.DATE));</span><br><span class="line">c1.set(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(c1.get(Calendar.YEAR)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.MONTH)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.DATE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">1</span>-<span class="number">1</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">0</span>-<span class="number">31</span></span><br><span class="line">    </span><br><span class="line">可见，将日期设为<span class="number">0</span>以后，月份变成了上个月，但月份可以为<span class="number">0</span>，把月份改为<span class="number">2</span>试试：</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(c1.get(Calendar.YEAR)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.MONTH)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.DATE));</span><br><span class="line">c1.set(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(c1.get(Calendar.YEAR)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.MONTH)</span><br><span class="line">+<span class="string">&quot;-&quot;</span>+c1.get(Calendar.DATE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">1</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">1</span>-<span class="number">28</span></span><br><span class="line">    </span><br><span class="line">可以看到上个月的最后一天是<span class="number">28</span>号，所以Calendar.MONTH为<span class="number">1</span>的时候是<span class="number">2</span>月 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String类</span><br><span class="line">   </span><br><span class="line"><span class="number">1</span>、String概述</span><br><span class="line">在API中是这样描述：</span><br><span class="line"> String 类代表字符串。Java 程序中的所有字符串字面值（如 <span class="string">&quot;abc&quot;</span> ）都作为此类的实例实现。 字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</span><br><span class="line">【演示：查看String源码】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【String的成员变量】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//String的属性值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">//数组被使用的开始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">//String中元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//String类型的hash值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line"><span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">从源码看出String底层使用一个字符数组来维护的。</span><br><span class="line">成员变量可以知道String类的值是<span class="keyword">final</span>类型的，不能被改变的，所以只要一个值改变就会生成一个新的</span><br><span class="line">String类型对象，存储String数据也不一定从数组的第<span class="number">0</span>个元素开始的，而是从offset所指的元素开始。</span><br><span class="line">【String的构造方法】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">String()</span><br><span class="line"><span class="comment">//初始化一个新创建的 String 对象，使其表示一个空字符序列。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes)</span><br><span class="line"><span class="comment">//通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, Charset charset)</span><br><span class="line"><span class="comment">//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span><br><span class="line"><span class="comment">//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span><br><span class="line"><span class="comment">//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span><br><span class="line"><span class="comment">//通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName)</span><br><span class="line"><span class="comment">//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">char</span>[] value)</span><br><span class="line"><span class="comment">//分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span><br><span class="line"><span class="comment">//分配一个新的 String，它包含取自字符数组参数一个子数组的字符。</span></span><br><span class="line">String(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span><br><span class="line"><span class="comment">//分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。</span></span><br><span class="line">String(String original)</span><br><span class="line"><span class="comment">//初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建</span></span><br><span class="line">的字符串是该参数字符串的副本。</span><br><span class="line">String(StringBuffer buffer)</span><br><span class="line"><span class="comment">//分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。</span></span><br><span class="line">String(StringBuilder builder)</span><br><span class="line"><span class="comment">//分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、创建字符串对象方式</span><br><span class="line">直接赋值方式创建对象是在方法区的常量池</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">String str=<span class="string">&quot;hello&quot;</span>;<span class="comment">//直接赋值的方式</span></span><br><span class="line"></span><br><span class="line">通过构造方法创建字符串对象是在堆内存</span><br><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);<span class="comment">//实例化的方式</span></span><br><span class="line"></span><br><span class="line">【两种实例化方式的比较】</span><br><span class="line"><span class="number">1.</span> 编写代码比较</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;Lance&quot;</span>);</span><br><span class="line">String str3 = str2; <span class="comment">//引用传递，str3直接指向st2的堆内存地址</span></span><br><span class="line">String str4 = <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ==:</span></span><br><span class="line"><span class="comment">* 基本数据类型：比较的是基本数据类型的值是否相同</span></span><br><span class="line"><span class="comment">* 引用数据类型：比较的是引用数据类型的地址值是否相同</span></span><br><span class="line"><span class="comment">* 所以在这里的话：String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/dCKuJrMlAEqi7N9.png"></p>
<p><img src="https://i.loli.net/2020/09/21/BurGiDby9HKP6Ss.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【字符串常量池】</span><br><span class="line">在字符串中，如果采用直接赋值的方式（String str=<span class="string">&quot;Lance&quot;</span>）进行对象的实例化，则会将匿名对象</span><br><span class="line">“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，我</span><br><span class="line">们可以用对象手工入池；</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">String str =<span class="keyword">new</span> String(<span class="string">&quot;Lance&quot;</span>).intern();<span class="comment">//对匿名对象&quot;hello&quot;进行手工入池操作</span></span><br><span class="line">String str1=<span class="string">&quot;Lance&quot;</span>;</span><br><span class="line">System.out.println(str==str1);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【两种实例化方式的区别】</span><br><span class="line"><span class="number">1.</span> 直接赋值（String str = <span class="string">&quot;hello&quot;</span>）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</span><br><span class="line"><span class="number">2.</span> 构造方法（String str= <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾</span><br><span class="line">被系统回收，而且不能够自动入池，需要通过<span class="function"><span class="keyword">public</span> String <span class="title">intern</span><span class="params">()</span></span>;方法进行手工入池。</span><br><span class="line"><span class="number">3.</span> 在开发的过程中不会采用构造方法进行字符串的实例化。</span><br><span class="line">【避免空指向】</span><br><span class="line">首先了解： == 和<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">()</span>比较字符串的区别</span></span><br><span class="line"><span class="function"></span>==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中，</span><br><span class="line">equals()通过接受参数，可以避免空指向。</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>))&#123;<span class="comment">//此时会出现空指向异常</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>.equals(str))&#123;<span class="comment">//此时equals会处理null值，可以避免空指向异常</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/fSXzoCux4qtOUGE.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string类的常用方法</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/3z9cfQVtb47jyUZ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string</span>类的常用方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String类相当于char类型的数组，数组的长度一旦创建不能更改，</span></span><br><span class="line">        <span class="comment">// value的数组还使用了final进行修饰</span></span><br><span class="line">        String str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回索指定索引的字符：&quot;</span> + str.charAt(<span class="number">0</span>) + <span class="string">&quot;\t&quot;</span>  + str.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;两字符串进行比较：&quot;</span> + str.equals(<span class="string">&quot;HelloWorld&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;两字符串忽略大小写进行比较：&quot;</span>  + str.equalsIgnoreCase(<span class="string">&quot;HelloWorld&quot;</span>));</span><br><span class="line">        <span class="comment">//找到返回索引值，找不到返回-1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回指点字符的索引值：&quot;</span> + str.indexOf(<span class="string">&#x27;l&#x27;</span>)   + <span class="string">&quot;\t&quot;</span> + str.indexOf(<span class="string">&#x27;X&#x27;</span>));</span><br><span class="line">        <span class="comment">//str.indexOf(&#x27;l&#x27;);自动类型转换：char---&gt;int</span></span><br><span class="line">        System.out.println(str.indexOf(<span class="number">108</span>) + <span class="string">&quot;\t&quot;</span> + str.indexOf(<span class="string">&#x27;l&#x27;</span>));</span><br><span class="line">        <span class="comment">//lastIndexOf:反向搜索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回指定字符串的索引值1：&quot;</span>   + str.indexOf(<span class="string">&quot;o&quot;</span>) + <span class="string">&quot;\t&quot;</span> + str.lastIndexOf(<span class="string">&quot;o&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回指定字符串的索引值2：&quot;</span>   + str.indexOf(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>) + <span class="string">&quot;\t&quot;</span> + str.lastIndexOf(<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>)   + <span class="string">&quot;\t&quot;</span> + str.lastIndexOf(<span class="string">&#x27;o&#x27;</span>, <span class="number">7</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回字符串的长度：&quot;</span> + str.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;新字符替换老字符：&quot;</span> + str.replace(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;H&#x27;</span>)   + <span class="string">&quot;\t&quot;</span> + str.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;W&#x27;</span>));</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;以XX开始：&quot;</span> + str.startsWith(<span class="string">&quot;hell&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;以XX结尾：&quot;</span> + <span class="string">&quot;HelloWorld.java&quot;</span>.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line">        <span class="comment">//前闭后开[beginIndex,endIndex)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;截取子字符串：&quot;</span> + str.substring(<span class="number">5</span>) + <span class="string">&quot;\t&quot;</span>  + str.substring(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;大小写转换：&quot;</span> + str.toUpperCase() + <span class="string">&quot;\t&quot;</span>  + <span class="string">&quot;JAVA&quot;</span>.toLowerCase());</span><br><span class="line">        String str2 = <span class="string">&quot;   hello   world   &quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;去除字符串首尾的空格：[&quot;</span> + str2.trim() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + str2 + <span class="string">&quot;]&quot;</span>);<span class="comment">//字符串一经创建不可改变</span></span><br><span class="line">        str2 = str2.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + str2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果为:  helloworld</span></span><br><span class="line">    <span class="comment">//返回索指定索引的字符：h    e</span></span><br><span class="line">    <span class="comment">//两字符串进行比较：false</span></span><br><span class="line">    <span class="comment">//两字符串忽略大小写进行比较：true</span></span><br><span class="line">    <span class="comment">//返回指点字符的索引值：2    -1</span></span><br><span class="line">    <span class="comment">//2    2</span></span><br><span class="line">    <span class="comment">//返回指定字符串的索引值1：4    6</span></span><br><span class="line">    <span class="comment">//返回指定字符串的索引值2：6    -1    6</span></span><br><span class="line">    <span class="comment">//返回字符串的长度：10</span></span><br><span class="line">    <span class="comment">//新字符替换老字符：Helloworld    helloWorld</span></span><br><span class="line">    <span class="comment">//helloworld</span></span><br><span class="line">    <span class="comment">//以XX开始：true</span></span><br><span class="line">    <span class="comment">//以XX结尾：true</span></span><br><span class="line">    <span class="comment">//截取子字符串：world    hell</span></span><br><span class="line">    <span class="comment">//大小写转换：HELLOWORLD    java</span></span><br><span class="line">    <span class="comment">//去除字符串首尾的空格：[hello   world]</span></span><br><span class="line">    <span class="comment">//[   hello   world   ]</span></span><br><span class="line">    <span class="comment">//[hello   world]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、String的判断</span><br><span class="line">【常用方法】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>： 比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str结尾</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class string的判断 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"><span class="comment">// boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"><span class="comment">// boolean startsWith(String str):判断字符串对象是否以指定的str开头</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;he&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;ll&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、String的截取</span><br><span class="line">【常用方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:获取字符串的长度，其实也就是字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>:获取指定索引处的字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>:获取str在字符串对象中第一次出现的索引</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>:从start开始截取字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:从start开始，到end结束截取字符串。包括start，</span></span><br><span class="line"><span class="function">不包括end</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class string的截取 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length()); <span class="comment">//10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>)); <span class="comment">//h</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>)); <span class="comment">//e</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;l&quot;</span>)); <span class="comment">//2</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;owo&quot;</span>)); <span class="comment">//4</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;ak&quot;</span>)); <span class="comment">//-1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">// String substring(int start):从start开始截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>)); <span class="comment">//helloworld</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>)); <span class="comment">//world</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">// String substring(int start,int end):从start开始，到end结束截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length())); <span class="comment">//helloworld</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>, <span class="number">8</span>)); <span class="comment">//lowor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、String的转换</span><br><span class="line">【常用方法】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">char</span>[] toCharArray()：把字符串转换为字符数组</span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：把字符串转换为小写字符串</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>：把字符串转换为大写字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class string的转换 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">            System.out.println(chs[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果为: a</span></span><br><span class="line">        <span class="comment">//        b</span></span><br><span class="line">        <span class="comment">//        c</span></span><br><span class="line">        <span class="comment">//        d</span></span><br><span class="line">        <span class="comment">//        e</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"><span class="comment">// String toLowerCase():把字符串转换为小写字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>.toLowerCase());<span class="comment">//helloworld</span></span><br><span class="line"><span class="comment">// String toUpperCase():把字符串转换为大写字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>.toUpperCase());<span class="comment">//HELLOWORLD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、其他方法</span><br><span class="line">【常用方法】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line">去除字符串两端空格：<span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">按照指定符号分割字符串：String[] <span class="title">split</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[注意:]按照split切割完后只能是一个数组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class string其他常用方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot; helloworld &quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s1 + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s1.trim() + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s2 + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s2.trim() + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s3 + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s3.trim() + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"><span class="comment">// String[] split(String str)</span></span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s4 = <span class="string">&quot;aa,bb,cc&quot;</span>;</span><br><span class="line">        String[] strArray = s4.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) &#123;</span><br><span class="line">            System.out.println(strArray[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果为: ---helloworld---</span></span><br><span class="line">    <span class="comment">//---helloworld---</span></span><br><span class="line">    <span class="comment">//--- helloworld ---</span></span><br><span class="line">    <span class="comment">//---helloworld---</span></span><br><span class="line">    <span class="comment">//--- hello world ---</span></span><br><span class="line">    <span class="comment">//---hello world---</span></span><br><span class="line">    <span class="comment">//-------------------</span></span><br><span class="line">    <span class="comment">//aa</span></span><br><span class="line">    <span class="comment">//bb</span></span><br><span class="line">    <span class="comment">//cc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、String的不可变性</span><br><span class="line">当我们去阅读源代码的时候，会发现有这样的一句话：</span><br><span class="line">    </span><br><span class="line">Strings are constant; their values cannot be changed after they are created.</span><br><span class="line">    </span><br><span class="line">[翻译:]字符串常量;它们的值在创建后不能更改。</span><br><span class="line">    </span><br><span class="line">我想大家应该就知道为什么String不可变了，String类被<span class="keyword">final</span>修饰，官方注释说明创建后不能被改变，但</span><br><span class="line">是为什么String要使用<span class="keyword">final</span>修饰呢？</span><br><span class="line">【了解一个经典的面试题】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(a==b); <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a==c); <span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(c)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/EYZyHMtLCrDs1Je.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【分析】</span><br><span class="line">因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个</span><br><span class="line">新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共</span><br><span class="line">享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。</span><br><span class="line">需要说明一点的是，在object中，equals()是用来比较内存地址的，但是<span class="string">&quot;String重写了equals()&quot;</span>方</span><br><span class="line">法，用来比较内容的，即使是不同地址，只要内容一致，也会返回<span class="keyword">true</span>，这也就是为什么a.equals(c)返</span><br><span class="line">回<span class="keyword">true</span>的原因了。</span><br><span class="line">【String不可变的好处】</span><br><span class="line">可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</span><br><span class="line">我们的程序中大量使用了String字符串，有可能是出于安全性考虑。</span><br><span class="line">大家都知道HashMap中key为String类型，如果可变将变的多么可怕。</span><br><span class="line">当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的</span><br><span class="line">话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、字符串常量池</span><br><span class="line">【字符串常量池概述】</span><br><span class="line"><span class="number">1.</span> 常量池表（Constant_Pool table）</span><br><span class="line"> Class文件中存储所有常量（包括字符串）的table。这是Class文件中的内容，还不是运行时的内容，不</span><br><span class="line">要理解它是个池子，其实就是Class文件中的字节码指令。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 运行时常量池（Runtime Constant Pool）</span><br><span class="line">JVM内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着JVM运行时候，从常</span><br><span class="line">量池转化而来，每个Class对应一个运行时常量池。上一句中说绝大部分是因为：除了 Class中常量池内</span><br><span class="line">容，还可能包括动态生成并加入这里的内容。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 字符串常量池（String Pool）</span><br><span class="line">这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享</span><br><span class="line">的，全局只有一个。JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有</span><br><span class="line">不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</span><br><span class="line">    </span><br><span class="line">【亨元模式】</span><br><span class="line">其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式</span><br><span class="line">也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有</span><br><span class="line">地方都引用这一个元素</span><br><span class="line">Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - <span class="string">&quot;String Pool”</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">【详细分析】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int x = 10;</span></span><br><span class="line"><span class="string">String y = &quot;</span>hello<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 首先， 10 和 &quot;</span>hello<span class="string">&quot; 会在经过javac（或者其他编译器）编译过后变为Class文件中</span></span><br><span class="line"><span class="string">constant_pool table 的内容</span></span><br><span class="line"><span class="string">2. 当我们的程序运行时，也就是说JVM运行时，每个Class constant_pool table 中的内容会被加</span></span><br><span class="line"><span class="string">载到JVM内存中的方法区中各自Class的 Runtime Constant Pool。</span></span><br><span class="line"><span class="string">3. 一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是&quot;</span>hello<span class="string">&quot;）会被加入到</span></span><br><span class="line"><span class="string">String Pool中（HosSpot使用hashtable引用方式），步骤如下：</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">1. 在Java Heap（堆）中根据&quot;</span>hello<span class="string">&quot;字面量create一个字符串对象</span></span><br><span class="line"><span class="string">2. 将字面量&quot;</span>hello<span class="string">&quot;与字符串对象的引用在hashtable中关联起来键 - 值形式是：&quot;</span>hello<span class="string">&quot; = 对象的引用地址。</span></span><br><span class="line"><span class="string">另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建</span></span><br><span class="line"><span class="string">新对象呢？</span></span><br><span class="line"><span class="string">策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某</span></span><br><span class="line"><span class="string">一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，就如同上面的第三步。</span></span><br><span class="line"><span class="string">如此，就实现了享元模式，提高的内存利用效率。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">举例：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">代码示例:</span></span><br><span class="line"><span class="string">使用String s = new String(&quot;</span>hello<span class="string">&quot;);会创建几个对象</span></span><br><span class="line"><span class="string">答：会创建2个对象</span></span><br><span class="line"><span class="string">首先，出现了字面量&quot;</span>hello<span class="string">&quot;，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行</span></span><br><span class="line"><span class="string">代码所以肯定没有，那么就在Java Heap中用字面量&quot;</span>hello<span class="string">&quot;首先创建1个String对象。</span></span><br><span class="line"><span class="string">接着，new String(&quot;</span>hello<span class="string">&quot;)，关键字new又在Java Heap中创建了1个对象，然后调用接收String</span></span><br><span class="line"><span class="string">参数的构造器进行了初始化。最终s的引用是这个String对象.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">[思考:]string &quot;</span>hello<span class="string">&quot;本身也需要创建这是一个对象,new又创建了一个,所以是两个,s引用的是new的对象.</span></span><br><span class="line"><span class="string">[疑惑:]string本身创建的对象是放在共享池中的吗?</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder 和 StringBuffer</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、概述</span><br><span class="line">【演示：查看源码及API文档】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder 是一个可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。</span><br><span class="line">StringBuffer 也是继承于AbstractStringBuilder的子类；但是，StringBuilder和StringBuffer不同，前者</span><br><span class="line">是非线程安全的，后者是线程安全的。</span><br><span class="line">StringBuilder 和 CharSequence之间的关系图如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/W8URDlfhXZOHTyp.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、常用方法</span><br><span class="line"><span class="number">1</span>、insert</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insert</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testInsertAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInsertAPIs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------- testInsertAPIs -----------&quot;</span>);</span><br><span class="line">        StringBuilder sbuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 在位置0处插入字符数组</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">        System.out.println(sbuilder);</span><br><span class="line"><span class="comment">// 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入float</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="number">1.414f</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入double</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="number">3.14159d</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入boolean</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入char</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入int</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入long</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="number">12345L</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入StringBuilder对象</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;StringBuilder&quot;</span>));</span><br><span class="line"><span class="comment">// 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括)</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;STRINGBUILDER&quot;</span>), <span class="number">6</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入StringBuffer对象。</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> StringBuffer(<span class="string">&quot;StringBuffer&quot;</span>));</span><br><span class="line"><span class="comment">// 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括)</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="keyword">new</span> StringBuffer(<span class="string">&quot;STRINGBUFFER&quot;</span>), <span class="number">6</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入String对象。</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括)</span></span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="string">&quot;0123456789&quot;</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 在位置0处插入Object对象。此处以HashMap为例</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        sbuilder.insert(<span class="number">0</span>, map);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s\n\n&quot;</span>, sbuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、append</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">append</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAppendAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuilder 的append()示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- testAppendAPIs ----------------- --&quot;</span>);</span><br><span class="line">                StringBuilder sbuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 追加字符数组</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 追加字符数组。0表示字符数组起始位置，3表示长度</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 追加float</span></span><br><span class="line">        sbuilder.append(<span class="number">1.414f</span>);</span><br><span class="line"><span class="comment">// 追加double</span></span><br><span class="line">        sbuilder.append(<span class="number">3.14159d</span>);</span><br><span class="line"><span class="comment">// 追加boolean</span></span><br><span class="line">        sbuilder.append(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 追加char</span></span><br><span class="line">        sbuilder.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">// 追加int</span></span><br><span class="line">        sbuilder.append(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 追加long</span></span><br><span class="line">        sbuilder.append(<span class="number">12345L</span>);</span><br><span class="line"><span class="comment">// 追加StringBuilder对象</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;StringBuilder&quot;</span>));</span><br><span class="line"><span class="comment">// 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括)</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;STRINGBUILDER&quot;</span>), <span class="number">6</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// 追加StringBuffer对象。</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> StringBuffer(<span class="string">&quot;StringBuffer&quot;</span>));</span><br><span class="line"><span class="comment">// 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括)</span></span><br><span class="line">        sbuilder.append(<span class="keyword">new</span> StringBuffer(<span class="string">&quot;STRINGBUFFER&quot;</span>), <span class="number">6</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">// 追加String对象。</span></span><br><span class="line">        sbuilder.append(<span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括)</span></span><br><span class="line">        sbuilder.append(<span class="string">&quot;0123456789&quot;</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        sbuilder.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">// 追加Object对象。此处以HashMap为例</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        sbuilder.append(map);</span><br><span class="line">        sbuilder.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">// 追加unicode编码</span></span><br><span class="line">        sbuilder.appendCodePoint(<span class="number">0x5b57</span>); <span class="comment">// 0x5b57是“字”的unicode编码</span></span><br><span class="line">        sbuilder.appendCodePoint(<span class="number">0x7b26</span>); <span class="comment">// 0x7b26是“符”的unicode编码</span></span><br><span class="line">        sbuilder.appendCodePoint(<span class="number">0x7f16</span>); <span class="comment">// 0x7f16是“编”的unicode编码</span></span><br><span class="line">        sbuilder.appendCodePoint(<span class="number">0x7801</span>); <span class="comment">// 0x7801是“码”的unicode编码</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%s\n\n&quot;</span>, sbuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                   </span><br><span class="line"><span class="number">3</span>、replace</span><br><span class="line">                   </span><br><span class="line">代码示例:</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">replace</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testReplaceAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuilder 的replace()示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReplaceAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- testReplaceAPIs----------------- --&quot;</span>);</span><br><span class="line">                StringBuilder sbuilder;</span><br><span class="line">        sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        sbuilder.replace(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;ABCDE&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;sbuilder=%s\n&quot;</span>, sbuilder);</span><br><span class="line">        sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        sbuilder.reverse();</span><br><span class="line">        System.out.printf(<span class="string">&quot;sbuilder=%s\n&quot;</span>, sbuilder);</span><br><span class="line">        sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        sbuilder.setCharAt(<span class="number">0</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;sbuilder=%s\n&quot;</span>, sbuilder);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、delete</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">delete</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testDeleteAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDeleteAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- testDeleteAPIs ----------------- --&quot;</span>);</span><br><span class="line">                StringBuilder sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"><span class="comment">// 删除位置0的字符，剩余字符是“123456789”。</span></span><br><span class="line">        sbuilder.deleteCharAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。</span></span><br><span class="line">        sbuilder.delete(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 获取sb中从位置1开始的字符串</span></span><br><span class="line">        String str1 = sbuilder.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取sb中从位置3(包括)到位置5(不包括)之间的字符串</span></span><br><span class="line">        String str2 = sbuilder.substring(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String</span></span><br><span class="line">        String str3 = (String)sbuilder.subSequence(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;sbuilder=%s\nstr1=%s\nstr2=%s\nstr3=%s\n&quot;</span>,</span><br><span class="line">                sbuilder, str1, str2, str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                   </span><br><span class="line"><span class="number">5</span>、index(找出索引位置)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">index</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testIndexAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuilder 中index相关API演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIndexAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------- testIndexAPIs ----- ---------------------------&quot;</span>);</span><br><span class="line">                StringBuilder sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abcAbcABCabCaBcAbCaBCabc&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;sbuilder=%s\n&quot;</span>, sbuilder);</span><br><span class="line"><span class="comment">// 1. 从前往后，找出&quot;bc&quot;第一次出现的位置</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%-30s = %d\n&quot;</span>, <span class="string">&quot;sbuilder.indexOf(\&quot;bc\&quot;)&quot;</span>,</span><br><span class="line">                sbuilder.indexOf(<span class="string">&quot;bc&quot;</span>));</span><br><span class="line"><span class="comment">// 2. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%-30s = %d\n&quot;</span>, <span class="string">&quot;sbuilder.indexOf(\&quot;bc\&quot;, 5)&quot;</span>,</span><br><span class="line">                sbuilder.indexOf(<span class="string">&quot;bc&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// 3. 从后往前，找出&quot;bc&quot;第一次出现的位置</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%-30s = %d\n&quot;</span>, <span class="string">&quot;sbuilder.lastIndexOf(\&quot;bc\&quot;)&quot;</span>,</span><br><span class="line">                sbuilder.lastIndexOf(<span class="string">&quot;bc&quot;</span>));</span><br><span class="line"><span class="comment">// 4. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%-30s = %d\n&quot;</span>, <span class="string">&quot;sbuilder.lastIndexOf(\&quot;bc\&quot;, 4)&quot;</span>,</span><br><span class="line">                sbuilder.lastIndexOf(<span class="string">&quot;bc&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、其他API</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 其他<span class="title">api</span>案例 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testOtherAPIs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuilder 的其它API示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testOtherAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- testOtherAPIs -----------&quot;</span>);</span><br><span class="line">        StringBuilder sbuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> cap = sbuilder.capacity();</span><br><span class="line">        System.out.printf(<span class="string">&quot;cap=%d\n&quot;</span>, cap);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity()返回的是字符串缓冲区的容量</span></span><br><span class="line"><span class="comment">StringBuffer( ); 分配16个字符的缓冲区</span></span><br><span class="line"><span class="comment">StringBuffer( int len ); 分配len个字符的缓冲区</span></span><br><span class="line"><span class="comment">StringBuffer( String s ); 除了按照s的大小分配空间外,再分配16个 字符的缓冲区</span></span><br><span class="line"><span class="comment">你的StringBuffer是用字符构造的，&quot;0123456789&quot;的长度是10另外再分配16个字符，所</span></span><br><span class="line"><span class="comment">以一共是26。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">char</span> c = sbuilder.charAt(<span class="number">6</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;c=%c\n&quot;</span>, c);</span><br><span class="line">        <span class="keyword">char</span>[] carr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        sbuilder.getChars(<span class="number">3</span>, <span class="number">7</span>, carr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;carr.length; i++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;carr[%d]=%c &quot;</span>, i, carr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;             </span><br><span class="line">                  </span><br><span class="line"><span class="number">3</span>、StringBuffer</span><br><span class="line">和StringBulider用法差不多，不过多介绍，主要看一下三者的区别</span><br><span class="line">                   </span><br><span class="line"><span class="number">4</span>、小结</span><br><span class="line">【String、StringBuffer、StringBuilder之间的区别】</span><br><span class="line">首先需要说明的是：</span><br><span class="line">String 字符串常量</span><br><span class="line">StringBuffer 字符串变量（线程安全）</span><br><span class="line">StringBuilder 字符串变量（非线程安全）</span><br><span class="line">在大多数情况下三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</span><br><span class="line">解释：</span><br><span class="line"> String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String</span><br><span class="line">类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以</span><br><span class="line">经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中</span><br><span class="line">无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</span><br><span class="line">    </span><br><span class="line">而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而</span><br><span class="line">不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对</span><br><span class="line">象经常改变的情况下。</span><br><span class="line">    </span><br><span class="line">为什么是大多数情况呢？                </span><br><span class="line">在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，</span><br><span class="line">所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中，</span><br><span class="line">String 效率是远要比 StringBuffer 快的：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(“This is only a”).append(“</span><br><span class="line">simple”).append(“ test”);</span><br><span class="line"></span><br><span class="line">你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本</span><br><span class="line">一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个</span><br><span class="line">String S1 = “This is only a” + “ simple” + “test”;</span><br><span class="line">其实就是：String S1 = “This is only a simple test”;</span><br><span class="line"></span><br><span class="line">所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象</span><br><span class="line">的话，速度就没那么快了，譬如：</span><br><span class="line">String S2 = “This is only a”;</span><br><span class="line">String S3 = “ simple”;</span><br><span class="line">String S4 = “ test”;</span><br><span class="line"></span><br><span class="line">大部分情况下StringBuilder的速度要大于StringBuffer：</span><br><span class="line"> java.lang.StringBuilder一个可变的字符序列是<span class="number">5.0</span>新增的。（大多数情况下就是我们是在单线程下进行</span><br><span class="line">的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的）此类提供一个与 StringBuffer</span><br><span class="line">兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个</span><br><span class="line">线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比</span><br><span class="line">StringBuffer 要快。两者的方法基本相同。</span><br><span class="line">    </span><br><span class="line">对于三者使用的总结：</span><br><span class="line"><span class="number">1</span>）如果要操作少量的数据用 = String</span><br><span class="line"><span class="number">2</span>）单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</span><br><span class="line"><span class="number">3</span>）多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、面试题的回答</span><br><span class="line">StringBuilder 与StringBuffer的区别，StringBuilder与String的区别。</span><br><span class="line"><span class="number">1</span>）StringBuilder效率高，线程不安全，StringBuffer效率低，线程安全。</span><br><span class="line"><span class="number">2</span>）String是不可变字符串，StringBuilder是可变字符串。为什么有这样的差异，可以深入源码去解析，</span><br><span class="line">比如String类内的 priver <span class="keyword">final</span> <span class="keyword">char</span> value[] 等方法的原因。</span><br><span class="line"><span class="number">3</span>）如果是简单的声明一个字符串没有后续过多的操作，使用String,StringBuilder均可，若后续对字符穿</span><br><span class="line">做频繁的添加，删除操作,或者是在循环当中动态的改变字符穿的长度应该用StringBuilder。使用String</span><br><span class="line">会产生多余的字符串，占用内存空间。</span><br><span class="line">    </span><br><span class="line">File类</span><br><span class="line"><span class="number">1</span>、File类的基本用法</span><br><span class="line"><span class="number">1.</span> java.io.File类：文件和目录路径名的抽象表示形式。</span><br><span class="line">File类的常见构造方法：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir</span></span><br><span class="line"><span class="function">中存储。</span></span><br><span class="line"><span class="function">1. File的静态属性String separator存储了当前系统的路径分隔符。</span></span><br><span class="line"><span class="function">2. 通过File对象可以访问文件的属性。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. 通过File对象创建空文件或目录（在该对象所指的文件或目录不存在的情况下）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>， <span class="title">mkdirs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. 常见构造器，方法</span></span><br><span class="line"><span class="function">【演示】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.io.File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">file</span>类案例 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\target&quot;</span>);<span class="comment">//直接使用路径</span></span><br><span class="line"></span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\target&quot;</span>,<span class="string">&quot;\\hi&quot;</span>);<span class="comment">//父路径，子路径</span></span><br><span class="line"></span><br><span class="line">        File file3 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">&quot;D:\\target&quot;</span>),<span class="string">&quot;\\hi&quot;</span>);<span class="comment">//把父路径封装一下，然后再带上子路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以上为三个常用的构造方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file3.isFile());<span class="comment">//判断当前路径是文件或是目录。false代表是目录，true代表是文件。此时输出false。</span></span><br><span class="line">        System.out.println(file3.isDirectory());<span class="comment">//判断是否为目录。输出true</span></span><br><span class="line">        System.out.println(file3.getName());<span class="comment">//如果是文件，那就输出文件名。如果是目录，那就输出最后一级目录名</span></span><br><span class="line">        System.out.println(file3.getParent());<span class="comment">//输出父路径</span></span><br><span class="line">        System.out.println(file3.getPath());<span class="comment">//输出该File实例所代表的路径</span></span><br><span class="line"></span><br><span class="line">        File file4 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\target\\hi\\123\\456&quot;</span>);</span><br><span class="line">        System.out.println(file4.mkdir());<span class="comment">//这个方法一次只能创建单级目录，D:\\target\\hi这个路径存在，然而D:\\target\\hi\\123不存在，所以输出false</span></span><br><span class="line">        System.out.println(file4.mkdirs());<span class="comment">//这个方法一次可以创建多级目录。输出true</span></span><br><span class="line">        <span class="comment">//mkdir()和mkdirs()只能创建目录，不能创建文件；而createNewFile()只能创建文件，不能创建目录</span></span><br><span class="line">        File file5 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\target\\hi\\123\\test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(file5.createNewFile());<span class="comment">//只有当前目录存在且文件不存在时才能返回true。此时输出true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(file5.exists());<span class="comment">//用于判断文件或目录是否存在</span></span><br><span class="line">        <span class="comment">//boolean delete()：删除File类对象表示的目录或文件。如果该对象表示一个目录，则该目录必须为空才能删除；文件或目录删除成功返回true，否则false。</span></span><br><span class="line">        System.out.println(file4.delete());<span class="comment">//返回true</span></span><br><span class="line">        String [] names = <span class="keyword">new</span> File(<span class="string">&quot;D:\\target\\hi\\123&quot;</span>).list();<span class="comment">//返回当前目录中的文件名组成的字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String string : names) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(file5.renameTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\target\\hi\\123\\newtest.txt&quot;</span>)));<span class="comment">//修改当前文件的名字,输出true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                                    </span><br></pre></td></tr></table></figure>

<h3 id="二、集合"><a href="#二、集合" class="headerlink" title="二、集合"></a>二、集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、为什么使用集合框架？</span><br><span class="line">假设，一个班级有<span class="number">30</span>个人，我们需要存储学员的信息，是不是我们可以用一个一维数组就解决了？</span><br><span class="line">那换一个问题，一个网站每天要存储的新闻信息，我们知道新闻是可以实时发布的，我们并不知道需要</span><br><span class="line">多大的空间去存储，我要是去设置一个很大的数组，要是没有存满，或者不够用，都会影响我们，前者</span><br><span class="line">浪费的空间，后者影响了业务！</span><br><span class="line">如果并不知道程序运行时会需要多少对象，或者需要更复杂的方式存储对象，那我们就可以使用Java的</span><br><span class="line">集合框架！</span><br><span class="line">    </span><br><span class="line">[思考:]动态分配空间,合理利用空间资源</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、集合框架包含的内容</span><br><span class="line"> Java集合框架提供了一套性能优良，使用方便的接口和类，他们位于java.util包中。</span><br><span class="line">【接口和具体类】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/xDfULZuRdGc4taK.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【算法】</span><br><span class="line">Collections 类提供了对集合进行排序，遍历等多种算法实现！</span><br><span class="line">【重中之重】</span><br><span class="line">Collection 接口存储一组不唯一，无序的对象</span><br><span class="line">List 接口存储一组不唯一，有序的对象。</span><br><span class="line">Set 接口存储一组唯一，无序的对象</span><br><span class="line">Map 接口存储一组键值对象，提供key到value的映射</span><br><span class="line">ArrayList实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/uKGzIxcZ9rO4viR.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet:采用哈希算法实现的Set</span><br><span class="line">HashSet的底层是用HashMap实现的，因此查询效率较高，由于采用hashCode算法直接确定</span><br><span class="line">元素的内存地址，增删效率也挺高的。</span><br><span class="line"></span><br><span class="line">ArrayList 实践</span><br><span class="line">问题：我们现在有<span class="number">4</span>只小狗，我们如何存储它的信息，获取总数，并能够逐条打印狗狗信息！</span><br><span class="line">分析：通过List 接口的实现类ArrayList 实现该需求.</span><br><span class="line">元素个数不确定</span><br><span class="line">要求获得元素的实际个数</span><br><span class="line">按照存储顺序获取并打印元素信息</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//idea生成构造方法的快捷键是Alt+Insert，然后选中Constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//构造。。。set、get、。。。toString（）</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建ArrayList对象 , 并存储狗狗</span></span><br><span class="line">            List dogs = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            dogs.add(<span class="keyword">new</span> Dog(<span class="string">&quot;小狗一号&quot;</span>));</span><br><span class="line">            dogs.add(<span class="keyword">new</span> Dog(<span class="string">&quot;小狗二号&quot;</span>));</span><br><span class="line">            dogs.add(<span class="keyword">new</span> Dog(<span class="string">&quot;小狗三号&quot;</span>));</span><br><span class="line">            dogs.add(<span class="number">2</span>,<span class="keyword">new</span> Dog(<span class="string">&quot;小狗四号&quot;</span>));<span class="comment">// 添加到指定位置  也是像数组一样下标从0开始</span></span><br><span class="line"><span class="comment">// .size() ： ArrayList大小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;共计有&quot;</span> + dogs.size() + <span class="string">&quot;条狗狗。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;分别是：&quot;</span>);</span><br><span class="line"><span class="comment">// .get(i) ： 逐个获取个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dogs.size(); i++) &#123;</span><br><span class="line">                Dog dog = (Dog) dogs.get(i);</span><br><span class="line">                System.out.println(dog.getName());<span class="comment">//你没有dogs的getname方法,创建一个dog对象转成指定下标Dog类型</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结果为:  共计有4条狗狗。</span></span><br><span class="line">            <span class="comment">//分别是：</span></span><br><span class="line">            <span class="comment">//小狗一号</span></span><br><span class="line">            <span class="comment">//小狗二号</span></span><br><span class="line">            <span class="comment">//小狗四号</span></span><br><span class="line">            <span class="comment">//小狗三号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">问题联想：</span><br><span class="line">删除第一个狗狗 ：remove（index）</span><br><span class="line">删除指定位置的狗狗 ：remove（object）</span><br><span class="line">判断集合中是否包含指定狗狗 ： contains（object）</span><br><span class="line">分析：使用List接口提供的remove()、contains()方法</span><br><span class="line">【常用方法】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/2fBeC6oMdq45LXt.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList 源码分析</span><br><span class="line"><span class="number">1</span>、ArrayList概述</span><br><span class="line"><span class="number">1.</span> ArrayList是可以动态增长和缩减的索引序列，它是基于数组实现的List类。</span><br><span class="line"><span class="number">2.</span> 该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity【容量】属性，表示</span><br><span class="line">它们所封装的Object[]数组的长度，当向ArrayList中添加元素时，该属性值会自动增加。如果想像</span><br><span class="line">ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配</span><br><span class="line">的次数提高性能。</span><br><span class="line"><span class="number">3.</span> ArrayList的用法和Vector相类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用。</span><br><span class="line">另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合</span><br><span class="line">时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span> ArrayList和Collection的关系：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/xzafEo6TgKnpkys.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、ArrayList的数据结构</span><br><span class="line">分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就理解了该类的实现思</span><br><span class="line">路，具体的实现细节再具体分析。</span><br><span class="line">    </span><br><span class="line">ArrayList的数据结构是：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/hZ6I1jWBQwCPp5r.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">说明：底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对</span><br><span class="line">ArrayList类的实例的所有的操作底层都是基于数组的。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ArrayList源码分析</span><br><span class="line"><span class="number">1</span>、继承结构和层次关系</span><br><span class="line">IDEA快捷键：Ctrl+H</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/3ZcwK7VzfYGslHh.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们看一下ArrayList的继承结构：</span><br><span class="line"> ArrayList extends AbstractList</span><br><span class="line"> AbstractList extends AbstractCollection</span><br><span class="line">所有类都继承Object 所以ArrayList的继承结构就是上图这样。</span><br><span class="line">    </span><br><span class="line">【分析】</span><br><span class="line"><span class="number">1.</span> 为什么要先继承AbstractList，而让AbstractList先实现List？而不是让ArrayList直接实现List？</span><br><span class="line">这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方</span><br><span class="line">法，正是利用了这一点，让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承</span><br><span class="line">这个AbstractList类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更</span><br><span class="line">简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到</span><br><span class="line">一个类上面还有一个抽象类，应该就是这个作用。</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span> ArrayList实现了哪些接口？</span><br><span class="line">List接口：我们会出现这样一个疑问，在查看了ArrayList的父类 AbstractList也实现了List接口，那为什</span><br><span class="line">么子类ArrayList还是去实现一遍呢？</span><br><span class="line">这是想不通的地方，所以我就去查资料，有的人说是为了查看代码方便，使观看者一目了然，说法不</span><br><span class="line">一，但每一个让我感觉合理的，但是在stackOverFlow中找到了答案，这里其实很有趣。</span><br><span class="line">开发这个collection 的作者Josh说：</span><br><span class="line">    </span><br><span class="line">这其实是一个mistake[失误]，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为</span><br><span class="line">没什么影响，就一直留到了现在。</span><br><span class="line">    </span><br><span class="line">RandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，</span><br><span class="line">有关效率的问题，在实现了该接口的话，那么使用普通的<span class="keyword">for</span>循环来遍历，性能更高，例如ArrayList。而</span><br><span class="line">没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了</span><br><span class="line">让我们知道我们用什么样的方式去获取数据性能更好。</span><br><span class="line">    </span><br><span class="line">Cloneable接口：实现了该接口，就可以使用Object.Clone()方法了。</span><br><span class="line">    </span><br><span class="line">Serializable接口：实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够</span><br><span class="line">从类变成字节流传输，然后还能从字节流变成原来的类。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、类中的属性</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">// 缺省容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 缺省空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 元素数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 实际元素大小，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 最大数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、构造方法</span><br><span class="line">通过IDEA查看源码，看到ArrayList有三个构造方法：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/YmkzBZfMKvIrJHA.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一. 无参构造方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">这里就说明了默认会给10的大小，所以说一开始arrayList的容量是10.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//ArrayList中储存数据的其实就是一个数组，这个数组就是elementData.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(); <span class="comment">//调用父类中的无参构造方法，父类中的是个空的构造方法</span></span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"><span class="comment">//EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData</span></span><br><span class="line"><span class="comment">//也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二. 有参构造方法 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">@param initialCapacity the initial capacity of the list</span></span><br><span class="line"><span class="comment">初始容量列表的初始容量</span></span><br><span class="line"><span class="comment">@throws IllegalArgumentException if the specified initial capacity is</span></span><br><span class="line"><span class="comment">negative</span></span><br><span class="line"><span class="comment">如果指定的初始容量为负，则为IllegalArgumentException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">////将自定义的容量大小当成初始化 initialCapacity 的大小</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">//等同于无参构造方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">////判断如果自定义大小的容量小于0，则报下面这个非法数据异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二. 有参构造方法 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructs a list containing the elements of the specified collection,</span></span><br><span class="line"><span class="comment">in the order they are returned by the collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。</span></span><br><span class="line"><span class="comment">@param c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">@throws NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">elementData = c.toArray(); <span class="comment">//转换为数组</span></span><br><span class="line"><span class="comment">//每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类</span></span><br><span class="line"><span class="comment">//型，那么久需要使用ArrayList中的方法去改造一下。</span></span><br><span class="line"><span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// replace with empty array.</span></span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个构造方法不常用，举个例子就能明白什么意思</span><br><span class="line">举个例子： Strudent exends Person ， ArrayList、 Person这里就是泛型 ， 我还有一个Collection、</span><br><span class="line">由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection转换为ArrayList</span><br><span class="line">， 这就是这个构造方法的作用 。</span><br><span class="line">【总结】ArrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数</span><br><span class="line">组，在其中就叫elementData。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、核心方法-add</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">* Appends the specified element to the end of this list.</span></span></span><br><span class="line"><span class="function"><span class="comment">* 添加一个特定的元素到list的末尾。</span></span></span><br><span class="line"><span class="function"><span class="comment">* @param e element to be appended to this list</span></span></span><br><span class="line"><span class="function"><span class="comment">* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判</span></span><br><span class="line"><span class="comment">//断size+1的这个个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。</span></span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">elementData[size++] = e; <span class="comment">//在数据中正确的位置上放上元素e，并且size++</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【分析：ensureCapacityInternal(xxx); 确定内部容量的方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//看，判断初始化的elementData是不是空的数组，也就是没有长度</span></span><br><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line"><span class="comment">//因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存</span></span><br><span class="line">放不了，所以就将minCapacity变成<span class="number">10</span>，也就是默认大小，但是在这里，还没有真正的初始化这个</span><br><span class="line">elementData的大小。</span><br><span class="line"><span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否</span></span><br><span class="line">够用</span><br><span class="line"><span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="comment">//minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不</span></span><br><span class="line">够用，不够用那么就要增加elementData的length。这里有的同学就会模糊minCapacity到底是什么</span><br><span class="line">呢，这里给你们分析一下</span><br><span class="line"><span class="comment">/*第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，</span></span><br><span class="line"><span class="comment">minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量</span></span><br><span class="line"><span class="comment">ensureCapacityInternal)就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，</span></span><br><span class="line"><span class="comment">还没有改变elementData的大小。</span></span><br><span class="line"><span class="comment">第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是</span></span><br><span class="line"><span class="comment">minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length</span></span><br><span class="line"><span class="comment">是否够用，如果length</span></span><br><span class="line"><span class="comment">不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。*/</span></span><br><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//arrayList核心的方法，能扩展数组大小的真正秘密。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="comment">//将扩充前的elementData大小给oldCapacity</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="comment">//newCapacity就是1.5倍的oldCapacity</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">//这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，</span></span><br><span class="line">newCapacity=<span class="number">0</span>，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为<span class="number">10.</span></span><br><span class="line">前面的工作都是准备工作。</span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;</span><br><span class="line"><span class="comment">//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给</span></span><br><span class="line">newCapacity</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line"><span class="comment">//新的容量大小已经确定好了，就copy数组，改变容量大小咯。</span></span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个就是上面用到的方法，很简单，就是用来赋最大值。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"><span class="comment">//如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将</span></span><br><span class="line">MAX_ARRAY_SIZE返回。因为maxCapacity是三倍的minCapacity，可能扩充的太大了，就用</span><br><span class="line">minCapacity来判断了。</span><br><span class="line"><span class="comment">//Integer.MAX_VALUE:2147483647 MAX_ARRAY_SIZE：2147483639 也就是说最大也就能</span></span><br><span class="line"><span class="comment">//给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。</span></span><br><span class="line"><span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">Integer.MAX_VALUE :</span><br><span class="line">MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>，E)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查index也就是插入的位置是否合理。</span></span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line"><span class="comment">//这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位，</span></span><br><span class="line">System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">size - index);</span><br><span class="line"><span class="comment">//在目标位置上存放元素</span></span><br><span class="line">elementData[index] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【分析：rangeCheckForAdd(index)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//插入的位置肯定不能大于size 和小于0</span></span><br><span class="line"><span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//如果是，就报这个越界异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【System.arraycopy(...)：就是将elementData在插入位置后的所有元素，往后面移一位.】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">src：源对象</span></span><br><span class="line"><span class="function">srcPos：源对象对象的起始位置</span></span><br><span class="line"><span class="function">dest：目标对象</span></span><br><span class="line"><span class="function">destPost：目标对象的起始位置</span></span><br><span class="line"><span class="function">length：从起始位置往后复制的长度。</span></span><br><span class="line"><span class="function"><span class="comment">//这段的大概意思就是解释这个方法的用法，复制src到dest，复制的位置是从src的srcPost开始，</span></span></span><br><span class="line"><span class="function">到srcPost+length-1的位置结束，复制到destPost上，从destPost开始到destPost+length-1</span></span><br><span class="line"><span class="function">的位置上，</span></span><br><span class="line"><span class="function">Copies an array from the specified source array, beginning at the specified</span></span><br><span class="line"><span class="function">position, to the specified position of the destination array. A subsequence</span></span><br><span class="line"><span class="function">of array components are copied from</span></span><br><span class="line"><span class="function">the source array referenced by src to the destination array referenced by</span></span><br><span class="line"><span class="function">dest. The number of components copied is equal to the length argument. The</span></span><br><span class="line"><span class="function">components at positions srcPos through srcPos+length-1</span></span><br><span class="line"><span class="function">in the source array are copied into positions destPos through</span></span><br><span class="line"><span class="function">destPos+length-1, respectively, of the destination array.</span></span><br><span class="line"><span class="function"><span class="comment">//告诉你复制的一种情况，如果A和B是一样的，那么先将A复制到临时数组C，然后通过C复制到B，用了</span></span></span><br><span class="line"><span class="function">一个第三方参数</span></span><br><span class="line"><span class="function">If the src and dest arguments refer to the same array object, then the</span></span><br><span class="line"><span class="function">copying is performed as <span class="keyword">if</span> the components at positions srcPos through</span></span><br><span class="line"><span class="function">srcPos+length-1 were first copied to</span></span><br><span class="line"><span class="function">a temporary array with length components and then the contents of the</span></span><br><span class="line"><span class="function">temporary array were copied into positions destPos through destPos+length-1</span></span><br><span class="line"><span class="function">of the destination array.</span></span><br><span class="line"><span class="function"><span class="comment">//这一大段，就是来说明会出现的一些问题，NullPointerException和</span></span></span><br><span class="line"><span class="function">IndexOutOfBoundsException 还有ArrayStoreException 这三个异常出现的原因。</span></span><br><span class="line"><span class="function">If dest is <span class="keyword">null</span>, then a NullPointerException is thrown.</span></span><br><span class="line"><span class="function">If src is <span class="keyword">null</span>, then a NullPointerException is thrown and the destination</span></span><br><span class="line"><span class="function">array is not modified.</span></span><br><span class="line"><span class="function">Otherwise, <span class="keyword">if</span> any of the following is <span class="keyword">true</span>, an ArrayStoreException is thrown</span></span><br><span class="line"><span class="function">and the destination is not modified:</span></span><br><span class="line"><span class="function">The src argument refers to an object that is not an array.</span></span><br><span class="line"><span class="function">The dest argument refers to an object that is not an array.</span></span><br><span class="line"><span class="function">The src argument and dest argument refer to arrays whose component types are</span></span><br><span class="line"><span class="function">different primitive types.</span></span><br><span class="line"><span class="function">The src argument refers to an array with a primitive component type and the</span></span><br><span class="line"><span class="function">dest argument refers to an array with a reference component type.</span></span><br><span class="line"><span class="function">The src argument refers to an array with a reference component type and the</span></span><br><span class="line"><span class="function">dest argument refers to an array with a primitive component type.</span></span><br><span class="line"><span class="function">Otherwise, <span class="keyword">if</span> any of the following is <span class="keyword">true</span>, an IndexOutOfBoundsException is</span></span><br><span class="line"><span class="function">thrown and the destination is not modified:</span></span><br><span class="line"><span class="function">The srcPos argument is negative.</span></span><br><span class="line"><span class="function">The destPos argument is negative.</span></span><br><span class="line"><span class="function">The length argument is negative.</span></span><br><span class="line"><span class="function">srcPos+length is greater than src.length, the length of the source array.</span></span><br><span class="line"><span class="function">destPos+length is greater than dest.length, the length of the destination</span></span><br><span class="line"><span class="function">array.</span></span><br><span class="line"><span class="function"><span class="comment">//这里描述了一种特殊的情况，就是当A的长度大于B的长度的时候，会复制一部分，而不是完全失败。</span></span></span><br><span class="line"><span class="function">Otherwise, <span class="keyword">if</span> any actual component of the source array from position srcPos</span></span><br><span class="line"><span class="function">through srcPos+length-1 cannot be converted to the component type of the</span></span><br><span class="line"><span class="function">destination array by assignment conversion, an ArrayStoreException is</span></span><br><span class="line"><span class="function">thrown.</span></span><br><span class="line"><span class="function">In <span class="keyword">this</span> <span class="keyword">case</span>, let k be the smallest nonnegative integer less than length</span></span><br><span class="line"><span class="function">such that src[srcPos+k] cannot be converted to the component type of the</span></span><br><span class="line"><span class="function">destination array</span>; when the exception is thrown, source array components</span><br><span class="line">from positions</span><br><span class="line">srcPos through srcPos+k-<span class="number">1</span> will already have been copied to destination array</span><br><span class="line">positions destPos through destPos+k-<span class="number">1</span> and no other positions of the</span><br><span class="line">destination array will have been modified. (Because of the restrictions</span><br><span class="line">already itemized,</span><br><span class="line"><span class="keyword">this</span> paragraph effectively applies only to the situation where both arrays</span><br><span class="line">have component types that are reference types.)</span><br><span class="line"><span class="comment">//这个参数列表的解释，一开始就说了，</span></span><br><span class="line">Parameters:</span><br><span class="line">src - the source array.</span><br><span class="line">srcPos - starting position in the source array.</span><br><span class="line">dest - the destination array.</span><br><span class="line">destPos - starting position in the destination data.</span><br><span class="line">length - the number of array elements to be copied.</span><br><span class="line"></span><br><span class="line">【总结】</span><br><span class="line">正常情况下会扩容<span class="number">1.5</span>倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。</span><br><span class="line">当我们调用add方法时，实际上的函数调用如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/nsewQv8V36jS5TB.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">说明：程序调用add，实际上还会进行一系列调用，可能会调用到grow，grow可能会调用</span><br><span class="line">hugeCapacity。</span><br><span class="line">【举例】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;;</span><br><span class="line">lists.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">说明：初始化lists大小为<span class="number">0</span>，调用的ArrayList()型构造函数，那么在调用lists.add(<span class="number">8</span>)方法时，会经过怎样</span><br><span class="line">的步骤呢？下图给出了该程序执行过程和最初与最后的elementData的大小。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/YQCU46gzJGc23BN.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">说明：我们可以看到，在add方法之前开始elementData = &#123;&#125;；调用add方法时会继续调用，直至</span><br><span class="line">grow，最后elementData的大小变为<span class="number">10</span>，之后再返回到add函数，把<span class="number">8</span>放在elementData[<span class="number">0</span>]中。</span><br><span class="line">【举例说明二】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">lists.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">说明：调用的ArrayList(<span class="keyword">int</span>)型构造函数，那么elementData被初始化为大小为<span class="number">6</span>的Object数组，在调用</span><br><span class="line">add(<span class="number">8</span>)方法时，具体的步骤如下：</span><br><span class="line">说明：我们可以知道，在调用add方法之前，elementData的大小已经为<span class="number">6</span>，之后再进行传递，不会进行</span><br><span class="line">扩容处理。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、核心方法-remove</span><br><span class="line">    </span><br><span class="line">其实这几个删除方法都是类似的。我们选择几个讲，其中fastRemove(<span class="keyword">int</span>)方法是<span class="keyword">private</span>的，是提供给</span><br><span class="line">remove(Object)这个方法用的。</span><br><span class="line"><span class="number">1.</span> remove(<span class="keyword">int</span>)：通过删除指定位置上的元素</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">rangeCheck(index);<span class="comment">//检查index的合理性</span></span><br><span class="line">modCount++;<span class="comment">//这个作用很多，比如用来检测快速失败的一种标志。</span></span><br><span class="line">E oldValue = elementData(index);<span class="comment">//通过索引直接找到该元素</span></span><br><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算要移动的位数。</span></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//这个方法也已经解释过了，就是用来移动元素的。</span></span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">numMoved);</span><br><span class="line"><span class="comment">//将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。</span></span><br><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"><span class="comment">//返回删除的元素。</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> remove(Object)：这个方法可以看出来，arrayList是可以存放<span class="keyword">null</span>值得。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//感觉这个不怎么要分析吧，都看得懂，就是通过元素来删除该元素，就依次遍历，如果有这个元素，</span></span><br><span class="line">就将该元素的索引传给fastRemobe(index)，使用这个方法来删除该元素，</span><br><span class="line"><span class="comment">//fastRemove(index)方法的内部跟remove(index)的实现几乎一样，这里最主要是知道</span></span><br><span class="line">arrayList可以存储<span class="keyword">null</span>值</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line"><span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">fastRemove(index);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> clear()：将elementData中每个元素都赋值为<span class="keyword">null</span>，等待垃圾回收将这个给回收掉，所以叫clear</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">// clear to let GC do its work</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> removeAll(collection c)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);<span class="comment">//批量删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> batchRemove(xx,xx)：用于两个方法，一个removeAll()：它只清楚指定集合中的元素，retainAll()</span><br><span class="line">用来测试两个集合是否有交集。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//这个方法，用于两处地方，如果complement为false，则用于removeAll如果为true，则给</span></span><br><span class="line">retainAll()用，retainAll（）是用来检测两个集合是否有交集的。</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData; <span class="comment">//将原集合，记名为A</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>; <span class="comment">//r用来控制循环，w是记录有多少个交集</span></span><br><span class="line"><span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line"><span class="comment">//参数中的集合C一次检测集合A中的元素是否有，</span></span><br><span class="line"><span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line"><span class="comment">//有的话，就给集合A</span></span><br><span class="line">elementData[w++] = elementData[r];</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line"><span class="comment">// even if c.contains() throws.</span></span><br><span class="line"><span class="comment">//如果contains方法使用过程报异常</span></span><br><span class="line"><span class="keyword">if</span> (r != size) &#123;</span><br><span class="line"><span class="comment">//将剩下的元素都赋值给集合A，</span></span><br><span class="line">System.arraycopy(elementData, r,</span><br><span class="line">elementData, w,</span><br><span class="line">size - r);</span><br><span class="line">w += size - r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (w != size) &#123;</span><br><span class="line"><span class="comment">//这里有两个用途，在removeAll()时，w一直为0，就直接跟clear一样，全是为</span></span><br><span class="line"><span class="keyword">null</span>。</span><br><span class="line"><span class="comment">//retainAll()：没有一个交集返回true，有交集但不全交也返回true，而两个集合</span></span><br><span class="line">相等的时候，返回<span class="keyword">false</span>，所以不能根据返回值来确认两个集合是否有交集，而是通过原集合的大小是否</span><br><span class="line">发生改变来判断，如果原集合中还有元素，则代表有交集，而元集合没有元素了，说明两个集合没有交</span><br><span class="line">集。</span><br><span class="line"><span class="comment">// clear to let GC do its work</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">modCount += size - w;</span><br><span class="line">size = w;</span><br><span class="line">modified = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：remove函数，用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单</span><br><span class="line">位，并且会把数组最后一个元素设置为<span class="keyword">null</span>，这样是为了方便之后将整个数组不被使用时，会被GC，可</span><br><span class="line">以作为小的技巧使用。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、其他方法</span><br><span class="line">【set()方法】</span><br><span class="line">说明：设定指定下标索引的元素值</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检验索引是否合法</span></span><br><span class="line">rangeCheck(index);</span><br><span class="line"><span class="comment">// 旧值</span></span><br><span class="line">E oldValue = elementData(index);</span><br><span class="line"><span class="comment">// 赋新值</span></span><br><span class="line">elementData[index] = element;</span><br><span class="line"><span class="comment">// 返回旧值</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【indexOf()方法】</span><br><span class="line">说明：从头开始查找与指定元素相等的元素，注意，是可以查找<span class="keyword">null</span>元素的，意味着ArrayList中可以存</span><br><span class="line">放<span class="keyword">null</span>元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">// 从首开始查找数组里面是否存在指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123; <span class="comment">// 查找的元素为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="comment">// 遍历数组，找到第一个为空的元素，返回下标</span></span><br><span class="line"><span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 查找的元素不为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="comment">// 遍历数组，找到第一个和指定元素相等的元</span></span><br><span class="line">素，返回下标</span><br><span class="line"><span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有找到，返回空</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【get()方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检验索引是否合法</span></span><br><span class="line">rangeCheck(index);</span><br><span class="line"><span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于<span class="number">0</span>），值得注意的</span><br><span class="line">是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：返回的值都经过了向下转型（Object -&gt; E），这些是对我们应用程序屏蔽的小细节。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、总结</span><br><span class="line"><span class="number">1</span>）arrayList可以存放<span class="keyword">null</span>。</span><br><span class="line"><span class="number">2</span>）arrayList本质上就是一个elementData数组。</span><br><span class="line"><span class="number">3</span>）arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。</span><br><span class="line"><span class="number">4</span>）arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而</span><br><span class="line">clear是全是删除集合中的元素。</span><br><span class="line"><span class="number">5</span>）arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很</span><br><span class="line">多，有移动很多数据才能达到应有的效果</span><br><span class="line"><span class="number">6</span>）arrayList实现了RandomAccess，所以在遍历它的时候推荐使用<span class="keyword">for</span>循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList实践</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、引入</span><br><span class="line">问题：在集合的任何位置（头部，中间，尾部）添加，获取，删除狗狗对象！</span><br><span class="line">分析：</span><br><span class="line">插入，删除操作频繁时，可使用LinkedList来提高效率。</span><br><span class="line"> LinkedList提供对头部和尾部元素进行添加和删除操作的方法！</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/PRslU3fZ8GveNIO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【LinkedList的特殊方法】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/SXZlnE9YOgzxtos.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【小结】</span><br><span class="line">集合框架有何好处？</span><br><span class="line">Java集合框架中包含哪些接口和类？</span><br><span class="line">ArrayList和LinkedList有何异同？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、LinkedList源码分析</span><br><span class="line">前面我们分析了ArrayList的源码，这一章是LinkedList。我们都知道它的底层是由链表实现的，所以我</span><br><span class="line">们要明白什么是链表？</span><br><span class="line"><span class="number">1</span>、LinkedList概述</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/Rc3aieBm6fqPpvQ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现</span><br><span class="line">的。</span><br><span class="line">LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队</span><br><span class="line">列进行操作。</span><br><span class="line">LinkedList 实现 List 接口，能对它进行队列操作。</span><br><span class="line">LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</span><br><span class="line">LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</span><br><span class="line">LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</span><br><span class="line">LinkedList 是非同步的。</span><br><span class="line"><span class="number">2</span>、LinkedList的数据结构</span><br><span class="line">【基础知识补充】</span><br><span class="line">单向链表：</span><br><span class="line"> element：用来存放元素</span><br><span class="line"> next：用来指向下一个节点元素</span><br><span class="line">通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向<span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/MhqdUXmOLpx7KB2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单向循环链表：</span><br><span class="line"> element、next 跟前面一样</span><br><span class="line">在单向链表的最后一个节点的next会指向头节点，而不是指向<span class="keyword">null</span>，这样存成一个环</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/r4XwGCdPS3YAZL7.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">双向链表：</span><br><span class="line"> element：存放元素</span><br><span class="line"> pre：用来指向前一个元素</span><br><span class="line"> next：指向后一个元素</span><br><span class="line">双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre</span><br><span class="line">指向<span class="keyword">null</span>，最后一个节点的tail指向<span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/vpcPJXm8M2BTKIQ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">双向循环链表：</span><br><span class="line"> element、pre、next 跟前面的一样</span><br><span class="line">第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/IzDHbsMuSCrTnV1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【LinkedList的数据结构】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/EXMUmnj4FvcwxPq.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如上图所示，LinkedList底层使用的双向链表结构，有一个头结点和一个尾结点，双向链表意味着我们</span><br><span class="line">可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、LinkedList的特性</span><br><span class="line"></span><br><span class="line">在我们平常中，我们只知道一些常识性的特点：</span><br><span class="line"> <span class="number">1</span>）是通过链表实现的</span><br><span class="line"> <span class="number">2</span>）如果在频繁的插入，或者删除数据时，就用linkedList性能会更好。</span><br><span class="line">那我们通过API去查看它的一些特性</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）Doubly-linked list implementation of the `List` and `Deque` interfaces.</span><br><span class="line">Implements all optional list operations, <span class="function">and permits all <span class="title">elements</span> <span class="params">(including</span></span></span><br><span class="line"><span class="function"><span class="params">`<span class="keyword">null</span>`)</span>.</span></span><br><span class="line"><span class="function">这告诉我们，linkedList是一个双向链表，并且实现了List和Deque接口中所有的列表操作，并且能存</span></span><br><span class="line"><span class="function">储任何元素，包括<span class="keyword">null</span>，这里我们可以知道linkedList除了可以当链表使用，还可以当作队列使用，并</span></span><br><span class="line"><span class="function">能进行相应的操作。</span></span><br><span class="line"><span class="function">2）All of the operations perform as could be expected <span class="keyword">for</span> a doubly-linked</span></span><br><span class="line"><span class="function">list. Operations that index into the list will traverse the list from the</span></span><br><span class="line"><span class="function">beginning or the end, whichever is closer to the specified index.</span></span><br><span class="line"><span class="function">这个告诉我们，linkedList在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所</span></span><br><span class="line"><span class="function">需要的的值。通俗点讲，这就告诉了我们这个是顺序存取，每次操作必须先按开始到结束的顺序遍历，随</span></span><br><span class="line"><span class="function">机存取，就是arrayList，能够通过index。随便访问其中的任意位置的数据，这就是随机列表的意思。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> 3）api中接下来讲的一大堆，就是说明linkedList是一个非线程安全的<span class="params">(异步)</span>，其中在操作Interator时，</span></span><br><span class="line"><span class="function">如果改变列表结构<span class="params">(adddelete等)</span>，会发生fail-fast。</span></span><br><span class="line"><span class="function">通过API再次总结一下LinkedList的特性：</span></span><br><span class="line"><span class="function"> 1）异步，也就是非线程安全</span></span><br><span class="line"><span class="function"> 2）双向链表。由于实现了list和Deque接口，能够当作队列来使用。</span></span><br><span class="line"><span class="function">链表：查询效率不高，但是插入和删除这种操作性能好。</span></span><br><span class="line"><span class="function"> 3）是顺序存取结构（注意和随机存取结构两个概念搞清楚）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4、继承结构以及层次关系</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/Je15Dd8uP3ty7xH.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【分析】</span><br><span class="line">我们可以看到，linkedList在最底层，说明他的功能最为强大，并且细心的还会发现，arrayList有四</span><br><span class="line">层，这里多了一层AbstractSequentialList的抽象类，为什么呢？</span><br><span class="line">通过API我们会发现：</span><br><span class="line"> <span class="number">1</span>）减少实现顺序存取（例如LinkedList）这种类的工作，通俗的讲就是方便，抽象出类似LinkedList这</span><br><span class="line">种类的一些共同的方法</span><br><span class="line"> <span class="number">2</span>）既然有了上面这句话，那么以后如果自己想实现顺序存取这种特性的类(就是链表形式)，那么就继承</span><br><span class="line">这个AbstractSequentialList抽象类，如果想像数组那样的随机存取的类，那么就去实现AbstracList抽象</span><br><span class="line">类。</span><br><span class="line"> <span class="number">3</span>）这样的分层，就很符合我们抽象的概念，越在高处的类，就越抽象，往在底层的类，就越有自己独</span><br><span class="line">特的个性。自己要慢慢领会这种思想。</span><br><span class="line"> <span class="number">4</span>）LinkedList的类继承结构很有意思，我们着重要看是Deque接口，Deque接口表示是一个双端队</span><br><span class="line">列，那么也意味着LinkedList是双端队列的一种实现，所以，基于双端队列的操作在LinkedList中全部有</span><br><span class="line">效。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">//这里第一段就解释了这个类的作用，这个类为实现<span class="title">list</span>接口提供了一些重要的方法，</span></span><br><span class="line"><span class="class">//尽最大努力去减少实现这个“顺序存取”的特性的数据存储(例如链表)的什么鬼，对于</span></span><br><span class="line"><span class="class">//随机存取数据(例如数组)的类应该优先使用<span class="title">AbstractList</span></span></span><br><span class="line"><span class="class">//从上面就可以大概知道，<span class="title">AbstractSwquentialList</span>这个类是为了减少<span class="title">LinkedList</span>这种顺序存取</span></span><br><span class="line"><span class="class">的类的代码复杂度而抽象的一个类，</span></span><br><span class="line"><span class="class"><span class="title">This</span> <span class="title">class</span> <span class="title">provides</span> <span class="title">a</span> <span class="title">skeletal</span> <span class="title">implementation</span> <span class="title">of</span> <span class="title">the</span> <span class="title">List</span> <span class="title">interface</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"><span class="title">minimize</span> <span class="title">the</span> <span class="title">effort</span> <span class="title">required</span> <span class="title">to</span> <span class="title">implement</span> <span class="title">this</span> <span class="title">interface</span> <span class="title">backed</span> <span class="title">by</span> <span class="title">a</span></span></span><br><span class="line">&quot;sequential access&quot; data store (such as a linked list). For random access</span><br><span class="line">data (such as an array), AbstractList should be used in preference to <span class="keyword">this</span></span><br><span class="line">class.</span><br><span class="line"><span class="comment">//这一段大概讲的就是这个AbstractSequentialList这个类和AbstractList这个类是完全//相反</span></span><br><span class="line">的。比如get、add这个方法的实现</span><br><span class="line">This <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">the</span> <span class="title">opposite</span> <span class="title">of</span> <span class="title">the</span> <span class="title">AbstractList</span> <span class="title">class</span> <span class="title">in</span> <span class="title">the</span> <span class="title">sense</span> <span class="title">that</span> <span class="title">it</span></span></span><br><span class="line">implements the &quot;random access&quot; methods (get(int index), set(int index, E</span><br><span class="line">element), add(<span class="keyword">int</span> index, E element) <span class="function">and <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>) on top of the</span></span><br><span class="line"><span class="function">list&#x27;s list iterator, instead of the other way around.</span></span><br><span class="line"><span class="function"><span class="comment">//这里就是讲一些我们自己要继承该类，该做些什么事情，一些规范。</span></span></span><br><span class="line"><span class="function">To implement a list the programmer needs only to extend <span class="keyword">this</span> class and</span></span><br><span class="line"><span class="function">provide implementations <span class="keyword">for</span> the listIterator and size methods. For an</span></span><br><span class="line"><span class="function">unmodifiable list, the programmer need only implement the list iterator&#x27;s</span></span><br><span class="line"><span class="function">hasNext, next, hasPrevious, previous and index methods.</span></span><br><span class="line"><span class="function">For a modifiable list the programmer should additionally implement the list</span></span><br><span class="line"><span class="function">iterator&#x27;s set method. For a variable-size list the programmer should</span></span><br><span class="line"><span class="function">additionally implement the list iterator&#x27;s remove and add methods.</span></span><br><span class="line"><span class="function">The programmer should generally provide a <span class="title">void</span> <span class="params">(no argument)</span> and collection</span></span><br><span class="line"><span class="function">constructor, as per the recommendation in the Collection interface</span></span><br><span class="line"><span class="function">specification.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">【接口实现分析】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class LinkedList&lt;E&gt;</span></span><br><span class="line"><span class="function">extends AbstractSequentialList&lt;E&gt;</span></span><br><span class="line"><span class="function">implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>）List接口：列表，add、set、等一些对列表进行操作的方法</span><br><span class="line"> <span class="number">2</span>）Deque接口：有队列的各种特性，</span><br><span class="line"> <span class="number">3</span>）Cloneable接口：能够复制，使用那个copy方法。</span><br><span class="line"> <span class="number">4</span>）Serializable接口：能够序列化。</span><br><span class="line"> <span class="number">5</span>）应该注意到没有RandomAccess：那么就推荐使用iterator，在其中就有一个foreach，增强的<span class="keyword">for</span>循</span><br><span class="line">环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator都可以。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、类的属性</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 实际元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> LinkedList的属性非常简单，一个头结点、一个尾结点、一个表示链表中实际元素个数的变量。注意，</span><br><span class="line">头结点、尾结点都有<span class="keyword">transient</span>关键字修饰，这也意味着在序列化时该域是不会序列化的。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、构造方法</span><br><span class="line">两个构造方法(两个构造方法都是规范规定需要写的）</span><br><span class="line">【空参构造函数】</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：会调用无参构造函数，并且会把集合中所有的元素添加到LinkedList中。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、内部类（Node）</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line"><span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.item = element;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line"><span class="keyword">this</span>.prev = prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：内部类Node就是实际的结点，用于存放实际元素的地方。</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、核心方法</span><br><span class="line"><span class="number">1</span>、【add()方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 添加到末尾</span></span><br><span class="line">linkLast(e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：add函数用于向LinkedList中添加一个元素，并且添加到链表尾部。具体添加到尾部的逻辑是由</span><br><span class="line">linkLast函数完成的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【LinkLast(XXXXX)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Links e as last element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">//临时节点l(L的小写)保存last，也就是l指向了最后一个</span></span><br><span class="line">节点</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//将e封装为节点，并且e.prev</span></span><br><span class="line">指向了最后一个节点</span><br><span class="line">last = newNode;<span class="comment">//newNode成为了最后一个节点，所以last指向了它</span></span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">null</span>) <span class="comment">//判断是不是一开始链表中就什么都没有，如果没有，则newNode就成为</span></span><br><span class="line">了第一个节点，first和last都要指向它</span><br><span class="line">first = newNode;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的</span></span><br><span class="line">最后一个节点，原先的最后一个节点就变成了倒数第二个节点</span><br><span class="line">l.next = newNode;</span><br><span class="line">size++;<span class="comment">//添加一个节点，size自增</span></span><br><span class="line">modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：对于添加一个元素至链表中会调用add方法 -&gt; linkLast方法。</span><br><span class="line"></span><br><span class="line">【举例一】</span><br><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">lists.add(<span class="number">5</span>);</span><br><span class="line">lists.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">首先调用无参构造函数，之后添加元素<span class="number">5</span>，之后再添加元素<span class="number">6</span>。具体的示意图如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/vjBD75m8xoOP6dE.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上图的表明了在执行每一条语句后，链表对应的状态。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、【addAll方法】</span><br><span class="line"> addAll有两个重载函数，addAll(Collection&lt;? extends E&gt;)型和addAll(<span class="keyword">int</span>, Collection&lt;? extends E&gt;)</span><br><span class="line">型，我们平时习惯调用的addAll(Collection&lt;? extends E&gt;)型会转化为addAll(<span class="keyword">int</span>, Collection&lt;? extends</span><br><span class="line">E&gt;)型。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//继续往下看</span></span><br><span class="line"><span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addAll(size，c)：这个方法，能包含三种情况下的添加，我们这里分析的只是构造方法，空链表的情</span><br><span class="line">况，看的时候只需要按照不同的情况分析下去就行了。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//真正核心的地方就是这里了，记得我们传过来的是size，c</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查index这个是否为合理。这个很简单，自己点进去看下就明白了。</span></span><br><span class="line">checkPositionIndex(index);</span><br><span class="line"><span class="comment">//将集合c转换为Object数组 a</span></span><br><span class="line">Object[] a = c.toArray();</span><br><span class="line"><span class="comment">//数组a的长度numNew，也就是由多少个元素</span></span><br><span class="line"><span class="keyword">int</span> numNew = a.length;</span><br><span class="line"><span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line"><span class="comment">//集合c是个空的，直接返回false，什么也不做。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//集合c是非空的，定义两个节点(内部类)，每个节点都有三个属性，item、next、prev。注</span></span><br><span class="line">意：不要管这两个什么含义，就是用来做临时存储节点的。这个Node看下面一步的源码分析，Node就是</span><br><span class="line">linkedList的最核心的实现，可以直接先跳下一个去看Node的分析</span><br><span class="line">Node&lt;E&gt; pred, succ;</span><br><span class="line"><span class="comment">//构造方法中传过来的就是index==size</span></span><br><span class="line"><span class="keyword">if</span> (index == size) &#123;</span><br><span class="line"><span class="comment">//linkedList中三个属性：size、first、last。 size：链表中的元素个数。</span></span><br><span class="line">first：头节点 last：尾节点，就两种情况能进来这里</span><br><span class="line"><span class="comment">//情况一、：构造方法创建的一个空的链表，那么size=0，last、和first都为null。</span></span><br><span class="line">linkedList中是空的。什么节点都没有。succ=<span class="keyword">null</span>、pred=last=<span class="keyword">null</span></span><br><span class="line"><span class="comment">//情况二、：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最</span></span><br><span class="line">后一个节点，在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到</span><br><span class="line">pred临时节点中。</span><br><span class="line">succ = <span class="keyword">null</span>;</span><br><span class="line">pred = last;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知</span></span><br><span class="line">道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存</span><br><span class="line">了这两个节点，就能够准确的插入节点了</span><br><span class="line"><span class="comment">//举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，就需要知</span></span><br><span class="line">道第一个位置是谁，原位置也就是第二个位置上是谁，然后才能将自己插到第二个位置上。如果这里还不</span><br><span class="line">明白，先看一下文章开头对于各种链表的删除，add操作是怎么实现的。</span><br><span class="line">succ = node(index);</span><br><span class="line">pred = succ.prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前面的准备工作做完了，将遍历数组a中的元素，封装为一个个节点。</span></span><br><span class="line"><span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line"><span class="comment">//pred就是之前所构建好的，可能为null、也可能不为null，为null的话就是属于情况</span></span><br><span class="line">一、不为<span class="keyword">null</span>则可能是情况二、或者情况三</span><br><span class="line">Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，此时的newNode</span></span><br><span class="line">就当作第一个节点，所以把newNode给first头节点</span><br><span class="line"><span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">first = newNode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//如果pred！=null，说明可能是情况2或者情况3，如果是情况2，pred就是last，</span></span><br><span class="line">那么在最后一个节点之后追加到newNode，如果是情况<span class="number">3</span>，在中间插入，pred为原index节点之前的一</span><br><span class="line">个节点，将它的next指向插入的节点，也是对的</span><br><span class="line">pred.next = newNode;</span><br><span class="line"><span class="comment">//然后将pred换成newNode，注意，这个不在else之中，请看清楚了。</span></span><br><span class="line">pred = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果succ==null，说明是情况一或者情况二，</span></span><br><span class="line"><span class="comment">情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，</span></span><br><span class="line"><span class="comment">last=newNode，所以linkedList的first、last都指向第一个节点。</span></span><br><span class="line"><span class="comment">情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点</span></span><br><span class="line"><span class="comment">了，就是newNode。*/</span></span><br><span class="line">last = pred;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果succ！=null，说明可能是情况三、在中间插入节点，举例说明这几个参数的意义，</span></span><br><span class="line">有<span class="number">1</span>、<span class="number">2</span>两个节点，现在想在第二个位置插入节点newNode，根据前面的代码，pred=newNode，</span><br><span class="line">succ=<span class="number">2</span>，并且<span class="number">1.</span>next=newNode，已经构建好了，pred.next=succ，相当于在newNode.next =</span><br><span class="line"><span class="number">2</span>； succ.prev = pred，相当于 <span class="number">2.</span>prev = newNode， 这样一来，这种指向关系就完成了。</span><br><span class="line">first和last不用变，因为头节点和尾节点没变</span><br><span class="line">pred.next = succ;</span><br><span class="line"><span class="comment">//。。</span></span><br><span class="line">succ.prev = pred;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加了几个元素，就把 size = size +numNew 就可以了</span></span><br><span class="line">size += numNew;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：参数中的index表示在索引下标为index的结点（实际上是第index + <span class="number">1</span>个结点）的前面插</span><br><span class="line">入。</span><br><span class="line">在addAll函数中，addAll函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索</span><br><span class="line">引下标找到该结点并返回，具体代码如下：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断插入的位置在链表前半段或者是后半段</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">// 插入位置在前半段</span></span><br><span class="line">Node&lt;E&gt; x = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) <span class="comment">// 从头结点开始正向遍历</span></span><br><span class="line">x = x.next;</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// 返回该结点</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入位置在后半段</span></span><br><span class="line">Node&lt;E&gt; x = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) <span class="comment">// 从尾结点开始反向遍历</span></span><br><span class="line">x = x.prev;</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// 返回该结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：在根据索引查找结点时，会有一个小优化，结点在前半段则从头开始遍历，在后半段则从尾开始</span><br><span class="line">遍历，这样就保证了只需要遍历最多一半结点就可以找到指定索引的结点。</span><br><span class="line">举例说明调用addAll函数后的链表状态：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">lists.add(<span class="number">5</span>);</span><br><span class="line">lists.addAll(<span class="number">0</span>, Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">上述代码内部的链表结构如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/uLoP4eshN3ibjt7.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addAll()中的一个问题：</span><br><span class="line">在addAll函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加</span><br><span class="line">数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？</span><br><span class="line">从效果上两者是完全等价的，都可以达到遍历的效果。关于为什么要转化为数组的问题，我的思考如</span><br><span class="line">下：</span><br><span class="line"><span class="number">1.</span> 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，这</span><br><span class="line">个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。</span><br><span class="line"><span class="number">2.</span> 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，所以占用的时间相对是</span><br><span class="line">较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的</span><br><span class="line">效率，尽可能短时间的阻塞。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、remove(Object o)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">* if it is present. If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment">* unchanged. More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment">* &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))</span></span><br><span class="line"><span class="comment">&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* (if such an element exists). Returns &#123;<span class="doctag">@code</span> true&#125; if this list</span></span><br><span class="line"><span class="comment">* contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">* changed as a result of the call).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contained the specified element</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//首先通过看上面的注释，我们可以知道，如果我们要移除的值在链表中存在多个一样的值，那么我们</span></span><br><span class="line">会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里可以看到，linkedList也能存储null</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//循环遍历链表，直到找到null值，然后使用unlink移除该值。下面的这个else中也一样</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">unlink(x);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">unlink(x);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【unlink(xxxx)】</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//不能传一个null值过，注意，看之前要注意之前的next、prev这些都是谁。</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert x != null;</span></span><br><span class="line"><span class="comment">//拿到节点x的三个属性</span></span><br><span class="line"><span class="keyword">final</span> E element = x.item;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"><span class="comment">//这里开始往下就进行移除该元素之后的操作，也就是把指向哪个节点搞定。</span></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//说明移除的节点是头节点，则first头节点应该指向下一个节点</span></span><br><span class="line">first = next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不是头节点，prev.next=next：有1、2、3，将1.next指向3</span></span><br><span class="line">prev.next = next;</span><br><span class="line"><span class="comment">//然后解除x节点的前指向。</span></span><br><span class="line">x.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//说明移除的节点是尾节点</span></span><br><span class="line">last = prev;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不是尾节点，有1、2、3，将3.prev指向1. 然后将2.next=解除指向。</span></span><br><span class="line">next.prev = prev;</span><br><span class="line">x.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x的前后指向都为null了，也把item为null，让gc回收它</span></span><br><span class="line">x.item = <span class="keyword">null</span>;</span><br><span class="line">size--; <span class="comment">//移除一个节点，size自减</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">return</span> element; <span class="comment">//由于一开始已经保存了x的值到element，所以返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、get(index)</span><br><span class="line">【get(index)查询元素的方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这里没有什么，重点还是在node(index)中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">checkElementIndex(index);</span><br><span class="line"><span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【node(index)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这里查询使用的是先从中间分一半查找</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">//&quot;&lt;&lt;&quot;:*2的几次方 “&gt;&gt;”:/2的几次方，例如：size&lt;&lt;1：size*2的1次方，</span></span><br><span class="line"><span class="comment">//这个if中就是查询前半部分</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//index&lt;size/2</span></span><br><span class="line">Node&lt;E&gt; x = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">x = x.next;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//前半部分没找到，所以找后半部分</span></span><br><span class="line">Node&lt;E&gt; x = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">x = x.prev;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、indexOf(Object o)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//这个很简单，就是通过实体元素来查找到该元素在链表中的位置。跟remove中的代码类似，只是返回</span></span><br><span class="line">类型不一样。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、LinkedList的迭代器</span><br><span class="line">在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是ListItr，还有一个</span><br><span class="line">是DescendingIterator。</span><br><span class="line">【ListItr内部类】</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看一下他的继承结构，发现只继承了一个ListIterator，到ListIterator中一看：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/PgXtCwVSJGbIMiN.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看到方法名之后，就发现不止有向后迭代的方法，还有向前迭代的方法，所以我们就知道了这个ListItr</span><br><span class="line">这个内部类干嘛用的了，就是能让linkedList不光能像后迭代，也能向前迭代。</span><br><span class="line"></span><br><span class="line">看一下ListItr中的方法，可以发现，在迭代的过程中，还能移除、修改、添加值得操作。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/FWhqwA348eOf6im.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【DescendingIterator内部类】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//看一下这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维</span></span><br><span class="line">去写代码，例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特</span><br><span class="line">殊的previous。</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> itr.previous();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">itr.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、总结</span><br><span class="line"><span class="number">1.</span> linkedList本质上是一个双向链表，通过一个Node内部类实现的这种链表结构。</span><br><span class="line"><span class="number">2.</span> 能存储<span class="keyword">null</span>值</span><br><span class="line"><span class="number">3.</span> 跟arrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查</span><br><span class="line">询的性能上好</span><br><span class="line"><span class="number">4.</span> 从源码中看，它不存在容量不足的情况</span><br><span class="line"><span class="number">5.</span> linkedList不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能</span><br><span class="line">移除值。</span><br><span class="line"><span class="number">6.</span> linkedList不光能当链表，还能当队列使用，这个就是因为实现了Deque接口。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vevtor和Stack</span><br><span class="line"></span><br><span class="line">前面写了一篇关于的是LinkedList的除了它的数据结构稍微有一点复杂之外，其他的都很好理解的。这</span><br><span class="line">一篇讲的可能大家在开发中很少去用到。但是有的时候也可能是会用到的！</span><br><span class="line">注意在学习这一篇之前，需要有多线程的知识：</span><br><span class="line"><span class="number">1</span>）锁机制：对象锁、方法锁、类锁</span><br><span class="line">对象锁就是方法锁：就是在一个类中的方法上加上<span class="keyword">synchronized</span>关键字，这就是给这个方法加锁了。</span><br><span class="line">类锁：锁的是整个类，当有多个线程来声明这个类的对象的时候将会被阻塞，直到拥有这个类锁的对象</span><br><span class="line">被销毁或者主动释放了类锁。这个时候在被阻塞住的线程被挑选出一个占有该类锁，声明该类的对象。</span><br><span class="line">其他线程继续被阻塞住。例如：在类A上有关键字<span class="keyword">synchronized</span>，那么就是给类A加了类锁，线程<span class="number">1</span>第一</span><br><span class="line">个声明此类的实例，则线程<span class="number">1</span>拿到了该类锁，线程<span class="number">2</span>在想声明类A的对象，就会被阻塞。</span><br><span class="line"><span class="number">2</span>）在本文中，使用的是方法锁。</span><br><span class="line"><span class="number">3</span>）每个对象只有一把锁，有线程A，线程B，还有一个集合C类，线程A操作C拿到了集合中的锁(在</span><br><span class="line">集合C中有用<span class="keyword">synchronized</span>关键字修饰的)，并且还没有执行完，那么线程A就不会释放锁，当轮到线程B</span><br><span class="line">去操作集合C中的方法时 ，发现锁被人拿走了，所以线程B只能等待那个拿到锁的线程使用完，然后才能</span><br><span class="line">拿到锁进行相应的操作。</span><br><span class="line"><span class="number">1</span> Vector</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、Vector概述</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/XQUI9DReoi61VGh.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过API中可以知道：</span><br><span class="line"><span class="number">1.</span> Vector是一个可变化长度的数组</span><br><span class="line"><span class="number">2.</span> Vector增加长度通过的是capacity和capacityIncrement这两个变量，目前还不知道如何实现自动</span><br><span class="line">扩增的，等会源码分析</span><br><span class="line"><span class="number">3.</span> Vector也可以获得iterator和listIterator这两个迭代器，并且他们发生的是fail-fast，而不是failsafe，注意这里，不要觉得这个vector是线程安全就搞错了，具体分析在下面会说</span><br><span class="line"><span class="number">4.</span> Vector是一个线程安全的类，如果使用需要线程安全就使用Vector，如果不需要，就使用arrayList</span><br><span class="line"><span class="number">5.</span> Vector和ArrayList很类似，就少许的不一样，从它继承的类和实现的接口来看，跟arrayList一模一</span><br><span class="line">样。</span><br><span class="line">注意：现在的版本已经是jdk1.<span class="number">7</span>，还有更高的jdk1.<span class="number">8</span>了，在开发中，建议不用vector，原因在文章的</span><br><span class="line">结束会有解释，如果需要线程安全的集合类直接用java.util.concurrent包下的类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Vector源码分析</span><br><span class="line">【继承结构和层次关系】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/elHxyXM1oNQU4tw.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们发现Vector的继承关系和层次结构和ArrayList中的一模一样，不懂的可以去前面的博客查看！</span><br><span class="line">【构造方法】</span><br><span class="line">一共有四个构造方法。最后两个构造方法是collection Framwork的规范要写的构造方法。</span><br><span class="line">构造方法作用：</span><br><span class="line"><span class="number">1.</span> 初始化存储元素的容器，也就是数组，elementData，</span><br><span class="line"><span class="number">2.</span> 初始化capacityIncrement的大小，默认是<span class="number">0</span>，这个的作用就是扩展数组的时候，增长的大小，为<span class="number">0</span></span><br><span class="line">则每次扩展<span class="number">2</span>倍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【Vector()：空构造】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty vector so that its internal data array</span></span><br><span class="line"><span class="comment">* has size &#123;<span class="doctag">@code</span> 10&#125; and its standard capacity increment is</span></span><br><span class="line"><span class="comment">* zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//看注释，这个是一个空的Vector构造方法，所以让他使用内置的数组，这里还不知道什么是内置的数</span></span><br><span class="line">组，看它调用了自身另外一个带一个参数的构造器</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【Vector(<span class="keyword">int</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">* with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> initialCapacity the initial capacity of the vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">* is negative</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//注释说，给空的cector构造器用和带有一个特定初始化容量用的，并且又调用了另外一个带两个参数</span></span><br><span class="line">的构造器，并且给容量增长值(capacityIncrement=<span class="number">0</span>)为<span class="number">0</span>，查看vector中的变量可以发现</span><br><span class="line">capacityIncrement是一个成员变量</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【ector(<span class="keyword">int</span>，<span class="keyword">int</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">* capacity increment.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> initialCapacity the initial capacity of the vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> capacityIncrement the amount by which the capacity is</span></span><br><span class="line"><span class="comment">* increased when the vector overflows</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">* is negative</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构建一个有特定的初始化容量和容量增长值的空的Vector，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();<span class="comment">//调用父类的构造，是个空构造</span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)<span class="comment">//小于0，会报非法参数异常：不合法的容量</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">initialCapacity);</span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//elementData是一个成员变量</span></span><br><span class="line">数组，初始化它，并给它初始化长度。默认就是<span class="number">10</span>，除非自己给值。</span><br><span class="line"><span class="keyword">this</span>.capacityIncrement = capacityIncrement;<span class="comment">//capacityIncrement的意思是如果</span></span><br><span class="line">要扩增数组，每次增长该值，如果该值为<span class="number">0</span>，那数组就变为两倍的原长度，这个之后会分析到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【Vector(Collection&lt;? extends E&gt; c)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a vector containing the elements of the specified</span></span><br><span class="line"><span class="comment">* collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment">* iterator.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> c the collection whose elements are to be placed into this</span></span><br><span class="line"><span class="comment">* vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//将集合c变为Vector，返回Vector的迭代器。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">elementData = c.toArray();</span><br><span class="line">elementCount = elementData.length;</span><br><span class="line"><span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">elementData = Arrays.copyOf(elementData, elementCount,</span><br><span class="line">Object[].class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、核心方法</span><br><span class="line">【add()方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//就是在vector中的末尾追加元素。但是看方法，synchronized，明白了为什么vector是线程安全</span></span><br><span class="line">的，因为在方法前面加了<span class="keyword">synchronized</span>关键字，给该方法加锁了，哪个线程先调用它，其它线程就得</span><br><span class="line">等着，如果不清楚的就去看看多线程的知识，到后面我也会一一总结的。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">//通过arrayList的源码分析经验，这个方法应该是在增加元素前，检查容量是否够用</span></span><br><span class="line">ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">elementData[elementCount++] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【ensureCapacityHelper(<span class="keyword">int</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This implements the unsynchronized semantics of ensureCapacity.</span></span><br><span class="line"><span class="comment">* Synchronized methods in this class can internally call this</span></span><br><span class="line"><span class="comment">* method for ensuring capacity without incurring the cost of an</span></span><br><span class="line"><span class="comment">* extra synchronization.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #ensureCapacity(int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这里注释解释，这个方法是异步(也就是能被多个线程同时访问)的，原因是为了让同步方法都能调用</span></span><br><span class="line">到这个检测容量的方法，比如add的同时，另一个线程调用了add的重载方法，那么两个都需要同时查询</span><br><span class="line">容量够不够，所以这个就不需要用<span class="keyword">synchronized</span>修饰了。因为不会发生线程不安全的问题</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//容量不够，就扩增，核心方法</span></span><br><span class="line">grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【grow(<span class="keyword">int</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//看一下这个方法，其实跟arrayList一样，唯一的不同就是在扩增数组的方式不一样，如果</span></span><br><span class="line">capacityIncrement不为<span class="number">0</span>，那么增长的长度就是capacityIncrement，如果为<span class="number">0</span>，那么扩增为<span class="number">2</span>倍</span><br><span class="line">的原容量</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">capacityIncrement : oldCapacity);</span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">感觉只要你能看的懂ArrayList，这个就是在每个方法上比arrayList多了一个<span class="keyword">synchronized</span>，其他都一</span><br><span class="line">样。这里就不再分析了！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"><span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> Stack</span><br><span class="line">现在来看看Vector的子类Stack，学过数据结构都知道，这个就是栈的意思。那么该类就是跟栈的用法一</span><br><span class="line">样了</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">通过查看他的方法，和查看api文档，很容易就能知道他的特性。就几个操作，出栈，入栈等，构造方法</span><br><span class="line">也是空的，用的还是数组，父类中的构造，跟父类一样的扩增方式，并且它的方法也是同步的，所以也</span><br><span class="line">是线程安全。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/D2nmoG6YERTMxUj.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> 总结Vector和Stack</span><br><span class="line">【Vector总结（通过源码分析）】</span><br><span class="line"><span class="number">1.</span> Vector线程安全是因为它的方法都加了<span class="keyword">synchronized</span>关键字</span><br><span class="line"><span class="number">2.</span> Vector的本质是一个数组，特点能是能够自动扩增，扩增的方式跟capacityIncrement的值有关</span><br><span class="line"><span class="number">3.</span> 它也会fail-fast，还有一个fail-safe两个的区别在下面的list总结中会讲到。</span><br><span class="line">【Stack的总结】</span><br><span class="line"><span class="number">1.</span> 对栈的一些操作，先进后出</span><br><span class="line"><span class="number">2.</span> 底层也是用数组实现的，因为继承了Vector</span><br><span class="line"><span class="number">3.</span> 也是线程安全的</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> List总结</span><br><span class="line">【arrayList和LinkedList区别】</span><br><span class="line">arrayList底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长</span><br><span class="line">度是<span class="number">0</span>，只有在增加元素时，长度才会增加。默认是<span class="number">10</span>，不能无限扩增，有上限，在查询操作的时候性</span><br><span class="line">能更好</span><br><span class="line">LinkedList底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表,顺序存取类型。</span><br><span class="line">在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性</span><br><span class="line">能更好。</span><br><span class="line">两个都是线程不安全的，在iterator时，会发生fail-fast：快速失效。</span><br><span class="line">    </span><br><span class="line">【arrayList和Vector的区别】</span><br><span class="line">arrayList线程不安全，在用iterator，会发生fail-fast</span><br><span class="line">Vector线程安全，因为在方法前加了Synchronized关键字。也会发生fail-fast</span><br><span class="line">    </span><br><span class="line">【fail-fast和fail-safe区别和什么情况下会发生】</span><br><span class="line">简单的来说：在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是failsafe。</span><br><span class="line"><span class="number">1</span>）fail-fast</span><br><span class="line">快速失败，例如在arrayList中使用迭代器遍历时，有另外的线程对arrayList的存储数组进行了改变，比</span><br><span class="line">如add、delete、等使之发生了结构上的改变，所以Iterator就会快速报一个</span><br><span class="line">java.util.ConcurrentModificationException 异常（并发修改异常），这就是快速失败。</span><br><span class="line"><span class="number">2</span>）fail-safe</span><br><span class="line">安全失败，在java.util.concurrent下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行</span><br><span class="line">结构的改变，不会报异常，而是正常遍历，这就是安全失败。</span><br><span class="line"><span class="number">3</span>）为什么在java.util.concurrent包下对集合有结构的改变，却不会报异常？</span><br><span class="line">在concurrent下的集合类增加元素的时候使用Arrays.copyOf()来拷贝副本，在副本上增加元素，如果有</span><br><span class="line">其他线程在此改变了集合的结构，那也是在副本上的改变，而不是影响到原集合，迭代器还是照常遍</span><br><span class="line">历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出</span><br><span class="line">现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe。</span><br><span class="line"><span class="number">4</span>）vector也是线程安全的，为什么是fail-fast呢？</span><br><span class="line">这里搞清楚一个问题，并不是说线程安全的集合就不会报fail-fast，而是报fail-safe，你得搞清楚前面所</span><br><span class="line">说答案的原理，出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副</span><br><span class="line">本，而像arrayList、linekdList、verctor等，他们底层就是对着真正的引用进行操作，所以才会发生异</span><br><span class="line">常。</span><br><span class="line"><span class="number">5</span>）既然是线程安全的，为什么在迭代的时候，还会有别的线程来改变其集合的结构呢(也就是对其</span><br><span class="line">删除和增加等操作)？</span><br><span class="line">首先，我们迭代的时候，根本就没用到集合中的删除、增加，查询的操作，就拿vector来说，我们都没</span><br><span class="line">有用那些加锁的方法，也就是方法锁放在那没人拿，在迭代的过程中，有人拿了那把锁，我们也没有办</span><br><span class="line">法，因为那把锁就放在那边。</span><br><span class="line">    </span><br><span class="line">【举例说明fail-fast和fail-safe的区别】</span><br><span class="line"><span class="number">1.</span> fail-fast</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/JyfluRxUWtN9KMS.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> fail-safe</span><br><span class="line">通过CopyOnWriteArrayList这个类来做实验，不用管这个类的作用，但是他确实没有报异常，</span><br><span class="line">并且还通过第二次打印，来验证了上面我们说创建了副本的事情。</span><br><span class="line">原理是在添加操作时会创建副本，在副本上进行添加操作，等迭代器遍历结束后，会将原引用</span><br><span class="line">改为副本引用，所以我们在创建了一个list的迭代器，结果打印的就是<span class="number">123444</span>了，</span><br><span class="line">证明了确实改变成为了副本引用，后面为什么是三个<span class="number">4</span>，原因是我们循环了<span class="number">3</span>次，不久添加了<span class="number">3</span></span><br><span class="line">个<span class="number">4</span>吗。如果还感觉不爽的话，看下add的源码。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/4KJxhTMQXPzAERs.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【为什么现在都不提倡使用vector了】</span><br><span class="line"><span class="number">1</span>）vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中，</span><br><span class="line">一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安</span><br><span class="line">全。</span><br><span class="line"><span class="number">2</span>）如果多个Thread并发执行一个已经加锁的方法，但是在该方法中，又有vector的存在，vector</span><br><span class="line">本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销。</span><br><span class="line"><span class="number">3</span>）就如上面第三个问题所说的，vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在</span><br><span class="line">遍历时又得额外加锁，又是额外的开销，还不如直接用arrayList，然后再加锁呢。</span><br><span class="line">总结：Vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在</span><br><span class="line">jdk1.<span class="number">5</span>之后就被弃用了，现在如果要用到线程安全的集合，都是从java.util.concurrent包下去拿相应的</span><br><span class="line">类。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> HashMap引入</span><br><span class="line">问题：建立国家英文简称和中文全名间的键值映射，并通过key对value进行操作，应该如何实现数据的</span><br><span class="line">存储和操作呢？</span><br><span class="line">分析：</span><br><span class="line"> Map接口专门处理键值映射数据的存储，可以根据键实现对值的操作。</span><br><span class="line">最常用的实现类是HashMap。</span><br><span class="line">【使用HashMap存储元素】</span><br><span class="line">【Map接口常用方法】</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> HashMap数据结构</span><br><span class="line"><span class="number">1</span>、HashMap概述</span><br><span class="line"> HashMap是基于哈希表的Map接口实现的，它存储的是内容是键值对&lt;key,value&gt;映射。此类不保证映</span><br><span class="line">射的顺序，假定哈希函数将元素适当的分布在各桶之间，可为基本操作(get和put)提供稳定的性能。</span><br><span class="line">在API中给出了相应的定义：</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value，可以为</span></span><br><span class="line"><span class="keyword">null</span>，(HashMap和HashTable大致上是一样的，除了hashmap是异步的，和允许key和value为</span><br><span class="line"><span class="keyword">null</span>)，</span><br><span class="line"><span class="comment">//这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不</span></span><br><span class="line">变。</span><br><span class="line">Hash table based implementation of the Map interface. This implementation</span><br><span class="line">provides all of the optional map operations, and permits <span class="keyword">null</span> values and the</span><br><span class="line"><span class="keyword">null</span> key.</span><br><span class="line">(The HashMap <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> <span class="title">Hashtable</span>, <span class="title">except</span> <span class="title">that</span> <span class="title">it</span> <span class="title">is</span></span></span><br><span class="line"><span class="class"><span class="title">unsynchronized</span> <span class="title">and</span> <span class="title">permits</span> <span class="title">nulls</span>.) <span class="title">This</span> <span class="title">class</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span></span></span><br><span class="line"><span class="class"><span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">map</span></span>;</span><br><span class="line">in particular, it does not guarantee that the order will remain constant</span><br><span class="line">over time.</span><br><span class="line"><span class="comment">//假设哈希函数将元素合适的分到了每个桶(其实就是指的数组中位置上的链表)中，则这个实现为基本</span></span><br><span class="line">的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashMap实例(key-value映射</span><br><span class="line">的数量)的容量(在桶中)成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者</span><br><span class="line">loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】</span><br><span class="line">This implementation provides constant-time performance <span class="keyword">for</span> the basic</span><br><span class="line">operations (get and put), assuming the hash function disperses the elements</span><br><span class="line">properly among the buckets.</span><br><span class="line">Iteration over collection views <span class="keyword">requires</span> time proportional to the</span><br><span class="line"><span class="string">&quot;capacity&quot;</span> <span class="function">of the HashMap <span class="title">instance</span> <span class="params">(the number of buckets)</span> plus its size</span></span><br><span class="line"><span class="function"><span class="params">(the number of key-value mappings</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>. Thus, it&#x27;s very important not to set the initial capacity too <span class="title">high</span> <span class="params">(or</span></span></span><br><span class="line"><span class="function"><span class="params">the load factor too low)</span> <span class="keyword">if</span> iteration performance is important.</span></span><br><span class="line"><span class="function"><span class="comment">//HashMap的实例有两个参数影响性能，初始化容量(initialCapacity)和loadFactor加载因子，</span></span></span><br><span class="line"><span class="function">在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量，</span></span><br><span class="line"><span class="function">在容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载</span></span><br><span class="line"><span class="function">因子乘以当前的容量，那么哈希表被修改<span class="params">(内部的数据结构会被重新建立)</span>所以哈希表有大约两倍的桶的</span></span><br><span class="line"><span class="function">数量.</span></span><br><span class="line"><span class="function">An instance of HashMap has two parameters that affect its performance:</span></span><br><span class="line"><span class="function">initial capacity and load factor. The capacity is the number of buckets in</span></span><br><span class="line"><span class="function">the hash table,</span></span><br><span class="line"><span class="function">and the initial capacity is simply the capacity at the time the hash table</span></span><br><span class="line"><span class="function">is created. The load factor is a measure of how full the hash table is</span></span><br><span class="line"><span class="function">allowed to get before</span></span><br><span class="line"><span class="function">its capacity is automatically increased. When the number of entries in the</span></span><br><span class="line"><span class="function">hash table exceeds the product of the load factor and the current capacity,</span></span><br><span class="line"><span class="function">the hash table</span></span><br><span class="line"><span class="function">is <span class="title">rehashed</span> <span class="params">(that is, internal data structures are rebuilt)</span> so that the hash</span></span><br><span class="line"><span class="function">table has approximately twice the number of buckets.</span></span><br><span class="line"><span class="function"><span class="comment">//通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的</span></span></span><br><span class="line"><span class="function">开支但是会增加查询花费的时间（体现在HashMap类中get、put方法上），当设置初始化容量时，应该</span></span><br><span class="line"><span class="function">考虑到map中会存放entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最</span></span><br><span class="line"><span class="function">大条目数除以加载因子，则不会发生 rehash 操作。</span></span><br><span class="line"><span class="function">As a general rule, the <span class="keyword">default</span> load <span class="title">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good tradeoff</span></span><br><span class="line"><span class="function">between time and space costs. Higher values decrease the space overhead but</span></span><br><span class="line"><span class="function">increase the lookup</span></span><br><span class="line"><span class="function"><span class="title">cost</span> <span class="params">(reflected in most of the operations of the HashMap class, including</span></span></span><br><span class="line"><span class="function"><span class="params">get and put)</span>. The expected number of entries in the map and its load factor</span></span><br><span class="line"><span class="function">should be taken</span></span><br><span class="line"><span class="function">into account when setting its initial capacity, so as to minimize the number</span></span><br><span class="line"><span class="function">of rehash operations. If the initial capacity is greater than the maximum</span></span><br><span class="line"><span class="function">number of</span></span><br><span class="line"><span class="function">entries divided by the load factor, no rehash operations will ever occur.</span></span><br><span class="line"><span class="function"><span class="comment">//如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的</span></span></span><br><span class="line"><span class="function">容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</span></span><br><span class="line"><span class="function">If many mappings are to be stored in a HashMap instance, creating it with a</span></span><br><span class="line"><span class="function">sufficiently large capacity will allow the mappings to be stored more</span></span><br><span class="line"><span class="function">efficiently than letting</span></span><br><span class="line"><span class="function">it perform automatic rehashing as needed to grow the table</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2、HashMap在JDK1.8以前数据结构和存储原理</span></span><br><span class="line"><span class="function">【链表散列】</span></span><br><span class="line"><span class="function">首先我们要知道什么是链表散列？通过数组和链表结合在一起使用，就叫做链表散列。这其实就是</span></span><br><span class="line"><span class="function">hashmap存储的原理图。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/ePQMtzSgXT5yUkJ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【HashMap的数据结构和存储原理】</span><br><span class="line"> HashMap的数据结构就是用的链表散列。那HashMap底层是怎么样使用这个数据结构进行数据存取的</span><br><span class="line">呢？分成两个部分：</span><br><span class="line">第一步：HashMap内部有一个entry的内部类，其中有四个属性，我们要存储一个值，则需要一个key</span><br><span class="line">和一个value，存到map中就会先将key和value保存在这个Entry类创建的对象中。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> K key; <span class="comment">//就是我们说的map的key</span></span><br><span class="line">V value; <span class="comment">//value值，这两个都不陌生</span></span><br><span class="line">Entry&lt;K,V&gt; next;<span class="comment">//指向下一个entry对象</span></span><br><span class="line"><span class="keyword">int</span> hash;<span class="comment">//通过key算过来的你hashcode值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry的物理模型图：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/HkV4qp8AQKIJ3bL.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第二步：构造好了entry对象，然后将该对象放入数组中，如何存放就是这hashMap的精华所在了。</span><br><span class="line">大概的一个存放过程是：通过entry对象中的hash值来确定将该对象存放在数组中的哪个位置上，如果</span><br><span class="line">在这个位置上还有其他元素，则通过链表来存储这个元素。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/xhkluCZ48mfqcJa.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【Hash存放元素的过程】</span><br><span class="line">通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash</span><br><span class="line">值和数组的长度length来计算出entry放在数组中的哪个位置上面，</span><br><span class="line">每次存放都是将entry放在第一个位置。在这个过程中，就是通过hash值来确定将该对象存放在数组中</span><br><span class="line">的哪个位置上。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、JDK1.<span class="number">8</span>后HashMap的数据结构</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/bpLmshwXN8FoY65.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红</span><br><span class="line">黑树，红黑树的引入是为了提高效率。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、HashMap的属性</span><br><span class="line">HashMap的实例有两个参数影响其性能。</span><br><span class="line">初始容量：哈希表中桶的数量</span><br><span class="line">加载因子：哈希表在其容量自动增加之前可以达到多满，的一种尺度</span><br><span class="line">当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行</span><br><span class="line">rehash操作，将哈希表扩充至两倍的桶数。</span><br><span class="line">Java中默认初始容量为<span class="number">16</span>，加载因子为<span class="number">0.75</span>。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">【loadFactor加载因子】</span><br><span class="line">定义：loadFactor译为装载因子。装载因子用来衡量HashMap满的程度。loadFactor的默认值为</span><br><span class="line"><span class="number">0.75f</span>。计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。</span><br><span class="line"> loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于<span class="number">1</span>，那么数组中存放的数据</span><br><span class="line">(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于<span class="number">0</span>，那么数组</span><br><span class="line">中存放的数据也就越稀，也就是可能数组中每个位置上就放一个元素。那有人说，就把loadFactor变为<span class="number">1</span></span><br><span class="line">最好吗，存的数据很多，但是这样会有一个问题，就是我们在通过key拿到我们的value时，是先通过key</span><br><span class="line">的hashcode值，找到对应数组中的位置，如果该位置中有很多元素，则需要通过equals来依次比较链表</span><br><span class="line">中的元素，拿到我们的value值，这样花费的性能就很高，如果能让数组上的每个位置尽量只有一个元素</span><br><span class="line">最好，我们就能直接得到value值了，所以有人又会说，那把loadFactor变得很小不就好了，但是如果变</span><br><span class="line">得太小，在数组中的位置就会太稀，也就是分散的太开，浪费很多空间，这样也不好，所以在hashMap</span><br><span class="line">中loadFactor的初始值就是<span class="number">0.75</span>，一般情况下不需要更改它。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">【桶】</span><br><span class="line">根据前面画的HashMap存储的数据结构图，你这样想，数组中每一个位置上都放有一个桶，每个桶里</span><br><span class="line">就是装一个链表，链表中可以有很多个元素(entry)，这就是桶的意思。也就相当于把元素都放在桶中。</span><br><span class="line">【capacity】</span><br><span class="line"> capacity译为容量代表的数组的容量，也就是数组的长度，同时也是HashMap中桶的个数。默认值是</span><br><span class="line"><span class="number">16</span>。</span><br><span class="line">一般第一次扩容时会扩容到<span class="number">64</span>，之后好像是<span class="number">2</span>倍。总之，容量都是<span class="number">2</span>的幂。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">【size的含义】</span><br><span class="line"> size就是在该HashMap的实例中实际存储的元素的个数</span><br><span class="line">【threshold的作用】</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就</span><br><span class="line">是说，这个的意思就是衡量数组是否需要扩增的一个标准。</span><br><span class="line">注意这里说的是考虑，因为实际上要扩增数组，除了这个size&gt;=threshold条件外，还需要另外一个条</span><br><span class="line">件。</span><br><span class="line">什么时候会扩增数组的大小？在put一个元素时先size&gt;=threshold并且还要在对应数组位置上有元素，</span><br><span class="line">这才能扩增数组。</span><br><span class="line">我们通过一张HashMap的数据结构图来分析：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/CWm5cbzDElN1wxy.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> HashMap的源码分析</span><br><span class="line"><span class="number">1</span>、HashMap的层次关系与继承结构</span><br><span class="line"></span><br><span class="line">【HashMap继承结构】</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/zinKhSGoRLlW2Es.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上面就继承了一个abstractMap，也就是用来减轻实现Map接口的编写负担。</span><br><span class="line">【实现接口】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Map&lt;K,V&gt;：在AbstractMap抽象类中已经实现过的接口，这里又实现，实际上是多余的。但每个集合</span><br><span class="line">都有这样的错误，也没过大影响</span><br><span class="line"> Cloneable：能够使用Clone()方法，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响</span><br><span class="line">被拷贝的对象。</span><br><span class="line"> Serializable：能够使之序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、HashMap类的属性</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"><span class="comment">// 默认的初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的填充因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line"><span class="comment">// 存放具体元素的集</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、HashMap的构造方法</span><br><span class="line">有四个构造方法，构造方法的作用就是记录一下<span class="number">16</span>这个数给threshold（这个数值最终会当作第一次数</span><br><span class="line">组的长度。）和初始化加载因子。注意，hashMap中table数组一开始就已经是个没有长度的数组了。</span><br><span class="line">构造方法中，并没有初始化数组的大小，数组在一开始就已经被创建了，构造方法只做两件事情，一个</span><br><span class="line">是初始化加载因子，另一个是用threshold记录下数组初始化的大小。注意是记录。</span><br><span class="line"></span><br><span class="line">【HashMap()】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//看上面的注释就已经知道，DEFAULT_INITIAL_CAPACITY=16，DEFAULT_LOAD_FACTOR=0.75</span></span><br><span class="line"><span class="comment">//初始化容量：也就是初始化数组的大小</span></span><br><span class="line"><span class="comment">//加载因子：数组上的存放数据疏密程度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【HashMap(<span class="keyword">int</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【HashMap(<span class="keyword">int</span>,<span class="keyword">float</span>)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始容量不能小于0，否则报错</span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">initialCapacity);</span><br><span class="line"><span class="comment">// 初始容量不能大于最大值，否则为最大值</span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="comment">// 填充因子不能小于或等于0，不能为非数字</span></span><br><span class="line"><span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">loadFactor);</span><br><span class="line"><span class="comment">// 初始化填充因子</span></span><br><span class="line"><span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 初始化threshold大小</span></span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【HashMap(Map&lt;? extends K, ? extends V&gt; m)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化填充因子</span></span><br><span class="line"><span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line"><span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【putMapEntries(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)函数将m的所有元素存入本HashMap实例中】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = m.size();</span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 判断table是否已经初始化</span></span><br><span class="line"><span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line"><span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line"><span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line"><span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">(<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line"><span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line"><span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">threshold = tableSizeFor(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">K key = e.getKey();</span><br><span class="line">V value = e.getValue();</span><br><span class="line">putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、常用方法</span><br><span class="line">【put(K key,V value)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【putVal(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点</span></span><br><span class="line">是放在数组中)</span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 桶中已经存在元素</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 放入树中</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// 为链表结点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 在链表最末插入结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">// 到达链表的尾部</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 在尾部插入新结点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">// 跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">// 相等，跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 记录e的value</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//用新值替换旧值</span></span><br><span class="line">e.value = value;</span><br><span class="line"><span class="comment">// 访问后回调</span></span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="comment">// 返回旧值</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构性修改</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">// 插入后回调</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap并没有直接提供putVal接口给用户调用，而是提供的put函数，而put函数就是通过putVal来插</span><br><span class="line">入元素的。</span><br><span class="line">【get(Object key)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【getNode(<span class="keyword">int</span> hash,Pbject key)】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// table已经初始化，长度大于0，根据hash寻找table中的项也不为空</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 桶中第一项(数组元素)相等</span></span><br><span class="line"><span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="comment">// 桶中不止一个结点</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 为红黑树结点</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 在红黑树中查找</span></span><br><span class="line"><span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="comment">// 否则，在链表中查找</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> HashMap并没有直接提供getNode接口给用户调用，而是提供的get函数，而get函数就是通过</span><br><span class="line">getNode来取得元素的。</span><br><span class="line"></span><br><span class="line">【resize方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="comment">// 当前table保存</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"><span class="comment">// 保存table大小</span></span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="comment">// 保存当前阈值</span></span><br><span class="line"><span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"><span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 之前table大小大于0</span></span><br><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 之前table大于最大容量</span></span><br><span class="line"><span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line"><span class="comment">// 阈值为最大整形</span></span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">return</span> oldTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 容量翻倍，使用左移，效率更高</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"><span class="comment">// 阈值翻倍</span></span><br><span class="line">newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之前阈值大于0</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">newCap = oldThr;</span><br><span class="line"><span class="comment">// oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个</span></span><br><span class="line">元素会调用resize函数，会进入这一步）</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新阈值为0</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY</span><br><span class="line">?</span><br><span class="line">(<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="comment">// 初始化table</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="comment">// 之前的table已经初始化过</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 复制元素，重新进行hash</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="comment">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两</span></span><br><span class="line">个不同的链表，完成rehash</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = e.next;</span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">loTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程</span><br><span class="line">序中，要尽量避免resize。</span><br><span class="line">在resize前和resize后的元素布局如下:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/tvYckPZN3XKROws.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上图只是针对了数组下标为<span class="number">2</span>的桶中的各个元素在扩容后的分配布局，其他各个桶中的元素布局可以以此</span><br><span class="line">类推。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 总结</span><br><span class="line">【关于数组扩容】</span><br><span class="line">从putVal源代码中我们可以知道，当插入一个元素的时候size就加<span class="number">1</span>，若size大于threshold的时候，就</span><br><span class="line">会进行扩容。假设我们的capacity大小为<span class="number">32</span>，loadFator为<span class="number">0.75</span>,则threshold为<span class="number">24</span> = <span class="number">32</span> * <span class="number">0.75</span>，</span><br><span class="line">此时，插入了<span class="number">25</span>个元素，并且插入的这<span class="number">25</span>个元素都在同一个桶中，桶中的数据结构为红黑树，则还</span><br><span class="line">有<span class="number">31</span>个桶是空的，也会进行扩容处理，其实，此时，还有<span class="number">31</span>个桶是空的，好像似乎不需要进行扩容处</span><br><span class="line">理，但是是需要扩容处理的，因为此时我们的capacity大小可能不适当。我们前面知道，扩容处理会遍</span><br><span class="line">历所有的元素，时间复杂度很高；前面我们还知道，经过一次扩容处理后，元素会更加均匀的分布在各</span><br><span class="line">个桶中，会提升访问效率。所以，说尽量避免进行扩容处理，也就意味着，遍历元素所带来的坏处大于</span><br><span class="line">元素在桶中均匀分布所带来的好处。</span><br><span class="line"></span><br><span class="line">【总结】</span><br><span class="line"><span class="number">1.</span> 要知道hashMap在JDK1.<span class="number">8</span>以前是一个链表散列这样一个数据结构，而在JDK1.<span class="number">8</span>以后是一个数组加</span><br><span class="line">链表加红黑树的数据结构。</span><br><span class="line"><span class="number">2.</span> 通过源码的学习，hashMap是一个能快速通过key获取到value值得一个集合，原因是内部使用的</span><br><span class="line">是hash查找值得方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迭代器</span><br><span class="line">所有实现了Collection接口的容器类都有一个iterator方法用以返回一个实现Iterator接口的对象</span><br><span class="line"></span><br><span class="line">Iterator对象称作为迭代器，用以方便的对容器内元素的遍历操作，Iterator接口定义了如下方法：</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hashNext</span><span class="params">()</span></span>;<span class="comment">//判断是否有元素没有被遍历</span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//返回游标当前位置的元素并将游标移动到下一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除游标左边的元素，在执行完next之后该操作只能执行一次</span></span><br><span class="line"></span><br><span class="line">问题：何遍历Map集合呢？</span><br><span class="line">分析：</span><br><span class="line">方法<span class="number">1</span>：通过迭代器Iterator实现遍历</span><br><span class="line">获取Iterator ：Collection 接口的iterator()方法</span><br><span class="line">Iterator的方法：</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>: 判断是否存在另一个可访问的元素</span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span>: 返回要访问的下一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function">Set keys</span>=dogMap.keySet(); <span class="comment">//取出所有key的集合</span></span><br><span class="line">Iterator it=keys.iterator(); <span class="comment">//获取Iterator对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String key=(String)it.next(); <span class="comment">//取出key</span></span><br><span class="line">Dog dog=(Dog)dogMap.get(key); <span class="comment">//根据key取出对应的值</span></span><br><span class="line">System.out.println(key+<span class="string">&quot;\t&quot;</span>+dog.getStrain());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：增强<span class="keyword">for</span>循环</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">for</span>(元素类型t 元素变量x : 数组或集合对象)&#123;</span><br><span class="line">引用了x的java语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">泛型</span><br><span class="line">Java 泛型（generics）是 JDK <span class="number">5</span> 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</span><br><span class="line">泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</span><br><span class="line">如何解决以下强制类型转换时容易出现的异常问题?</span><br><span class="line"> List的get(<span class="keyword">int</span> index)方法获取元素</span><br><span class="line"> Map的get(Object key)方法获取元素</span><br><span class="line"> Iterator的next()方法获取元素</span><br><span class="line">分析：通过泛型 ， JDK1.<span class="number">5</span>使用泛型改写了集合框架中的所有接口和类</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/LcU63Q5WuwlosMi.png"></p>
<p><img src="https://i.loli.net/2020/09/23/R1XnwlVKxc4kOhy.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">？ 通配符： &lt; ? &gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections工具类</span><br><span class="line">【前言】</span><br><span class="line">Java提供了一个操作Set、List和Map等集合的工具类：Collections，该工具类提供了大量方法对集合进</span><br><span class="line">行排序、查询和修改等操作，还提供了将集合对象置为不可变、对集合对象实现同步控制等方法。</span><br><span class="line">这个类不需要创建对象，内部提供的都是静态方法。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、Collectios概述</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/xImwlbfuUML82Aj.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为此类的方法所提供的 collection 或类对象为 <span class="keyword">null</span>，则这些方法都将抛出 NullPointerException 。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、排序操作</span><br><span class="line"></span><br><span class="line">【方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="number">1</span>）<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span>:</span></span><br><span class="line"><span class="function">反转列表中元素的顺序。</span></span><br><span class="line"><span class="function">2）<span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span> :</span></span><br><span class="line"><span class="function">对List集合元素进行随机排序。</span></span><br><span class="line"><span class="function">3） <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function">根据元素的自然顺序 对指定列表按升序进行排序</span></span><br><span class="line"><span class="function">4）<span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> :</span></span><br><span class="line"><span class="function">根据指定比较器产生的顺序对指定列表进行排序。</span></span><br><span class="line"><span class="function">5）<span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">在指定List的指定位置i,j处交换元素。</span></span><br><span class="line"><span class="function">6）<span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span></span></span><br><span class="line"><span class="function">当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为</span></span><br><span class="line"><span class="function">负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">【演示】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.ArrayList</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 排序操作 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(-<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(-<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//输出：[3, -2, 9, 5, -1, 6]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//集合元素的次序反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line"><span class="comment">//输出：[6, -1, 5, 9, -2, 3]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//排序：按照升序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"><span class="comment">//[-2, -1, 3, 5, 6, 9]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//根据下标进行交换</span></span><br><span class="line">        Collections.swap(list, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//像数组一样下标从0开始</span></span><br><span class="line"><span class="comment">//输出：[-2, -1, 9, 5, 6, 3]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">/*//随机排序</span></span><br><span class="line"><span class="comment">Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//每次输出的次序不固定</span></span><br><span class="line"><span class="comment">System.out.println(list);*/</span></span><br><span class="line"><span class="comment">//后两个整体移动到前边</span></span><br><span class="line">        Collections.rotate(list, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出：[6, 9, -2, -1, 3, 5]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果为: [3, -2, 9, 5, -1, 6]</span></span><br><span class="line">     <span class="comment">//[6, -1, 5, 9, -2, 3]</span></span><br><span class="line">     <span class="comment">//[-2, -1, 3, 5, 6, 9]</span></span><br><span class="line">     <span class="comment">//[-2, -1, 9, 5, 6, 3]</span></span><br><span class="line">     <span class="comment">//[6, 3, -2, -1, 9, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、查找、替换操作</span><br><span class="line">【方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="number">1</span>） <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">list, T key)</span></span></span><br><span class="line"><span class="function">使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引。</span></span><br><span class="line"><span class="function">注意：此前必须保证List集合中的元素已经处于有序状态。</span></span><br><span class="line"><span class="function">2）<span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function">根据元素的自然顺序，返回给定collection 的最大元素。</span></span><br><span class="line"><span class="function">3）<span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function">根据指定比较器产生的顺序，返回给定 collection 的最大元素。</span></span><br><span class="line"><span class="function">4）<span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll)</span>:</span></span><br><span class="line"><span class="function">根据元素的自然顺序，返回给定collection 的最小元素。</span></span><br><span class="line"><span class="function">5）<span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function">根据指定比较器产生的顺序，返回给定 collection 的最小元素。</span></span><br><span class="line"><span class="function">6） <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">fill</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list, T obj)</span> :</span></span><br><span class="line"><span class="function">使用指定元素替换指定列表中的所有元素。</span></span><br><span class="line"><span class="function">7）<span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span></span></span><br><span class="line"><span class="function">返回指定 collection 中等于指定对象的出现次数。</span></span><br><span class="line"><span class="function">8）<span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span> :</span></span><br><span class="line"><span class="function">返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回</span></span><br><span class="line"><span class="function">-1。</span></span><br><span class="line"><span class="function">9）<span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span></span></span><br><span class="line"><span class="function">返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回</span></span><br><span class="line"><span class="function">-1。</span></span><br><span class="line"><span class="function">10）<span class="keyword">static</span> &lt;T&gt; <span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List&lt;T&gt; list, T oldVal, T newVal)</span></span></span><br><span class="line"><span class="function">使用一个新值替换List对象的所有旧值oldVal</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">【演示：实例使用查找、替换操作】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.ArrayList</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(-<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(-<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//[3, -2, 9, 5, -1, 6]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//输出最大元素9</span></span><br><span class="line">        System.out.println(Collections.max(list));</span><br><span class="line"><span class="comment">//输出最小元素：-2</span></span><br><span class="line">        System.out.println(Collections.min(list));</span><br><span class="line"><span class="comment">//将list中的-2用1来代替</span></span><br><span class="line">        System.out.println(Collections.replaceAll(list, -<span class="number">2</span>, <span class="number">1</span>));<span class="comment">//操作成功返回的是true</span></span><br><span class="line"><span class="comment">//[3, 1, 9, 5, -1, 6]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//判断9在集合中出现的位数，返回2</span></span><br><span class="line">        System.out.println(Collections.frequency(list, <span class="number">9</span>));</span><br><span class="line"><span class="comment">//对集合进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"><span class="comment">//[-1, 1, 3, 5, 6, 9, 9]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有排序后的List集合才可用二分法查询，输出2</span></span><br><span class="line">        System.out.println(Collections.binarySearch(list, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果为: [3, -2, 9, 5, -1, 6]</span></span><br><span class="line">     <span class="comment">//9</span></span><br><span class="line">     <span class="comment">//-2</span></span><br><span class="line">     <span class="comment">//true</span></span><br><span class="line">     <span class="comment">//[3, 1, 9, 5, -1, 6]</span></span><br><span class="line">     <span class="comment">//2</span></span><br><span class="line">     <span class="comment">//[-1, 1, 3, 5, 6, 9, 9]</span></span><br><span class="line">     <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、同步控制</span><br><span class="line">Collectons提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从</span><br><span class="line">而解决多线程并发访问集合时的线程安全问题。</span><br><span class="line">正如前面介绍的HashSet，TreeSet，arrayList,LinkedList,HashMap,TreeMap都是线程不安全的。</span><br><span class="line">Collections提供了多个静态方法可以把他们包装成线程同步的集合。</span><br><span class="line"></span><br><span class="line">【方法】</span><br><span class="line">代码示例:</span><br><span class="line"><span class="number">1</span>）<span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function">返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line"><span class="function">2）<span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function">返回指定列表支持的同步（线程安全的）列表。</span></span><br><span class="line"><span class="function">3）<span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span></span><br><span class="line"><span class="function">返回由指定映射支持的同步（线程安全的）映射。</span></span><br><span class="line"><span class="function">4）<span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br><span class="line"><span class="function">返回指定 set 支持的同步（线程安全的）set。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">【实例】</span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.*</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//下面程序创建了四个同步的集合对象</span></span><br><span class="line">Collection c = Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList());</span><br><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、Collesction设置不可变集合</span><br><span class="line">【方法】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="number">1</span>）emptyXxx()</span><br><span class="line">返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是</span><br><span class="line">Map。</span><br><span class="line"><span class="number">2</span>）singletonXxx():</span><br><span class="line">返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：</span><br><span class="line">List，Set，Map。</span><br><span class="line"><span class="number">3</span>）unmodifiableXxx():</span><br><span class="line">返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。</span><br><span class="line"></span><br><span class="line">上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。</span><br><span class="line">【实例】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnmodifiable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个空的、不可改变的List对象</span></span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.emptyList();</span><br><span class="line"><span class="comment">//unmodifiableList.add(&quot;java&quot;);</span></span><br><span class="line"><span class="comment">//添加出现异常：java.lang.UnsupportedOperationException</span></span><br><span class="line">System.out.println(unmodifiableList);<span class="comment">// []</span></span><br><span class="line"><span class="comment">//创建一个只有一个元素，且不可改变的Set对象</span></span><br><span class="line">Set unmodifiableSet = Collections.singleton(<span class="string">&quot;Struts2权威指南&quot;</span>);</span><br><span class="line"><span class="comment">//[Struts2权威指南]</span></span><br><span class="line">System.out.println(unmodifiableSet);</span><br><span class="line"><span class="comment">//创建一个普通Map对象</span></span><br><span class="line">Map scores = <span class="keyword">new</span> HashMap();</span><br><span class="line">scores.put(<span class="string">&quot;语文&quot;</span> , <span class="number">80</span>);</span><br><span class="line">scores.put(<span class="string">&quot;Java&quot;</span> , <span class="number">82</span>);</span><br><span class="line"><span class="comment">//返回普通Map对象对应的不可变版本</span></span><br><span class="line">Map unmodifiableMap = Collections.unmodifiableMap(scores);</span><br><span class="line"><span class="comment">//下面任意一行代码都将引发UnsupportedOperationException异常</span></span><br><span class="line">unmodifiableList.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">unmodifiableSet.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">unmodifiableMap.put(<span class="string">&quot;语文&quot;</span>,<span class="number">90</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结和测试</span><br><span class="line">【JavaBean】</span><br><span class="line">实体类：Pojo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; <span class="comment">//Javabean, Enter实体类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line"><span class="keyword">private</span> String department;</span><br><span class="line"><span class="keyword">private</span> Date hireDate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> salary, String department,</span></span></span><br><span class="line"><span class="function"><span class="params">String hireDate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line"><span class="keyword">this</span>.department = department;</span><br><span class="line">DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.hireDate = format.parse(hireDate);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> department;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(String department)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.department = department;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getHireDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hireDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDate</span><span class="params">(Date hireDate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.hireDate = hireDate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【测试类代码如下】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//一个对象对应了一行记录！</span></span><br><span class="line">Employee e = <span class="keyword">new</span> Employee(<span class="number">0301</span>,<span class="string">&quot;狂神&quot;</span>,<span class="number">3000</span>,<span class="string">&quot;项目部&quot;</span>,<span class="string">&quot;2017-10&quot;</span>);</span><br><span class="line">Employee e2 = <span class="keyword">new</span> Employee(<span class="number">0302</span>,<span class="string">&quot;小明&quot;</span>,<span class="number">3500</span>,<span class="string">&quot;教学部&quot;</span>,<span class="string">&quot;2016-10&quot;</span>);</span><br><span class="line">Employee e3 = <span class="keyword">new</span> Employee(<span class="number">0303</span>,<span class="string">&quot;小红&quot;</span>,<span class="number">3550</span>,<span class="string">&quot;教学部&quot;</span>,<span class="string">&quot;2016-10&quot;</span>);</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">list.add(e);</span><br><span class="line">list.add(e2);</span><br><span class="line">list.add(e3);</span><br><span class="line">printEmpName(list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEmpName</span><span class="params">(List&lt;Employee&gt; list)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">System.out.println(list.get(i).getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[思考:]数据结构-集合-算法连在一起(具体可以在算法那边补充完整),计算机组成原理硬件这块也是弱势,也可以单独拿出来写.</span><br></pre></td></tr></table></figure>

<h3 id="三、IO"><a href="#三、IO" class="headerlink" title="三、IO"></a>三、IO</h3><p><img src="https://i.loli.net/2020/09/23/zRgln6EBaupk7qO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、JAVA流式输入/输出原理</span><br><span class="line"></span><br><span class="line">在Java程序中，对于数据的输入/输出操作以“流”（Stream）方式进行；J2SDK提供了各种各样的“流”</span><br><span class="line">类，用以获取不同种类的数据：程序中通过标准的方法输入或输出数据。</span><br><span class="line">读入写出</span><br><span class="line">流是用来读写数据的，java有一个类叫File，它封装的是文件的文件名，只是内存里面的一个对象，真</span><br><span class="line">正的文件是在硬盘上的一块空间，在这个文件里面存放着各种各样的数据，我们想读文件里面的数据怎</span><br><span class="line">么办呢？是通过一个流的方式来读，咱们要想从程序读数据，对于计算机来说，无论读什么类型的数据</span><br><span class="line">都是以<span class="number">010101101010</span>这样的形式读取的。怎么把文件里面的数据读出来呢？你可以把文件想象成一个</span><br><span class="line">小桶，文件就是一个桶，文件里面的数据就相当于是这个桶里面的水，那么我们怎么从这个桶里面取水</span><br><span class="line">呢，也就是怎么从这个文件读取数据呢。</span><br><span class="line">常见的取水的办法是我们用一根管道插到桶上面，然后在管道的另一边打开水龙头，桶里面的水就开始</span><br><span class="line">哗啦哗啦地从水龙头里流出来了，桶里面的水是通过这根管道流出来的，因此这根管道就叫流，JAVA里</span><br><span class="line">面的流式输入/输出跟水流的原理一模一样，当你要从文件读取数据的时候，一根管道插到文件里面去，</span><br><span class="line">然后文件里面的数据就顺着管道流出来，这时你在管道的另一头就可以读取到从文件流出来的各种各样</span><br><span class="line">的数据了。当你要往文件写入数据时，也是通过一根管道，让要写入的数据通过这根管道哗啦哗啦地流</span><br><span class="line">进文件里面去。除了从文件去取数据以外，还可以通过网络，比如用一根管道把我和你的机子连接起</span><br><span class="line">来，我说一句话，通过这个管道流进你的机子里面，你马上就可以看得到，而你说一句话，通过这根管</span><br><span class="line">道流到我的机子里面，我也马上就可以看到。有的时候，一根管道不够用，比方说这根管道流过来的水</span><br><span class="line">有一些杂质，我们就可以在这个根管道的外面再包一层管道，把杂质给过滤掉。从程序的角度来讲，从</span><br><span class="line">计算机读取到的原始数据肯定都是<span class="number">010101</span>这种形式的，一个字节一个字节地往外读，当你这样读的时候</span><br><span class="line">你觉得这样的方法不合适，没关系，你再在这根管道的外面再包一层比较强大的管道，这个管道可以把</span><br><span class="line"><span class="number">010101</span>帮你转换成字符串。这样你使用程序读取数据时读到的就不再是<span class="number">010101</span>这种形式的数据了，而</span><br><span class="line">是一些可以看得懂的字符串了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、输入输出流分类</span><br><span class="line">Java.io 包中定义了多个流类型（类或抽象类）来实现输入/输出功能；可以从不同的角度对其进行分</span><br><span class="line">类：</span><br><span class="line">按数据流的方向不同可以分为输入流和输出流</span><br><span class="line">按照处理数据单位不同可以分为字节流和字符流</span><br><span class="line">按照功能不同可以分为节点流和处理流</span><br><span class="line">    </span><br><span class="line">我们来理解两个概念：</span><br><span class="line">字节流：最原始的一个流，读出来的数据就是<span class="number">010101</span>这种最底层的数据表示形式，只不过它是按</span><br><span class="line">照字节来读的，一个字节（Byte）是<span class="number">8</span>位（bit）读的时候不是一个位一个位的来读，而是一个字节</span><br><span class="line">一个字节来读。</span><br><span class="line">字符流：字符流是一个字符一个字符地往外读取数据。一个字符是<span class="number">2</span>个字节</span><br><span class="line">J2SDK所提供的所有流类型位于包 Java.io内，都分别继承自以下四种抽象流类型。</span><br><span class="line">输入流：InputStream（字节流），Reader（字符流）</span><br><span class="line">输出流：OutPutStream（字节流），Writer（字符流）</span><br><span class="line">这四个类都是抽象类，可以把这四个类想象成四根不同的管道。一端接着你的程序，另一端接着数据</span><br><span class="line">源，你可以通过输出管道从数据源里面往外读数据，也可以通过输入管道往数据源里面输入数据，总</span><br><span class="line">之，通过这四根管道可以让数据流进来和流出去。</span><br><span class="line">io包里面定义了所有的流，所以一说流指的就是io包里面的</span><br><span class="line">什么叫输入流？什么叫输出流？</span><br><span class="line">用一根管道一端插进文件里，一端插进程序里面，然后开始读数据，那么这是输入还是输出呢？</span><br><span class="line">如果站在文件的角度上，这叫输出。</span><br><span class="line">如果站在程序的角度上，这叫输入。</span><br><span class="line">    </span><br><span class="line">记住，以后说输入流和输出流都是站在<span class="string">&quot;程序&quot;</span>的角度上来说。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">三、节点流和处理流</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/rdPDIkzaeNiZHEw.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你要是对原始的流不满意，你可以在这根管道外面再套其它的管道，套在其它管道之上的流叫处理流。</span><br><span class="line">为什么需要处理流呢？这就跟水流里面有杂质，你要过滤它，你可以再套一层管道过滤这些杂质一样。</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span>.节点流类型</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/3GHzorFeqAibwmC.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">节点流就是一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数</span><br><span class="line">据。典型的节点流是文件流：文件的字节输入流（FileInputStream），文件的字节输出流</span><br><span class="line">（FileOutputStream），文件的字符输入流（FileReader），文件的字符输出流（FileWriter）。</span><br><span class="line"></span><br><span class="line"><span class="number">3.2</span>.处理流类型</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/LJ2obyHFktCf6Qi.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">处理流是包在别的流上面的流，相当于是包到别的管道上面的管道。</span><br><span class="line"></span><br><span class="line">四、InputStream(输入流)</span><br><span class="line">我们看到的具体的某一些管道，凡是以InputStream结尾的管道，都是以字节的形式向我们的程序输入</span><br><span class="line">数据。</span><br><span class="line">继承自InputStream的流都是用于向程序中输入数据，且数据的单位为字节（<span class="number">8</span>bit）；下图中深色为节点</span><br><span class="line">流，浅色为处理流。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/yp9qwBgx2oZ1sUr.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4.1</span>.InputStream的基本方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前已到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取length个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从length位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer,<span class="keyword">int</span> offset,<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span>方法是一个字节一个字节地往外读，每读取一个字节，就处理一个字节。<span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span>方法</span></span><br><span class="line"><span class="function">读取数据时，先把读取到的数据填满这个<span class="keyword">byte</span>[]类型的数组<span class="title">buffer</span><span class="params">(buffer是内存里面的一块缓冲区)</span>，然</span></span><br><span class="line"><span class="function">后再处理数组里面的数据。这就跟我们取水一样，先用一个桶去接，等桶接满水后再处理桶里面的水。</span></span><br><span class="line"><span class="function">如果是每读取一个字节就处理一个字节，这样子读取也太累了。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4.2 案例</span></span><br><span class="line"><span class="function">以<span class="title">File</span><span class="params">(文件)</span>这个类型作为讲解节点流的典型代表</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">【源码查看，分析结构】</span></span><br><span class="line"><span class="function">【演示：使用FileInputStream流来读取FileInputStream.java文件的内容】</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.io.*</span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;<span class="comment">// 使用变量b来装调用read()方法时返回的整数</span></span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 使用FileInputStream流来读取有中文的内容时，读出来的是乱码，因为使用</span></span><br><span class="line">        <span class="comment">//InputStream流里面的read()方法读取内容时是一个字节一个字节地读取的，而一个汉字是占用两个</span></span><br><span class="line">        <span class="comment">//字节的，所以读取出来的汉字无法正确显示。</span></span><br><span class="line"><span class="comment">// FileReader in = null;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用FileReader流来读取内容时，中英文都可以正确显示，因为Reader流里面的</span></span><br><span class="line">        <span class="comment">//read()方法是一个字符一个字符地读取的，这样每次读取出来的都是一个完整的汉字，这样就可以正确显示了。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\test.java&quot;</span>);</span><br><span class="line"><span class="comment">// in = new FileReader(&quot;E:\教学\班级\Test\Lesson2\src\com\kuang\chapter\Student.java&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;系统找不到指定文件！&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);<span class="comment">// 系统非正常退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;<span class="comment">// 使用变量num来记录读取到的字符数</span></span><br><span class="line"><span class="comment">// 调用read()方法时会抛异常，所以需要捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 调用int read() throws Exception方法时，返回的是一个int类型的整数</span></span><br><span class="line"><span class="comment">// 循环结束的条件就是返回一个值-1，表示此时已经读取到文件的末尾了。</span></span><br><span class="line"><span class="comment">// System.out.print(b+&quot;\t&quot;);//如果没有使用“(char)b”进行转换，那么直接打印出来的b就是数字，而不是英文和中文了</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line"><span class="comment">// “char(b)”把使用数字表示的汉字和英文字母转换成字符输入</span></span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();<span class="comment">// 关闭输入流</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;总共读取了&quot;</span> + num + <span class="string">&quot;个字节的文件&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件读取错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果为: package javaStudy.javaé«çº§å­¦ä¹ .ioæµ;</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">//public class test &#123;</span></span><br><span class="line">     <span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line">     <span class="comment">//        System.out.println(&quot;hello world&quot;);</span></span><br><span class="line">     <span class="comment">//    &#125;</span></span><br><span class="line">     <span class="comment">//&#125;</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">//总共读取了166个字节的文件</span></span><br><span class="line">&#125;</span><br><span class="line">[思考:]字节流字符流,中文是字符两个字节,所以会乱码,一个字节<span class="number">8</span>bit</span><br><span class="line"></span><br><span class="line">五、OutputStream(输出流)</span><br><span class="line"></span><br><span class="line">继承自OutputStream的流是用于程序中输出数据，且数据的单位为字节（<span class="number">8</span>bit）：下图中深色的为节点</span><br><span class="line">流，浅色为处理流</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/VKrCqE6bPpeHX2w.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5.1</span>.OutputStream的基本方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置（off）开始的len个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5.2 案例</span></span><br><span class="line"><span class="function">【使用FileOutputStream流往一个文件里面写入数据】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.io.*</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\test.java&quot;</span>);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\testnew.java&quot;</span>);</span><br><span class="line"><span class="comment">// 指明要写入数据的文件，如果指定的路径中不存在StudentNew.java这样的文件，则系统会自动创建一个</span></span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(b);</span><br><span class="line"><span class="comment">// 调用write(int c)方法把读取到的字符全部写入到指定文件中去</span></span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);<span class="comment">// 非正常退出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件复制失败！&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.StudentNew.java里面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileInputStream和FileOutputStream这两个流都是字节流，都是以一个字节为单位进行输入和输出</span><br><span class="line">的。所以对于占用<span class="number">2</span>个字节存储空间的字符来说读取出来时就会显示成乱码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">六、Reader流</span><br><span class="line"></span><br><span class="line">Reader ： 和InputStream一模一样，唯一的区别就在于读的数据单位不同</span><br><span class="line">继承自Reader的流都是用于向程序中输入数据，且数据的单位为字符（<span class="number">16</span>bit）</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/6As85IzN4gpjdY9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>位：一个字符也就是两个字节，使用Reader流读取数据时都是两个字节两个字节往外读的，为什么还</span><br><span class="line">要有这两种两个字节的读取方式呢? 因为有些字符是占<span class="number">2</span>个字节的，如我们的中文字符在Java里面就是占</span><br><span class="line">两个字节的。如果采用一个字节一个字节往外读的方式，那么读出来的就是半个汉字，这样子Java就没</span><br><span class="line">有办法正确的显示中文字符的，所以有必要存在这种流，一个字符一个字符地往外读。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.1</span>.Reader的基本方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前已到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取length个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从length位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer,<span class="keyword">int</span> offset,<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">七、Writer流</span></span><br><span class="line"><span class="function">继承自Writer的流都是用于程序中输出数据，且数据的单位为字符（16bit）；</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/47arAPjEi1KWVBd.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7.1</span>.Writer的基本方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置（off）开始的len个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7.2 演示</span></span><br><span class="line"><span class="function">【演示：使用FileWriter（字符流）向指定文件中写入数据】</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="comment">/*使用FileWriter（字符流）向指定文件中写入数据写入数据时以1个字符为单位进行写入*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.io.*</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFileWriter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">/*使用FileWriter输出流从程序把数据写入到Uicode.dat文件中</span></span><br><span class="line"><span class="comment">使用FileWriter流向文件写入数据时是一个字符一个字符写入的*/</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\testnew.java&quot;</span>);</span><br><span class="line"><span class="comment">//字符的本质是一个无符号的16位整数</span></span><br><span class="line"><span class="comment">//字符在计算机内部占用2个字节</span></span><br><span class="line"><span class="comment">//这里使用for循环把0～60000里面的所有整数都输出(修改为60)</span></span><br><span class="line"><span class="comment">//这里相当于是把全世界各个国家的文字都0～60000内的整数的形式来表示</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=<span class="number">60000</span>;c++)&#123;</span><br><span class="line">                fw.write(c);</span><br><span class="line"><span class="comment">//使用write(int c)把0～60000内的整数写入到指定文件内</span></span><br><span class="line"><span class="comment">//调用write()方法时，我认为在执行的过程中应该使用了“(char)c”进行强制转换，即把整数转换成字符来显示</span></span><br><span class="line"><span class="comment">//因为打开写入数据的文件可以看到，里面显示的数据并不是0～60000内的整数，而是不同国家的文字的表示方式</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">/*使用FileReader(字符流)读取指定文件里面的内容</span></span><br><span class="line"><span class="comment">读取内容时是以一个字符为单位进行读取的*/</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\testnew.java&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>((b = fr.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)b + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;总共读取了&quot;</span>+num+<span class="string">&quot;个字符&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileReader和FileWriter这两个流都是字符流，都是以一个字符为单位进行输入和输出的。所以读取和写</span><br><span class="line">入占用<span class="number">2</span>个字节的字符时都可以正常地显示出来，以上是以File(文件)这个类型为例对节点流进行了讲</span><br><span class="line">解，所谓的节点流指定就是直接把输入流或输出插入到数据源上，直接往数据源里面写入数据或读取数</span><br><span class="line">据。</span><br><span class="line"></span><br><span class="line">八、处理流讲解</span><br><span class="line"></span><br><span class="line"><span class="number">8.1</span>.第一种处理流——缓冲流(Buffering)</span><br><span class="line">缓冲流要”套接“在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加</span><br><span class="line">了一些新的方法。J2SDK提供了四种缓冲流，常用构造方法如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in,<span class="keyword">int</span> sz) <span class="comment">//sz 为自定义缓冲区的大小</span></span><br><span class="line">BufferedWriter(Writer out)</span><br><span class="line">BufferedWriter(Writer out,<span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputStream(InputStream in)</span><br><span class="line">BufferedInputStream(InputStream in,<span class="keyword">int</span> size)</span><br><span class="line">BufferedOutputStream(InputStream in)</span><br><span class="line">BufferedOutputStream(InputStream in,<span class="keyword">int</span> size)</span><br><span class="line"></span><br><span class="line">缓冲输入流支持其父类的mark和reset方法。</span><br><span class="line">BufferedReader提供了readLine方法用于读取一行字符串</span><br><span class="line">BufferedWriter提供了newLine用于写入一个行分隔符</span><br><span class="line">对于输出的缓冲流，写出的数据会现在内存中缓存，使用flush方法将会使内存中的数据立刻写出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带有缓冲区的，缓冲区(Buffer)就是内存里面的一小块区域，读写数据时都是先把数据放到这块缓冲区</span><br><span class="line">域里面，减少io对硬盘的访问次数，保护我们的硬盘。可以把缓冲区想象成一个小桶，把要读写的数据</span><br><span class="line">想象成水，每次读取数据或者是写入数据之前，都是先把数据装到这个桶里面，装满了以后再做处理。</span><br><span class="line">这就是所谓的缓冲。先把数据放置到缓冲区上，等到缓冲区满了以后，再一次把缓冲区里面的数据写入</span><br><span class="line">到硬盘上或者读取出来，这样可以有效地减少对硬盘的访问次数，有利于保护我们的硬盘。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【缓冲流测试代码：BufferedInputStream】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\test.java&quot;</span>);</span><br><span class="line"><span class="comment">// 在FileInputStream节点流的外面套接一层处理流BufferedInputStream</span></span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">            bis.mark(<span class="number">100</span>);<span class="comment">// 在第100个字符处做一个标记</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            bis.reset();<span class="comment">// 重新回到原来标记的地方</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【演示：BufferedReader】</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\test.txt&quot;</span>));</span><br><span class="line"><span class="comment">//在节点流FileWriter的外面再套一层处理流BufferedWriter</span></span><br><span class="line">            String s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                s = String.valueOf(Math.random());<span class="comment">//“Math.random()”将会生成一系列介于0～1之间的随机数。</span></span><br><span class="line"><span class="comment">// static String valueOf(double d)这个valueOf()方法的作用就是把一个double类型的数转换成字符串</span></span><br><span class="line"><span class="comment">//valueOf()是一个静态方法，所以可以使用“类型.静态方法名”的形式来调用</span></span><br><span class="line">                bw.write(s);<span class="comment">//把随机数字符串写入到指定文件中</span></span><br><span class="line">                bw.newLine();<span class="comment">//调用newLine()方法使得每写入一个随机数就换行显示</span></span><br><span class="line">            &#125;</span><br><span class="line">            bw.flush();<span class="comment">//调用flush()方法清空缓冲区</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\test.txt&quot;</span>));</span><br><span class="line"><span class="comment">//在节点流FileReader的外面再套一层处理流BufferedReader</span></span><br><span class="line">            <span class="keyword">while</span>((s = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//使用BufferedReader处理流里面提供String readLine()方法读取文件中的数据时是一行一行读取的</span></span><br><span class="line"><span class="comment">//循环结束的条件就是使用readLine()方法读取数据返回的字符串为空值后则表示已经读取到文件的末尾了。</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            bw.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/lSFakxE4eXyNrAO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序的输入指的是把从文件读取到的内容存储到为程序分配的内存区域里面去。流，什么是流，流无非</span><br><span class="line">就是两根管道，一根向里，一根向外，向里向外都是对于我们自己写的程序来说，流分为各种各样的类</span><br><span class="line">型，不同的分类方式又可以分为不同的类型，根据方向来分，分为输入流和输出流，根据读取数据的单</span><br><span class="line">位的不同，又可以分为字符流和字节流，除此之外，还可以分为节点流和处理流，节点流就是直接和数</span><br><span class="line">据源连接的流，处理流就是包在其它流上面的流，处理流不是直接和数据源连接，而是从数据源读取到</span><br><span class="line">数据以后再通过处理流处理一遍。缓冲流也包含了四个类：BufferedInputStream、</span><br><span class="line">BufferedOutputStream、BufferedReader和BufferedWriter。流都是成对的，没有流是是不成对的，</span><br><span class="line">肯定是一个in，一个out。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.2</span>.第二种处理流——转换流</span><br><span class="line">InputStreamReader 和 OutputStreamWriter 用于字节数据到字符数据之间的转换</span><br><span class="line">InputStreamReader 需要和 InputStream “套接” 。</span><br><span class="line">OutputStreamWriter 需要和 OutputStream “套接” 。</span><br><span class="line"></span><br><span class="line">转换流在构造时可以指定其编码集合</span><br><span class="line">InputStream isr = <span class="keyword">new</span> InputStreamReader（System.in，<span class="string">&quot;ISO8859-1&quot;</span>）</span><br><span class="line"></span><br><span class="line">转换流非常的有用，它可以把一个字节流转换成一个字符流，转换流有两种，一种叫</span><br><span class="line">InputStreamReader，另一种叫OutputStreamWriter。InputStream是字节流，Reader是字符流，</span><br><span class="line">InputStreamReader就是把InputStream转换成Reader。OutputStream是字节流，Writer是字符流，</span><br><span class="line">OutputStreamWriter就是把OutputStream转换成Writer。把OutputStream转换成Writer之后就可以</span><br><span class="line">一个字符一个字符地通过管道写入数据了，而且还可以写入字符串。我们如果用一个FileOutputStream</span><br><span class="line">流往文件里面写东西，得要一个字节一个字节地写进去，但是如果我们在FileOutputStream流上面套上</span><br><span class="line">一个字符转换流，那我们就可以一个字符串一个字符串地写进去。</span><br><span class="line"></span><br><span class="line">【转换流测试代码】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTransform1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\char.txt&quot;</span>));</span><br><span class="line">            osw.write(<span class="string">&quot;MircosoftsunIBMOracleApplet&quot;</span>);<span class="comment">// 把字符串写入到指定的文件中去</span></span><br><span class="line">            System.out.println(osw.getEncoding());<span class="comment">// 使用getEncoding()方法取得当前系统的默认字符编码</span></span><br><span class="line">            osw.close();</span><br><span class="line">            osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                    <span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\char.txt&quot;</span>, <span class="keyword">true</span>), <span class="string">&quot;ISO8859_1&quot;</span>);</span><br><span class="line"><span class="comment">// 如果在调用FileOutputStream的构造方法时没有加入true，那么新加入的字符串就会替换掉原来写入的字符串，在调用构造方法时指定了字符的编码</span></span><br><span class="line">            osw.write(<span class="string">&quot;MircosoftsunIBMOracleApplet&quot;</span>);<span class="comment">// 再次向指定的文件写入字符串，新写入的字符串加入到原来字符串的后面</span></span><br><span class="line">            System.out.println(osw.getEncoding());</span><br><span class="line">            osw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/ezYjcEdiG2SJsXo.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTransform2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="comment">//System.in这里的in是一个标准的输入流，用来接收从键盘输入的数据</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String s = <span class="keyword">null</span>;</span><br><span class="line">            s = br.readLine();<span class="comment">//使用readLine()方法把读取到的一行字符串保存到字符串变量s中去</span></span><br><span class="line">            <span class="keyword">while</span>(s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s.toUpperCase());<span class="comment">//把保存在内存s中的字符串打印出来</span></span><br><span class="line">                        s = br.readLine();<span class="comment">//在循环体内继续接收从键盘的输入</span></span><br><span class="line">                <span class="keyword">if</span>(s.equalsIgnoreCase(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line"><span class="comment">//只要输入exit循环就结束，就会退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//案例测试:  哈哈哈hh123</span></span><br><span class="line">    <span class="comment">//哈哈哈HH123</span></span><br><span class="line">    <span class="comment">//exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/6Tfxi1VWNCpKQtZ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8.3</span>.第三种处理流——数据流</span><br><span class="line">DataInputStream 和 DataOutputStream 分别继承自InputStream 和 OutputStream ， 它属于处</span><br><span class="line">理流，需要分别“套接”在InputStream 和 OutputStream类型的节点流上。</span><br><span class="line">DataInputStream 和 DataOutputStream 提供了可以存取与机器无关的Java原始类型数据（<span class="keyword">int</span>，<span class="keyword">double</span>等）的方法。</span><br><span class="line"></span><br><span class="line">DataInputStream 和 DataOutputStream 的构造方法</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">DataInputStream （InputStream in）</span><br><span class="line">DataOutputStream （OutputStream out）</span><br><span class="line"></span><br><span class="line">【数据流测试代码】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDataStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">//在调用构造方法时，首先会在内存里面创建一个ByteArray字节数组</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line"><span class="comment">//在输出流的外面套上一层数据流，用来处理int，double类型的数</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dos.writeDouble(Math.random());<span class="comment">//把产生的随机数直接写入到字节数组ByteArray中</span></span><br><span class="line">            dos.writeBoolean(<span class="keyword">true</span>);<span class="comment">//布尔类型的数据在内存中就只占一个字节</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            System.out.println(bais.available());</span><br><span class="line">            DataInputStream dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">            System.out.println(dis.readDouble());<span class="comment">//先写进去的就先读出来，调用readDouble()方法读取出写入的随机数</span></span><br><span class="line">            System.out.println(dis.readBoolean());<span class="comment">//后写进去的就后读出来，这里面的读取顺序不能更改位置，否则会打印出不正确的结果</span></span><br><span class="line">            dos.close();</span><br><span class="line">            bais.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试结果为:9</span></span><br><span class="line">    <span class="comment">//0.9618256651190431</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过bais这个流往外读取数据的时候，是一个字节一个字节地往外读取的，因此读出来的数据无法判断</span><br><span class="line">是字符串还是bool类型的值，因此要在它的外面再套一个流，通过dataInputStream把读出来的数据转</span><br><span class="line">换就可以判断了。注意了：读取数据的时候是先写进去的就先读出来，因此读ByteArray字节数组数据的</span><br><span class="line">顺序应该是先把占<span class="number">8</span>个字节的<span class="keyword">double</span>类型的数读出来，然后再读那个只占一个字节的<span class="keyword">boolean</span>类型的</span><br><span class="line">数，因为<span class="keyword">double</span>类型的数是先写进数组里面的，读的时候也要先读它。这就是所谓的先写的要先读。如</span><br><span class="line">果先读Boolean类型的那个数，那么读出来的情况可能就是把<span class="keyword">double</span>类型数的<span class="number">8</span>个字节里面的一个字节</span><br><span class="line">读了出来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.4</span>.打印流——Print</span><br><span class="line"></span><br><span class="line">PrintWriter 和 PrintStream 都属于输出流，分别针对与字符和字节</span><br><span class="line">PrintWriter 和 PrintStream 提供了重载的print</span><br><span class="line">Println方法用于多种数据类型的输出</span><br><span class="line">PrintWriter和PrintStream的输出操作不会抛出异常，用户通过检测错误状态获取错误信息</span><br><span class="line">PrintWriter 和 PrintStream有自动flush功能</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">PrintWriter（Writer out）</span><br><span class="line">PrintWriter（Writer out，<span class="keyword">boolean</span> autoFlush）</span><br><span class="line">PrintWriter（OutputStream out）</span><br><span class="line">PrintWriter（OutputStream out，<span class="keyword">boolean</span> autoFlush）</span><br><span class="line">PrintStream（OutputStream out）</span><br><span class="line">PrintStream（OutputStream out，<span class="keyword">boolean</span> autoFlush）</span><br><span class="line"></span><br><span class="line">【测试代码】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">/*这个小程序是重新设置打印输出的窗口，</span></span><br><span class="line"><span class="comment">* 把默认在命令行窗口输出打印内容设置成其他指定的打印显示窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPrintStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\log.txt&quot;</span>);</span><br><span class="line">                    ps = <span class="keyword">new</span> PrintStream(fos);<span class="comment">//在输出流的外面套接一层打印流，用来控制打印输出</span></span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.setOut(ps);<span class="comment">//这里调用setOut()方法改变了输出窗口，以前写</span></span><br><span class="line"><span class="comment">//System.out.print()默认的输出窗口就是命令行窗口</span></span><br><span class="line"><span class="comment">//但现在使用System.setOut(ps)将打印输出窗口改成了由ps指定的文件里</span></span><br><span class="line"><span class="comment">//面，通过这样设置以后，打印输出时都会在指定的文件内打印输出</span></span><br><span class="line"><span class="comment">//在这里将打印输出窗口设置到了log.txt这个文件里面，所以打印出来的内容会在log.txt这个文件里面看到</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="number">0</span>;c&lt;=<span class="number">1000</span>;c++)&#123;</span><br><span class="line">                System.out.print(c+<span class="string">&quot;\t&quot;</span>);<span class="comment">//把世界各国的文字打印到log.txt这个文件中去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/6ducQbTneAHNZOj.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8.5</span>. 对象流——Object</span><br><span class="line">直接将Object 写入或读出</span><br><span class="line"><span class="keyword">transient</span>关键字</span><br><span class="line"><span class="keyword">transient</span>：透明的，用它来修饰的成员变量在序列化的时候不予考虑，也就是当成不存在。</span><br><span class="line">serializable接口</span><br><span class="line">externaliazble接口</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObjectIo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        t.k = <span class="number">8</span>;<span class="comment">// 把k的值修改为8</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\TestObjectIo.txt&quot;</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"><span class="comment">// ObjectOutputStream流专门用来处理Object的，在fos流的外面套接bjectOutputStream流就可以直接把一个Object写进去</span></span><br><span class="line">            oos.writeObject(t);<span class="comment">// 直接把一个t对象写入到指定的文件里面</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Xosin\\IdeaProjects\\javaStudy\\src\\javaStudy\\java高级学习\\io流\\TestObjectIo.txt&quot;</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"><span class="comment">// ObjectInputStream专门用来读一个Object的</span></span><br><span class="line">            T tRead = (T) ois.readObject();</span><br><span class="line"><span class="comment">// 直接把文件里面的内容全部读取出来然后分解成一个Object对象，并使用强制转换成指定类型T</span></span><br><span class="line">            System.out.print(tRead.i + <span class="string">&quot;\t&quot;</span> + tRead.j + <span class="string">&quot;\t&quot;</span> + tRead.d +</span><br><span class="line">                    <span class="string">&quot;\t&quot;</span></span><br><span class="line">                    + tRead.k);</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 凡是要将一个类的对象序列化成一个字节流就必须实现Serializable接口</span></span><br><span class="line"><span class="comment">* Serializable接口中没有定义方法，Serializable接口是一个标记性接口，用来给类作标记，</span></span><br><span class="line"><span class="comment">只是起到一个标记作用。</span></span><br><span class="line"><span class="comment">* 这个标记是给编译器看的，编译器看到这个标记之后就可以知道这个类可以被序列化 如果想把某个</span></span><br><span class="line"><span class="comment">类的对象序列化，就必须得实现Serializable接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Serializable的意思是可以被序列化的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">2.3</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">15</span>;</span><br><span class="line"><span class="comment">// transient int k = 15;</span></span><br><span class="line"><span class="comment">// 在声明变量时如果加上transient关键字，那么这个变量就会被当作是透明的，即不存在。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接实现Serializable接口的类是JDK自动把这个类的对象序列化，而如果实现<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span></span></span><br><span class="line"><span class="class"><span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span>的类则可以自己控制对象的序列化，建议能让<span class="title">JDK</span>自己控制序列化的就不要让自己去控制</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">九、<span class="title">IO</span>流总结</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/8xbuGEshDUfaypQ.png"></p>
<h3 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">process进程   thread线程</span><br><span class="line">简介:</span><br><span class="line"></span><br><span class="line">在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。可以通过多种途径达到这个目的。最开始的时候，那些掌握机器低级语言的程序员编写一些“中断服务例程”，主进程的暂停是通过硬件级的中断实现的。尽管这是一种有用的方法，但编出的程序很难移植，由此造成了另一类的代价高昂问题。中断对那些实时性很强的任务来说是很有必要的。但对于其他许多问题，只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求.</span><br><span class="line">最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源！如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说（比如打印机），它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开（释放）这个锁，使其他线程可以接着使用同样的资源 .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line">实现多线程是采用一种并发执行机制 </span><br><span class="line">并发执行机制原理：简单地说就是把一个处理器划分为若干个短的时间片，每个时间片依次轮流地执行处理各个应用程序，由于一个时间片很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果 </span><br><span class="line">多线程就是把操作系统中的这种并发执行机制原理运用在一个程序中，把一个程序划分为若干个子任务，多个子任务并发执行，每一个任务就是一个线程。这就是多线程程序 </span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line"><span class="number">1</span>、使用线程可以把占据时间长的程序中的任务放到后台去处理 </span><br><span class="line"><span class="number">2</span>、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度 </span><br><span class="line"><span class="number">3</span>、程序的运行速度可能加快 </span><br><span class="line"><span class="number">4</span>、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等</span><br><span class="line"><span class="number">5</span>、多线程技术在IOS软件开发中也有举足轻重的作用 </span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line"><span class="number">1</span>、如果有大量的线程，会影响性能，因为操作系统需要在它们之间切换 </span><br><span class="line"><span class="number">2</span>、更多的线程需要更多的内存空间 </span><br><span class="line"><span class="number">3</span>、线程可能会给程序带来更多“bug”，因此要小心使用 </span><br><span class="line"><span class="number">4</span>、线程的中止需要考虑其对程序运行的影响 </span><br><span class="line"><span class="number">5</span>、通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生</span><br><span class="line"></span><br><span class="line">核心概念:</span><br><span class="line">线程就是独立的执行路径；</span><br><span class="line">在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程(垃圾回收)；</span><br><span class="line">main() 称之为主线程，为系统的入口，用于执行整个程序；</span><br><span class="line">在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。</span><br><span class="line">对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</span><br><span class="line">线程会带来额外的开销，如cpu调度时间，并发控制开销。</span><br><span class="line">每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三种创建方式:</span><br><span class="line"></span><br><span class="line">方式一: 继承thread <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//线程创建方式一 ：</span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class">第一步：继承<span class="title">Thread</span>类</span></span><br><span class="line"><span class="class">第二步：重写<span class="title">run</span>（）方法</span></span><br><span class="line"><span class="class">第三步：创建继承了<span class="title">Thread</span>类的对象 ， 调用<span class="title">start</span>（）方法启动。</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//线程开启不一样立即执行由<span class="title">cpu</span>调度执行</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义run方法的线程(重写)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程执行体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人在写笔记--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//start（） 方法用来 启动线程；</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人在在睡觉sleep--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu调度不一样,因为没有设置优先级所以每次执行的结果不一样(两个线程交替进行)</span><br><span class="line"></span><br><span class="line">多线程案例:同步下载图片,需要导入一个写好的url转为文件的jar包</span><br><span class="line">    </span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下载图片</span></span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();<span class="comment">//下载器</span></span><br><span class="line">        webDownloader.downloader(url,name);<span class="comment">//下载文件的方式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下载了图片--&gt;&quot;</span>+name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 t1 = <span class="keyword">new</span> TestThread2(<span class="string">&quot;https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1593106255,4245861836&amp;fm=26&amp;gp=0.jpg&quot;</span>,<span class="string">&quot;老虎.jpg&quot;</span>);</span><br><span class="line">        TestThread2 t2 = <span class="keyword">new</span> TestThread2(<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600947781999&amp;di=6989dc121c1dfa3705a10f6a49ea3531&amp;imgtype=0&amp;src=http%3A%2F%2Fa1.att.hudong.com%2F05%2F00%2F01300000194285122188000535877.jpg&quot;</span>,<span class="string">&quot;猫咪.jpg&quot;</span>);</span><br><span class="line">        TestThread2 t3 = <span class="keyword">new</span> TestThread2(<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600947781998&amp;di=552a8ae3f3f9452915bbfed848d00f3b&amp;imgtype=0&amp;src=http%3A%2F%2Fa0.att.hudong.com%2F18%2F56%2F14300000958002128488569856508.jpg&quot;</span>,<span class="string">&quot;狗.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了t1&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了t2&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了t3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载图片  下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//输出异常信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;downloader方法出现异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主要过程:</span><br><span class="line"></span><br><span class="line">自定义线程类继承Thread类</span><br><span class="line">重写run()方法，编写线程执行体</span><br><span class="line">创建线程对象，调用start()方法启动线程</span><br><span class="line"></span><br><span class="line">方式二: 实现Runnable</span><br><span class="line"></span><br><span class="line">主要过程:</span><br><span class="line"></span><br><span class="line">定义MyRunnable类实现Runnable接口</span><br><span class="line">实现run()方法，编写线程执行体</span><br><span class="line">创建线程对象，调用start()方法启动线程</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//创建线程方式2：实现runnable接口</span></span><br><span class="line"><span class="comment">//1.实现接口</span></span><br><span class="line"><span class="comment">//2.重写run方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建runbale接口实现类的对象。</span></span><br><span class="line"><span class="comment">//启动线程。需要创建一个线程Thread对象 ， 然后把runbale接口实现类的对象丢到构造参数里 ， 调用start方式启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程执行体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人在写笔记--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重点就是将runbale接口实现类的对象丢入Thread构造器</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程对象,通过线程对象来开启我们的代理(静态代理)</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面两行代码可以简写为:</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).run();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人在在睡觉sleep--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">两者的对比:</span><br><span class="line"></span><br><span class="line"> 继承Thread类</span><br><span class="line"> 子类继承Thread类具备多线程能力</span><br><span class="line"> 启动线程：子类对象. start()</span><br><span class="line"> 不建议使用：避免OOP单继承局限性</span><br><span class="line"></span><br><span class="line"> 实现Runnable接口</span><br><span class="line"> 实现接口Runnable具有多线程能力</span><br><span class="line"> 启动线程：传入目标对象+Thread对象.start()</span><br><span class="line"> 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">初识并发问题,多个线程同时操作一个对象,数据共享混乱</span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//初识并发问题：多个线程同时操作一个对象（runnable接口实现类）</span></span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行体</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟网络延时，睡眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取线程名字</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;抢到了第&quot;</span>+ticketNums--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 t = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个参数，创建线程名字</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t,<span class="string">&quot;黄牛党&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多线程经典案例:龟兔赛跑</span><br><span class="line"></span><br><span class="line">代码示例:    </span><br><span class="line"><span class="comment">//模拟龟兔赛跑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//winner:只有一个胜利者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//赛道</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= <span class="number">101</span>; step++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//兔子休眠</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; step % <span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断比赛是否结束</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = gameOver(step);</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;跑了&quot;</span>+ step +<span class="string">&quot;步&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断比赛是否结束</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (winner!=<span class="keyword">null</span>)&#123; <span class="comment">//如果存在胜利者</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step&gt;=<span class="number">100</span>)&#123;  <span class="comment">//如果跑到了比赛结束</span></span><br><span class="line">            winner = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;比赛结束&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;胜利者-----&gt;&quot;</span>+winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程创建方式三:实现Callable接口</span><br><span class="line"></span><br><span class="line">主要过程:</span><br><span class="line"><span class="number">1.</span> 实现Callable接口，需要返回值类型</span><br><span class="line"><span class="number">2.</span> 重写call方法，需要抛出异常</span><br><span class="line"><span class="number">3.</span> 创建目标对象</span><br><span class="line"><span class="number">4.</span> 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="number">5.</span> 提交执行：Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br><span class="line"><span class="number">6.</span> 获取结果：<span class="keyword">boolean</span> r1 = result1.get()</span><br><span class="line"><span class="number">7.</span> 关闭服务：ser.shutdownNow();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用这种方式实现多线程下载图片</span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//用Callable改造多线程下载图片</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">好处:1.可以定义返回值</span></span><br><span class="line"><span class="comment">    2.可以抛出异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JUC并发编程</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//下载图片</span></span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();<span class="comment">//下载器</span></span><br><span class="line">        webDownloader.downloader(url,name);<span class="comment">//下载文件的方式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下载了图片--&gt;&quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1593106255,4245861836&amp;fm=26&amp;gp=0.jpg&quot;</span>,<span class="string">&quot;你好1.jpg&quot;</span>);</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600947781999&amp;di=6989dc121c1dfa3705a10f6a49ea3531&amp;imgtype=0&amp;src=http%3A%2F%2Fa1.att.hudong.com%2F05%2F00%2F01300000194285122188000535877.jpg&quot;</span>,<span class="string">&quot;你好2.jpg&quot;</span>);</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600947781998&amp;di=552a8ae3f3f9452915bbfed848d00f3b&amp;imgtype=0&amp;src=http%3A%2F%2Fa0.att.hudong.com%2F18%2F56%2F14300000958002128488569856508.jpg&quot;</span>,<span class="string">&quot;你好3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建执行服务：</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交执行：</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> r1 = result1.get();</span><br><span class="line">        <span class="keyword">boolean</span> r2 = result2.get();</span><br><span class="line">        <span class="keyword">boolean</span> r3 = result3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断线程是否顺利结束或者有异常</span></span><br><span class="line"></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(r3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载图片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//输出异常信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;downloader方法出现异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态代理</span><br><span class="line">  </span><br><span class="line">总结  </span><br><span class="line"><span class="comment">//真实对象和代理对象都要实现同一个接口</span></span><br><span class="line"><span class="comment">//代理对象要代理真实角色</span></span><br><span class="line"><span class="comment">//好处是  代理对象可以做很多真实对象做不了的事情</span></span><br><span class="line"><span class="comment">//真实对象专注自己的事情</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lamda表达式(简化的匿名内部类)</span><br><span class="line"></span><br><span class="line">λ 希腊字母表中排序第十一位的字母，英语名称为Lambda</span><br><span class="line">避免匿名内部类定义过多</span><br><span class="line">其实质属于函数式编程的概念</span><br><span class="line"></span><br><span class="line">好处:</span><br><span class="line">为什么要使用lambda表达式</span><br><span class="line">避免匿名内部类定义过多</span><br><span class="line">可以让你的代码看起来很简洁</span><br><span class="line">去掉了一堆没有意义的代码，只留下核心的逻辑</span><br><span class="line"></span><br><span class="line">理解Functional Interface（函数式接口）是学习Java8 lambda表达式的关键所在。</span><br><span class="line">函数式接口的定义：</span><br><span class="line">任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好呀lambda！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test02 test02 = <span class="keyword">new</span> Test02();</span><br><span class="line">        <span class="keyword">new</span> Thread(test02).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你好呀lambda2！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Test03 test03 = <span class="keyword">new</span> Test03();</span><br><span class="line">        <span class="keyword">new</span> Thread(test03).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类, 需要有一个借口或者父类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你好呀lambda3！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda  jdk.8新增方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好呀lambda4！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带参数的函数式接口lambda表达式</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//lambda表达式传递参数</span></span><br><span class="line"><span class="comment">//隐式前提</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个参数的情况下,可以简化参数类型 , 必须加上括号 .</span></span><br><span class="line"><span class="comment">// 只有一行代码的情况下 , 可以省略大括号</span></span><br><span class="line"><span class="comment">// 必须是函数式接口</span></span><br><span class="line"></span><br><span class="line">[理解:]只有一行代码的时候,用lambda可以简化为一行代码,如果实现里面有多行,那就需要用代码块包裹起来</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILove love = <span class="keyword">new</span> Love();</span><br><span class="line">        love.lambda(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        love = <span class="keyword">new</span> ILove() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我开始喜欢lambda了....&quot;</span>+a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        love.lambda(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        love = (<span class="keyword">int</span> a)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我开始喜欢lambda了....&quot;</span>+a);</span><br><span class="line">        &#125;;</span><br><span class="line">        love.lambda(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化1: 去掉括号</span></span><br><span class="line">        love = a-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我开始喜欢lambda了....&quot;</span>+a);</span><br><span class="line">        &#125;;</span><br><span class="line">        love.lambda(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化2:去掉花括号</span></span><br><span class="line">        love = a-&gt;System.out.println(<span class="string">&quot;我开始喜欢lambda了....&quot;</span>+a);</span><br><span class="line"></span><br><span class="line">        love.lambda(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILove</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span> <span class="keyword">implements</span> <span class="title">ILove</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开始喜欢lambda了....&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lambda在多线程的应用</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//lambda表达式在多线程中的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原先方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你好二&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程体只有一行可以省略到极致</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;你好二&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程体有多行 , 用一个代码块包裹起来就好.</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你好二&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程状态</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/25/Z7N6JVRngesft3w.png"></p>
<p><img src="https://i.loli.net/2020/09/25/WBGvJyUtdAV3OqS.png"></p>
<p><img src="https://i.loli.net/2020/09/25/fb2J9Zxu7nVLopz.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程停止</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//线程正常停止,利用次数不建议使用死循环</span></span><br><span class="line"><span class="comment">//建议使用标志位停止,设置一个标志位</span></span><br><span class="line"><span class="comment">//建议不适用stop或者是destroy等过时或者jdk不推荐的办法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程正在运行..&quot;</span>+i++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">//调用stop方法标志位停止线程</span></span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程该停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程休眠:</span><br><span class="line"></span><br><span class="line">sleep (时间) 指定当前线程阻塞的毫秒数；</span><br><span class="line">sleep存在异常InterruptedException；</span><br><span class="line">sleep时间达到后线程进入就绪状态；</span><br><span class="line">sleep可以模拟网络延时，倒计时等。</span><br><span class="line">每一个对象都有一个锁，sleep不会释放锁；</span><br><span class="line"></span><br><span class="line">获取系统当前时间(实现倒计时)</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        TestSleep2 testSleep2 = <span class="keyword">new</span> TestSleep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统时间</span></span><br><span class="line">        Date startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(startTime));</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒计时方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;倒计时:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程礼让:</span><br><span class="line"></span><br><span class="line">礼让线程，让当前正在执行的线程暂停，但不阻塞</span><br><span class="line">将线程从运行状态转为就绪状态</span><br><span class="line">让cpu重新调度，礼让不一定成功！看CPU心情</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//线程的礼让</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;启动了&quot;</span>);</span><br><span class="line">        Thread.yield();<span class="comment">//礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;停止了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程强制执行:</span><br><span class="line"></span><br><span class="line">Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</span><br><span class="line">可以想象成插队</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//线程强制执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">80</span>)&#123;</span><br><span class="line">                <span class="comment">//强制执行</span></span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是主线程:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是要插队的线程:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">观测线程状态</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/25/UBDrPZulG1hbXK5.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新生--就绪--运行--阻塞--死亡</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//观测线程的状态</span></span><br><span class="line"><span class="comment">//停止之后就不能再次启动,死亡后的线程不能再重新启动,线程只能启动一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;////////////&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//观察状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//NEW</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观察启动后</span></span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//RUN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED)&#123;<span class="comment">//只要线程不终止,就一直输出状态</span></span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState();<span class="comment">//更新线程状态</span></span><br><span class="line">            System.out.println(state);<span class="comment">//输出线程状态</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程优先级</span><br><span class="line"></span><br><span class="line">优先级是权重,代表概率大</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/25/8cJb2oUEXjMWTm1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="comment">//测试线程优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread thread4 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread thread5 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.setPriority(<span class="number">1</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread2.setPriority(<span class="number">4</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread3.setPriority(<span class="number">8</span>);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        thread4.setPriority(<span class="number">9</span>);</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        thread5.setPriority(<span class="number">10</span>);</span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">性能倒置:优先级低的先启动.</span><br><span class="line">[思考:]main先执行</span><br><span class="line"></span><br><span class="line">守护线程</span><br><span class="line"></span><br><span class="line">线程分为用户线程和守护线程</span><br><span class="line">虚拟机必须确保用户线程执行完毕</span><br><span class="line">虚拟机不用等待守护线程执行完毕</span><br><span class="line">如,后台记录操作日志,监控内存,垃圾回收等待(gc垃圾回收)...</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//测试守护线程</span></span><br><span class="line"><span class="comment">//用户线程: 虚拟机要等待用户线程执行完毕</span></span><br><span class="line"><span class="comment">//守护线程: 虚拟机 不用等待 守护线程 执行完毕</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">//设置线程为守护线程,默认为false是用户线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你开心的在这个世界上活着&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======Goodbye , World!&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//守护线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;<span class="keyword">true</span>;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑着你&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程同步</span><br><span class="line"></span><br><span class="line">并发 : 同一个对象被多个线程同时操作</span><br><span class="line"></span><br><span class="line">现实生活中,我们会遇到”同一个资源,多个人都想使用”的问题,比如,食堂排队</span><br><span class="line">打饭,每个人都想吃饭,最天然的解决办法就是,排队.一个个来.</span><br><span class="line"></span><br><span class="line">处理多线程问题时,多个线程访问同一个对象,并且某些线程还想修改这个对象.这时候我们就需要线程同步.线程同步其实就是一种等待机制,多个需要同时访问</span><br><span class="line">此对象的线程进入这个<span class="string">&quot;对象的等待池&quot;</span>形成队列,等待前面线程使用完毕 , 下一个线</span><br><span class="line">程再使用</span><br><span class="line"></span><br><span class="line">队列和锁</span><br><span class="line">要保证队列安全就要有锁,让下个队列能正常排队,每个线程都有一把锁,保证安全</span><br><span class="line">由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问</span><br><span class="line">冲突问题(线程不安全),为了保证数据在方法中被访问时的正确性,在访问时加入锁机制</span><br><span class="line"><span class="keyword">synchronized</span>,当一个线程获得对象的排它锁,独占资源,其他线程必须等待,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用后释放锁即可.存在以下问题:</span><br><span class="line">一个线程持有锁会导致其他所有需要此锁的线程挂起;(队列过长)</span><br><span class="line">在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题;</span><br><span class="line">如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒</span><br><span class="line">置,引起性能问题 .</span><br><span class="line"></span><br><span class="line">arraylist集合不安全示例</span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程不安全问题3,集合操作(arraylist线程不安全示例)</span></span><br><span class="line"><span class="comment">//同一时间把两个元素添加到同一个内存里面,那么集合里面就少了</span></span><br><span class="line"><span class="comment">//思考?怎么让这些问题变安全.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnSafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;倒计时&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">安全的arraylist  juc安全类型的集合</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="comment">//测试juc安全类型的集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeJUCList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//保证线程安全的list , ArrayList</span></span><br><span class="line">        CopyOnWriteArrayList list = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;倒计时&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程不安全示例:买票问题</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//线程同步问题一 :线程不安全,买票问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            buyTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟网络延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeBuyTicket station = <span class="keyword">new</span> UnsafeBuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;苦逼的我&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;牛逼的你们&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;可恶的黄牛党&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同步方法:(默认锁的是<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">由于我们可以通过 <span class="keyword">private</span>关键字来保证数据对象只能被方法访问,所以我们只需</span><br><span class="line">要针对方法提出一套机制,这套机制就是<span class="keyword">synchronized</span> 关键字,它包括两种用法:</span><br><span class="line"><span class="keyword">synchronized</span>方法和<span class="keyword">synchronized</span>块.</span><br><span class="line"></span><br><span class="line">同步方法 : <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> args)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">synchronized</span>方法控制对 “对象” 的访问,每个对象对应一把锁,每个</span><br><span class="line"><span class="keyword">synchronized</span>方法都必须获得调用该方法的对象的锁才能执行,否则线程会阻塞 ,</span><br><span class="line">方法一旦执行,就独占该锁,直到该方法返回才释放锁,后面被阻塞的线程才能获</span><br><span class="line">得这个锁,继续执行</span><br><span class="line"></span><br><span class="line">缺陷 : 若将一个大的方法申明为<span class="keyword">synchronized</span> 将会影响效率</span><br><span class="line"></span><br><span class="line">同步方法的弊端:</span><br><span class="line"></span><br><span class="line">方法里面需要修改的内容才需要锁,锁的太多浪费资源 </span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//线程同步问题一 :线程不安全,买票问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            buyTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引入锁机制,锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟网络延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeBuyTicket station = <span class="keyword">new</span> UnsafeBuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;苦逼的我&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;牛逼的你们&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station,<span class="string">&quot;可恶的黄牛党&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步块:(锁的对象是变化的量,影响线程安全的量)</span><br><span class="line"></span><br><span class="line">同步块 : <span class="keyword">synchronized</span> (Obj ) &#123; &#125;</span><br><span class="line">Obj 称之为 同步监视器</span><br><span class="line">Obj 可以是任何对象 , 但是推荐使用共享资源作为同步监视器</span><br><span class="line">同步方法中无需指定同步监视器 , 因为同步方法的同步监视器就是<span class="keyword">this</span>,就是</span><br><span class="line">这个对象本身,或者是class[反射中讲解]</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//银行(存钱:存了多少,取钱:去了多少) , 两个人 , 账户</span></span><br><span class="line"><span class="comment">//并发问题,线程不安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>,<span class="string">&quot;招商卡&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Bank you = <span class="keyword">new</span> Bank(<span class="string">&quot;痛苦的你&quot;</span>,account,<span class="number">50</span>);</span><br><span class="line">        Bank wife = <span class="keyword">new</span> Bank(<span class="string">&quot;开心的媳妇&quot;</span>,account,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        wife.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;<span class="comment">//余额</span></span><br><span class="line">    String name; <span class="comment">//卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//银行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//存钱:存了多少,取钱:取了多少</span></span><br><span class="line"></span><br><span class="line">    Account account;  <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">int</span> drawingMoney; <span class="comment">//取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney; <span class="comment">//手里有多少钱</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(String name,Account account,<span class="keyword">int</span> drawingMoney)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的是一个代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">            <span class="comment">//判断能否取钱</span></span><br><span class="line">            <span class="keyword">if</span> (account.money-drawingMoney&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了放大问题发生性,我们加个延时.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//余额 = 余额 - 你去走的钱</span></span><br><span class="line">            account.money = account.money - drawingMoney;</span><br><span class="line">            <span class="comment">//你的钱 = 你的钱 + 你取的钱</span></span><br><span class="line">            nowMoney = drawingMoney + nowMoney;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.account.name+<span class="string">&quot;账户余额:&quot;</span>+account.money);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;手里的钱:&quot;</span>+nowMoney);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同步监视器的执行过程</span><br><span class="line"><span class="number">1.</span>第一个线程访问,锁定同步监视器,执行其中代码. </span><br><span class="line"><span class="number">2.</span>第二个线程访问,发现同步监视器被锁定,无法访问. </span><br><span class="line"><span class="number">3.</span>第一个线程访问完毕,解锁同步监视器. </span><br><span class="line"><span class="number">4.</span>第二个线程访问,发现同步监视器没有锁,然后锁定并访问</span><br><span class="line"></span><br><span class="line">死锁:</span><br><span class="line"></span><br><span class="line">多个线程各自占有一些共享资源,并且互相等待其他线程占有的资源才能运行,而</span><br><span class="line">导致两个或者多个线程都在等待对方释放资源,都停止执行的情形.某一个同步块</span><br><span class="line">同时拥有“两个以上对象的锁”时,就可能会发生“死锁”的问题.(两个小孩抢同一个玩具)</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//死锁问题</span></span><br><span class="line"><span class="comment">//两个线程抱着自己的锁 , 然后想要对方的锁 .</span></span><br><span class="line"><span class="comment">// 于是产生一个问题 ---&gt; 死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLocked</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup g1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>,<span class="string">&quot;白雪公主&quot;</span>);</span><br><span class="line">        Makeup g2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>,<span class="string">&quot;灰姑凉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(g1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(g2).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//化妆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    <span class="comment">//谁进来了</span></span><br><span class="line">    String girlName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个对象</span></span><br><span class="line">    <span class="keyword">static</span> LipStick lipStick = <span class="keyword">new</span> LipStick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Makeup</span><span class="params">(<span class="keyword">int</span> choice,String girlName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//化妆</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//化妆的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice==<span class="number">0</span>)&#123; <span class="comment">//先拿口红,再拿镜子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lipStick)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;拿到口红&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//等待拿镜子的人释放锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;拿到镜子&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//先拿镜子 , 再拿口红</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;拿到镜子&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//等待拿口红的人释放锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lipStick)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;拿到口红&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//口红</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LipStick</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//镜子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">死锁避免方法:</span><br><span class="line"></span><br><span class="line">产生死锁的四个必要条件：</span><br><span class="line"><span class="number">1.</span> 互斥条件：一个资源每次只能被一个进程使用。</span><br><span class="line"><span class="number">2.</span> 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class="line"><span class="number">3.</span> 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class="line"><span class="number">4.</span> 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line"></span><br><span class="line">上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件</span><br><span class="line">就可以避免死锁发生</span><br><span class="line"></span><br><span class="line">lock(锁)</span><br><span class="line"></span><br><span class="line">从JDK <span class="number">5.0</span>开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对</span><br><span class="line">象来实现同步。同步锁使用Lock对象来充当</span><br><span class="line">    </span><br><span class="line">java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</span><br><span class="line">锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开</span><br><span class="line">始访问共享资源之前应先获得Lock对象</span><br><span class="line">    </span><br><span class="line">ReentrantLock(可重入锁) 类实现了 Lock ，它拥有与 <span class="keyword">synchronized</span> 相同的并发性和内存语</span><br><span class="line">义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释</span><br><span class="line">放锁。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(helloWorld).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(helloWorld).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">                <span class="comment">//判断是否有票</span></span><br><span class="line">                <span class="keyword">if</span> (ticketNums&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketNums--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//保证线程安全的代码;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line"><span class="comment">//如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 与 Lock 的区别:</span><br><span class="line"></span><br><span class="line">Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）<span class="keyword">synchronized</span>是隐式锁，出了</span><br><span class="line">作用域自动释放</span><br><span class="line">Lock只有代码块锁，<span class="keyword">synchronized</span>有代码块锁和方法锁</span><br><span class="line">使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展</span><br><span class="line">性（提供更多的子类）</span><br><span class="line">优先使用顺序：</span><br><span class="line">Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方</span><br><span class="line">法体之外）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程协作(生产者消费模式)</span><br><span class="line">[思考:涉及到并发记得上锁<span class="keyword">synchronized</span></span><br><span class="line"></span><br><span class="line">线程通信:</span><br><span class="line">应用场景 : 生产者和消费者问题</span><br><span class="line">假设仓库中只能存放一件产品,生产者将生产出来的产品放入仓库,消费者将仓库中产品取走消费 . </span><br><span class="line">如果仓库中没有产品,则生产者将产品放入仓库,否则停止生产并等待,直到仓库中的产品被消费者取走为止 .</span><br><span class="line">如果仓库中放有产品,则消费者可以将产品取走消费,否则停止消费并等待,直到仓库中再次放入产品为止 .</span><br><span class="line"></span><br><span class="line">生产者-----&gt;数据缓冲区----&gt;消费者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是一个线程同步问题,生产者和消费者共享同一个资源,并且生产者和消费者之间相互依赖,互为条件 . </span><br><span class="line"></span><br><span class="line">对于生产者,没有生产产品之前,要通知消费者等待.而生产了产品之后,又需要马上通知消费者消费</span><br><span class="line"></span><br><span class="line">对于消费者,在消费之后,要通知生产者已经结束消费,需要生产新的产品以供消费. </span><br><span class="line"></span><br><span class="line">在生产者消费者问题中,仅有<span class="keyword">synchronized</span>是不够的</span><br><span class="line"><span class="keyword">synchronized</span> 可阻止并发更新同一个共享资源 , 实现了同步</span><br><span class="line"><span class="keyword">synchronized</span> 不能用来实现不同线程之间的消息传递 (通信)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/25/hK1gZfPrsyJzdxV.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">解决方式<span class="number">1</span>:</span><br><span class="line">并发协作模型 “ 生产者 / 消费者模式 ” ---&gt;管程法</span><br><span class="line"></span><br><span class="line">生产者 : 负责生产数据的模块 (可能是方法 , 对象 , 线程 , 进程) ;</span><br><span class="line">消费者 : 负责处理数据的模块 (可能是方法 , 对象 , 线程 , 进程) ;</span><br><span class="line">缓冲区 : 消费者不能直接使用生产者的数据 , 他们之间有个 “ 缓冲区</span><br><span class="line">生产者将生产好的数据放入缓冲区 , 消费者从缓冲区拿出数据</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.思考需要哪些对象?</span></span><br><span class="line"><span class="comment">// 生产 , 消费 , 产品 , 容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.分工</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者只管生产</span></span><br><span class="line"><span class="comment">    消费者只管消费</span></span><br><span class="line"><span class="comment">    鸡: 实体类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    容器 :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    容器添加数据.</span></span><br><span class="line"><span class="comment">    要判断容器是否满 , 满了等待消费者消费</span></span><br><span class="line"><span class="comment">    没有满,通知生产者生产</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    容器减少数据</span></span><br><span class="line"><span class="comment">    判断还有没有数据, 没有数据的话 . 等待生产者生产</span></span><br><span class="line"><span class="comment">    消费完毕 , 通知生产者生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试生产者和消费者问题</span></span><br><span class="line"><span class="comment">//管程法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer synContainer = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Productor(synContainer).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(synContainer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要向容器中加入产品</span></span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//生产者添加产品</span></span><br><span class="line">            container.push(<span class="keyword">new</span> Chicken(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了&quot;</span>+i+<span class="string">&quot;鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//消费者拿走产品</span></span><br><span class="line">            Chicken chicken = container.pop();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了&quot;</span>+chicken.id+<span class="string">&quot;鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区--&gt;容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容器</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容器的计数器</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假如容易已经满了,就不用放,等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (num&gt;=chickens.length)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待消费者消费</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如容器没有满 , 通知生产生成</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;num,,,,,&quot;</span>+num);</span><br><span class="line">        chickens[num] = chicken;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组有多少个元素&quot;</span>+num);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//通知消费者消费</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者拿走产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//假如容器空的,等待</span></span><br><span class="line">        <span class="keyword">if</span> (num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        Chicken chicken = chickens[num];</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品-&gt;鸡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解决方式<span class="number">2</span>(信号灯法):</span><br><span class="line"></span><br><span class="line">并发协作模型 “ 生产者 / 消费者模式 ” </span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//生产者消费2</span></span><br><span class="line"><span class="comment">//生产者---&gt;演员</span></span><br><span class="line"><span class="comment">//消费者---&gt;观众</span></span><br><span class="line"><span class="comment">//产品:信号灯---&gt;电视-----&gt;声音</span></span><br><span class="line"><span class="comment">//信号灯发法,标志位解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">&quot;节目:快乐大本营播放中&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">&quot;广告:抖音,记录美好生活&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="comment">//演员说话 , 观众等待</span></span><br><span class="line">    <span class="comment">//观众观看 , 演员等待</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说话</span></span><br><span class="line">    String voice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演员等待</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;表演了&quot;</span>+voice);</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观众等待</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;观众听到了: &quot;</span>+voice);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知演员说话</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用线程池:</span><br><span class="line"></span><br><span class="line">背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影</span><br><span class="line">响很大。</span><br><span class="line">思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。</span><br><span class="line">可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</span><br><span class="line"></span><br><span class="line">好处：</span><br><span class="line">提高响应速度（减少了创建新线程的时间）</span><br><span class="line">降低资源消耗（重复利用线程池中线程，不需要每次都创建）</span><br><span class="line">便于线程管理(....)</span><br><span class="line">corePoolSize：核心池的大小</span><br><span class="line">maximumPoolSize：最大线程数</span><br><span class="line">keepAliveTime：线程没有任务时最多保持多长时间后会终止</span><br><span class="line"></span><br><span class="line">使用线程池:</span><br><span class="line"></span><br><span class="line">JDK <span class="number">5.0</span>起提供了线程池相关API：ExecutorService 和 Executors</span><br><span class="line">ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> ：执行任务/命令，没有返回值，一般用来执</span></span><br><span class="line"><span class="function">行Runnable</span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span>：执行任务，有返回值，一般又来执行</span></span><br><span class="line"><span class="function">Callable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> ：关闭连接池</span></span><br><span class="line"><span class="function">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.concurrent.ExecutorService</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程池(池子大小)</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行runnable接口实现类</span></span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyThread4());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyThread4());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyThread4());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyThread4());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、网络编程"><a href="#五、网络编程" class="headerlink" title="五、网络编程"></a>五、网络编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、网络编程概述</span><br><span class="line"><span class="number">1.1</span>、概述</span><br><span class="line">Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的</span><br><span class="line">网络应用程序。Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机</span><br><span class="line">安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络</span><br><span class="line">编程环境。</span><br><span class="line"></span><br><span class="line">计算机网络：</span><br><span class="line">把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大，功能强的网络系统，</span><br><span class="line">从而使众多的计算机可以方便地互相传递信息，共享硬件，软件，数据信息等资源。</span><br><span class="line"></span><br><span class="line">网络编程的目的：</span><br><span class="line">直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯。</span><br><span class="line"></span><br><span class="line">网络编程中有两个主要的问题：</span><br><span class="line"><span class="number">1.</span> 如何准确的定位网络上的一台或多台主机，定位主机上的特定的应用</span><br><span class="line"><span class="number">2.</span> 找到主机后如何可靠高效地进行数据传输</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>、网络通信两个要素</span><br><span class="line">如何实现网络中的主机互相通信？</span><br><span class="line"></span><br><span class="line">通信双方的地址 ：</span><br><span class="line">IP</span><br><span class="line">端口号</span><br><span class="line">【比如说我们这里上课使用的就是局域网，你们连接到我的电脑，就能查看到我电脑的画面了】</span><br><span class="line">一定的规则：（即，网络通信协议，有两套参考模型）</span><br><span class="line">OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广！</span><br><span class="line">TCP/IP 参考模型：TCP/IP协议，事实上的国际标准。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/ax9w13EGQJtbPiU.png"></p>
<p><img src="https://i.loli.net/2020/09/26/Z4SDQvzC9KJ1eV3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小总结：</span><br><span class="line"><span class="number">1.</span> 网络编程中有两个主要的问题：</span><br><span class="line">如何准确的定位网络上一台或多台主机；定位主机上的特定的应用</span><br><span class="line">找到主机后如何可靠高效的进行数据传输</span><br><span class="line"><span class="number">2.</span> 网络编程中的两个要素：</span><br><span class="line">ip 和 端口号</span><br><span class="line">网路通信协议:udp,tcp</span><br><span class="line">提供网络通信协议。 TCP/IP参考模型（应用层，传输层，网络层，物理+数据链路层）</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span>、Inet Adderss</span><br><span class="line">ip地址：Inet Adderss</span><br><span class="line">唯一的标识 internet 上的计算机 ( 通信实体 )</span><br><span class="line">本地回环地址（hostAddress）：<span class="number">127.0</span>.<span class="number">0.1</span>(本机) 主机名 ( hostName )：localhost</span><br><span class="line"></span><br><span class="line">IP地址分类方式一 ： IPV4 IPV6</span><br><span class="line">IPV4(<span class="number">127.0</span>.<span class="number">0.1</span>)：<span class="number">4</span>个字节组成，<span class="number">4</span>个<span class="number">0</span>~<span class="number">255</span>。大概<span class="number">42</span>亿个， <span class="number">30</span>亿都在北美，亚洲<span class="number">4</span>亿。<span class="number">2011</span>年初已经用</span><br><span class="line">尽。以点分十进制表示，如<span class="number">192.168</span>.<span class="number">0.1</span></span><br><span class="line">IPV6：<span class="number">128</span>位（<span class="number">16</span>个字节），写成<span class="number">8</span>个无符号整数，每个整数用四个十六进制位表示，数之间</span><br><span class="line">用冒号 隔开，如：<span class="number">2001</span>:<span class="number">0d</span>b8:<span class="number">3</span>c4d:<span class="number">0015</span>:<span class="number">0000</span>:<span class="number">0000</span>:<span class="number">1</span>a2f:<span class="number">1</span>a2b</span><br><span class="line"></span><br><span class="line">IP地址分类方式<span class="number">2</span>：公网地址（万维网使用） 和 私有地址（局域网使用）。</span><br><span class="line"><span class="number">192.168</span>.开头的就是私有地址，范围即为 <span class="number">192.168</span>.<span class="number">0.0</span> ~ <span class="number">192.168</span>.<span class="number">255.255</span>，专门为组织机构</span><br><span class="line">内部使用</span><br><span class="line">【查看 JDK 帮助文档=&gt; InetAddress类，代表IP】</span><br><span class="line"></span><br><span class="line">特点：不便于记忆，我们常使用域名来访问：www.baidu.com</span><br><span class="line">https:<span class="comment">//blog.kuangstudy.com/ =&gt; DNS 域名解析（150.109.117.44）=&gt; 现在本机的hosts文件，</span></span><br><span class="line">判断是否有输入的域名地址，没有的话，再通过DNS服务器，找主机。</span><br><span class="line">hosts文件地址： c：\windows\system32\drivers\etc\hosts</span><br><span class="line"></span><br><span class="line">获取ip地址</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="comment">//IP 这个东西，怎么用Java对象表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InetAddressTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获得IP地址</span></span><br><span class="line">            InetAddress inetAddresses1 =</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;192.168.8.123&quot;</span>);</span><br><span class="line">            System.out.println(inetAddresses1);</span><br><span class="line">            InetAddress inetAddresses2 =</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inetAddresses2);</span><br><span class="line"><span class="comment">//获取本地IP</span></span><br><span class="line">            InetAddress inetAddresses3 = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inetAddresses3);</span><br><span class="line">            InetAddress inetAddresses4 = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(inetAddresses4);</span><br><span class="line">            InetAddress inetAddresses5 = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inetAddresses5);</span><br><span class="line"><span class="comment">//getHostName</span></span><br><span class="line">            System.out.println(inetAddresses2.getHostName());</span><br><span class="line"><span class="comment">//getHostAddress</span></span><br><span class="line">            System.out.println(inetAddresses2.getHostAddress());</span><br><span class="line"><span class="comment">//Canonical : 规范的</span></span><br><span class="line">            System.out.println(inetAddresses2.getCanonicalHostName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果为:  /192.168.8.123</span></span><br><span class="line">    <span class="comment">//www.baidu.com/180.101.49.11</span></span><br><span class="line">    <span class="comment">///127.0.0.1</span></span><br><span class="line">    <span class="comment">//localhost/127.0.0.1</span></span><br><span class="line">    <span class="comment">//DESKTOP-QMF7Q7A/192.168.137.1</span></span><br><span class="line">    <span class="comment">//www.baidu.com</span></span><br><span class="line">    <span class="comment">//180.101.49.11</span></span><br><span class="line">    <span class="comment">//180.101.49.11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span>、端口号</span><br><span class="line">端口号标识正在计算机上运行的进程（程序）</span><br><span class="line">不同的进程有不同的端口号，用来区分软件</span><br><span class="line">被规定为一个<span class="number">16</span>位的整数 <span class="number">0</span>~<span class="number">65535</span></span><br><span class="line">TCP 和 UDP 各有 <span class="number">65535</span>个端口，单个协议下端口不能冲突</span><br><span class="line"></span><br><span class="line">端口分类：</span><br><span class="line">公认端口： <span class="number">0</span>~<span class="number">1023</span>。被预先定义的服务通信占用端口。</span><br><span class="line">HTTP 默认端口 ： <span class="number">80</span></span><br><span class="line">HTTPS 默认端口：<span class="number">443</span></span><br><span class="line">FTP 默认端口： <span class="number">21</span></span><br><span class="line">Telnet 默认端口：<span class="number">23</span></span><br><span class="line">注册端口：<span class="number">1024</span>~<span class="number">49151</span>、分配给用户进程或应用程序。</span><br><span class="line">tomcat 默认端口：<span class="number">8080</span></span><br><span class="line">Mysql 默认端口：<span class="number">3306</span></span><br><span class="line">Oracle 默认端口：<span class="number">1521</span></span><br><span class="line">动态、私有端口：<span class="number">49152</span>~<span class="number">65535</span></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">netstat -ano #查看所有端口</span><br><span class="line">netstat -ano|findstr &quot;6732&quot; #查看指定端口</span><br><span class="line">tasklist|findstr &quot;6732&quot; #查看指定进程</span><br><span class="line"># 使用任务管理器查看PID</span><br><span class="line"></span><br><span class="line">端口通信概念图:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/gmtiqWDEOPyz3BJ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">端口号与IP地址的组合，得出一个网络套接字：Socket，所以说一些网络编程也被称为Socket编程</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">InetSocketAddressTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress socketAddress2 = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">9000</span>);</span><br><span class="line">        System.out.println(socketAddress.getHostName());</span><br><span class="line">        System.out.println(socketAddress.getAddress());</span><br><span class="line">        System.out.println(socketAddress.getPort());</span><br><span class="line">        System.out.println(socketAddress2.getHostName());</span><br><span class="line">        System.out.println(socketAddress2.getAddress()); <span class="comment">//返回地址</span></span><br><span class="line">        System.out.println(socketAddress2.getPort()); <span class="comment">//返回端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果为: 127.0.0.1</span></span><br><span class="line">     <span class="comment">//127.0.0.1/127.0.0.1</span></span><br><span class="line">     <span class="comment">//8080</span></span><br><span class="line">     <span class="comment">//localhost</span></span><br><span class="line">     <span class="comment">//localhost/127.0.0.1</span></span><br><span class="line">     <span class="comment">//9000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.5</span>、网络通信协议</span><br><span class="line">协议：就好比我们都说的普通话，大家才能听懂我讲的，但是我们还有自己的方言！</span><br><span class="line"></span><br><span class="line">网络通信协议：</span><br><span class="line">计算机网络中实现通信必须有一些约定，即通信协议，对速率，传输代码，代码结构，传输控制步骤，</span><br><span class="line">出错控制等制定标准。</span><br><span class="line"></span><br><span class="line">问题：网路协议太复杂？</span><br><span class="line">计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量</span><br><span class="line">控制，路由控制，如何实现如此复杂的网络协议呢？</span><br><span class="line"></span><br><span class="line">通信协议分层的思想</span><br><span class="line">在制定协议时，把复杂成份分解成一些简单的成份，再将他们复合起来。最常用的复合方式是层次方</span><br><span class="line">式，即同层间可以通信，上一层调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开</span><br><span class="line">发和扩展。</span><br><span class="line"></span><br><span class="line">TCP/IP协议簇</span><br><span class="line">传输层协议中有两个非常重要的协议：</span><br><span class="line">用户传输协议 TCP （Transmission Control Protocol）tcp</span><br><span class="line">用户数据报协议（User Datagram Protocol）udp</span><br><span class="line"></span><br><span class="line">Tcp/IP 以其两个主要协议： 传输控制协议：TCP，和网络互联协议：IP，而得名，实际上是一组协</span><br><span class="line">议，包括多个具有不同功能且互为关联的协议。</span><br><span class="line">IP（Internet Protocol）协议是网络层的主要协议，支持网间互联的数据通信。</span><br><span class="line">TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层，IP层，传输层</span><br><span class="line">和应用层</span><br><span class="line"></span><br><span class="line">TCP 和 UDP对比</span><br><span class="line">TCP协议(打电话)</span><br><span class="line">使用TCP协议前，必须建立TCP连接，形成传输数据通道；</span><br><span class="line">传输前，采用 ‘ 三次握手 ’ 方式，点对点通信，是可靠的。</span><br><span class="line">[你瞅啥?瞅你咋地?干一场!](最少需要三次才能保证稳定连接)</span><br><span class="line"></span><br><span class="line">[我要断开连接了.我知道你要断开了.你真的断开了吗?我真的断开了](最少需要四次才能保证断开连接)</span><br><span class="line">TCP协议进行通信的两个应用进程：客户端，服务端。</span><br><span class="line">在连接中可进行大数据量的传输</span><br><span class="line">传输完毕，需要释放已建立的连接，效率低</span><br><span class="line">举例：打电话</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/XjbL7wos3g6ux8R.png"></p>
<p><img src="https://i.loli.net/2020/09/26/OeibafS1VYKv3ZQ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UDP协议(发短信)</span><br><span class="line">将数据，源，目的封装成数据包，不需要建立连接</span><br><span class="line">每个数据报的大小限制在<span class="number">64</span>K内</span><br><span class="line">发送方不管对方是否准备好，接收方收到也不确认，故事不可靠的</span><br><span class="line">可以广播发送</span><br><span class="line">发送数据结束时，无需释放资源，开销小，速度快。</span><br><span class="line">举例：发短信，导弹</span><br><span class="line">ddos饱和攻击(洪水攻击)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、TCP网络编程</span><br><span class="line"><span class="number">2.1</span>、案例一</span><br><span class="line">需求：客户端发送信息给服务端，服务端将数据显示在控制台上。</span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line"><span class="number">1.</span>连接服务器socket</span><br><span class="line"><span class="number">2.</span>发送消息</span><br><span class="line"></span><br><span class="line">服务器</span><br><span class="line"><span class="number">1.</span>建立服务的端口serversocket</span><br><span class="line"><span class="number">2.</span>等待用户的衔接</span><br><span class="line"><span class="number">3.</span>接收用的消息</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 连接服务器的地址</span></span><br><span class="line">            InetAddress serverIP = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">8899</span>;</span><br><span class="line"><span class="comment">//2. 创建一个Socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP,port);</span><br><span class="line"><span class="comment">//3. 创建一个输出流，向外写东西</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;哈哈哈,我在向你发送消息&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//4. 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket accept = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 开放服务器端口，创建ServerSocket</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line"><span class="comment">//2. 等待客户端的连接</span></span><br><span class="line">            accept = serverSocket.accept();</span><br><span class="line"><span class="comment">//3. 读入客户端的消息,</span></span><br><span class="line">            is = accept.getInputStream();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">回忆之前的IO流方案，弊端：存在中文，可能存在乱码。</span></span><br><span class="line"><span class="comment">byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">int len;</span></span><br><span class="line"><span class="comment">while ((len=is.read(buffer))!=-1)&#123;</span></span><br><span class="line"><span class="comment">String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">System.out.println(str);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;数据来源地址：&quot;</span>+accept.getInetAddress().getHostName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//4. 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (accept!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/lc4JMNevQnCkoT9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.2</span>、案例二</span><br><span class="line">需求：客户端发送文件给服务器，服务端将文件保存在本地。</span><br><span class="line">我们需要准备一个图片，放在项目目录下：</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">编写代码：客户端</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//1. 创建socket连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2. 创建一个输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"><span class="comment">//3. 读取文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;案例.jpg&quot;</span>));</span><br><span class="line"><span class="comment">//4. 写出文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//5. 资源关闭,应该使用 try-catch-finally</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1. 开启 ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2. 监听 客户端 Socket的连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"><span class="comment">//3. 获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line"><span class="comment">//4. 读取接收的文件并保存</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;receive.jpg&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//5.关闭资源,应该使用 try-catch-finally</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span>、案例三</span><br><span class="line">需求：我们需要在案例二的基础上，接收成功后，返回给客户端，接收成功！然后客户端才关闭连接！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//1. 创建socket连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2. 创建一个输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"><span class="comment">//3. 读取文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;案例.jpg&quot;</span>));</span><br><span class="line"><span class="comment">//4. 写出文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//告诉服务器，我传输完了,关闭数据的输出，不然就会一直阻塞！</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"><span class="comment">//先别着急关，等待服务器响应，响应到控制台，注意重复的变量问题！</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span> ((len2=inputStream.read(buffer2))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer2,<span class="number">0</span>,len2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"><span class="comment">//5. 资源关闭,应该使用 try-catch-finally</span></span><br><span class="line">        baos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1. 开启 ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2. 侦听 客户端 Socket</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"><span class="comment">//3. 获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line"><span class="comment">//4. 读取接收的文件并保存</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;receive2.jpg&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通知客户端接收成功</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;文件已经成功收到，OK&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">//5.关闭资源,应该使用 try-catch-finally</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.5</span>、初识Tomcat服务器</span><br><span class="line"></span><br><span class="line">客户端</span><br><span class="line">自定义s</span><br><span class="line">浏览器s</span><br><span class="line"></span><br><span class="line">服务端</span><br><span class="line">自定义c</span><br><span class="line">Tomcat服务器b</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将提供的tomcat解压</span><br><span class="line"><span class="number">2.</span> 运行bin目录下的启动文件</span><br><span class="line"><span class="number">3.</span> 测试访问localhost:<span class="number">8080</span></span><br><span class="line"><span class="number">4.</span> 现在，我们在里面的 \webapps\ROOT 目录下 新建一个hello.txt，编辑文件保存！</span><br><span class="line"><span class="number">5.</span> 浏览器输入 http:<span class="comment">//localhost:8080/kuangshen.txt ，发现可以访问到我们客户端的资源，OK</span></span><br><span class="line"><span class="number">6.</span> 这里，我们的浏览器，就相当于是一个客户端，而Tomcat 服务器，就相当于是服务端，具体的关</span><br><span class="line">于Tomcat的学习我们要到 JavaWeb 阶段会具体学习</span><br><span class="line">[思考:]同一个写一下端口不能冲突</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、UDP网络编程</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span>、说明</span><br><span class="line">没有真正的服务端客户端,但是有发送方和接收方的概念.(接受包)</span><br><span class="line">DatagramSocket 和 DatagramPacket 两个类实现了基于UDP协议的网络程序。</span><br><span class="line">UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安</span><br><span class="line">全送到目的地，也不确定什么时候可以抵达。</span><br><span class="line">DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端</span><br><span class="line">的IP地址和端口号。</span><br><span class="line">UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快</span><br><span class="line">递包裹一样。</span><br><span class="line"><span class="number">3.2</span>、案例一</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">发送方</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="comment">//不需要连接服务器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDPSenderDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1. 建立DatagramSocket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//2. 封装数据包</span></span><br><span class="line">        String msg = <span class="string">&quot;UDPSender==&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = msg.getBytes();</span><br><span class="line">        InetAddress inet = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>,data.length,inet,port);</span><br><span class="line"><span class="comment">//3. 通过 Socket 发送 packet</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"><span class="comment">//4. 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接收方</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="comment">//还是要等待发送方接收</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDPReceiverDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1. 建立DatagramSocket,开放端口</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2. 接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"><span class="comment">//3. 输出数据</span></span><br><span class="line"><span class="comment">// packet.getData() : 获取packet中的数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line"><span class="comment">//4. 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.3</span>、案例二：在线咨询</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">客户端</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UdpTalkClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方启动中....&quot;</span>);</span><br><span class="line"><span class="comment">//1. 使用DatagramSocket 指定端口，创建发送端</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2. 准备数据，转成字节数组</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">                InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            String data = reader.readLine();</span><br><span class="line">            <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line"><span class="comment">//3. 封装成DatagramPacket包裹，需要指定目的地</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,</span><br><span class="line">                    <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">6666</span>));</span><br><span class="line"><span class="comment">//4. 发送包裹send</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line"><span class="comment">//退出判断</span></span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//5. 释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接收方</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UdpTalkServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//准备接收包裹；</span></span><br><span class="line">                <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container, <span class="number">0</span>, container.length);</span><br><span class="line">                socket.receive(packet); <span class="comment">//阻塞式接收包裹</span></span><br><span class="line">                <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">                <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">                String data = <span class="keyword">new</span> String(datas,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(data);</span><br><span class="line"><span class="comment">//退出判断</span></span><br><span class="line">                <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">问题：现在需要两遍需要接受和发送，我们可以使用多线程来解决！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">发送端多线程</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toPort;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkSend</span><span class="params">(<span class="keyword">int</span> port,String toIP,<span class="keyword">int</span> toPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toIP = toIP;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String data = reader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line"><span class="comment">//3. 封装成DatagramPacket包裹，需要指定目的地</span></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span></span><br><span class="line">                        DatagramPacket(datas,<span class="number">0</span>,datas.length,</span><br><span class="line">                        <span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.toIP,<span class="keyword">this</span>.toPort));</span><br><span class="line"><span class="comment">//4. 发送包裹send</span></span><br><span class="line">                socket.send(packet);</span><br><span class="line"><span class="comment">//退出判断</span></span><br><span class="line">                <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//5. 释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接收端多线程</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkReceive</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkReceive</span><span class="params">(<span class="keyword">int</span> port,String msgFrom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//准备接收包裹；</span></span><br><span class="line">                <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container, <span class="number">0</span>,</span><br><span class="line">                        container.length);</span><br><span class="line">                socket.receive(packet); <span class="comment">//阻塞式接收包裹</span></span><br><span class="line">                <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">                <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">                String data = <span class="keyword">new</span> String(datas,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(msgFrom+<span class="string">&quot;:&quot;</span>+data);</span><br><span class="line"><span class="comment">//退出判断</span></span><br><span class="line">                <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">学生端:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">7777</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="number">8888</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">老师端:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="number">9999</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">5555</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、URL编程(dns域名解析,把一个ip地址变成域名)</span><br><span class="line"><span class="number">4.1</span>、url类</span><br><span class="line">URL （Uniform Resource Locator）： 统一资源定位符，它表示 internet 上某一资源的地址。</span><br><span class="line">它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate：定位这个资源。</span><br><span class="line">通过URL 我们可以访问Internet上的各种网络资源，比如最常见的 www,ftp站点。浏览器通过解析</span><br><span class="line">给定的URL可以在网络上查找相应的文件或其他资源。</span><br><span class="line"></span><br><span class="line">URL 的 基本结构由 <span class="number">5</span>部分组成：</span><br><span class="line">传输协议：<span class="comment">//主机名：端口号/文件名 #片段名？参数列表</span></span><br><span class="line">例如：http:<span class="comment">//localhost:8080/helloworld/index.jsp#a?username=kuangshen&amp;password=123</span></span><br><span class="line">片段名，即锚链接，比如我们去一些小说网站，可以直接定位到某个章节位置</span><br><span class="line">参数列表格式 ： 参数名=参数值 &amp; 参数名=参数值...</span><br><span class="line"></span><br><span class="line">实例化</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/helloworld/index.jsp? username=hhh&amp;password=123&quot;</span>);</span><br><span class="line">            System.out.println(url.getProtocol()); <span class="comment">//获取URL的协议名</span></span><br><span class="line">            System.out.println(url.getHost()); <span class="comment">//获取URL的主机名</span></span><br><span class="line">            System.out.println(url.getPort()); <span class="comment">//获取URL的端口号</span></span><br><span class="line">            System.out.println(url.getPath()); <span class="comment">//获取URL的文件路径</span></span><br><span class="line">            System.out.println(url.getFile()); <span class="comment">//获取URL的文件名</span></span><br><span class="line">            System.out.println(url.getQuery()); <span class="comment">//获取URL的查询名</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.2</span>、下载tomcat下的文件</span><br><span class="line">首先需要在tomcat中放入一个资源文件！</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 定位到服务器端的资源</span></span><br><span class="line">            URL url = <span class="keyword">new</span></span><br><span class="line">                    URL(<span class="string">&quot;http://localhost:8080/xosin/safe.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2. 创建连接</span></span><br><span class="line">            HttpURLConnection connection = (HttpURLConnection)</span><br><span class="line">                    url.openConnection();</span><br><span class="line"><span class="comment">//3. 获取输入流</span></span><br><span class="line">            InputStream is = connection.getInputStream();</span><br><span class="line"><span class="comment">//4. 写出文件</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;safe.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">            fos.close();</span><br><span class="line">            is.close();</span><br><span class="line">            connection.disconnect();<span class="comment">//断开连接</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="六、Gui编程"><a href="#六、Gui编程" class="headerlink" title="六、Gui编程"></a>六、Gui编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GUI编程</span><br><span class="line">Swing和AWT 是java开发GUI常用的技术 . 但是由于外观不太美观, 组件数量偏少, 并且运行需要JRE环境</span><br><span class="line">(动不动就上百M的JRE包....), 所以没有流行起来. 但是 ,建议学还是需要简单的学习和了解的.</span><br><span class="line"><span class="number">1.</span> 组件(JTable,JList等)很多都是MVC的经典示范. 学习也可以了解mvc架构的</span><br><span class="line"><span class="number">2.</span> 工作时,也有可能遇见需要维护N年前awt/swing写的软件 ,虽然可能性很小</span><br><span class="line"><span class="number">3.</span> 可以写一些自己使用用的软件. 还是相当的方便.</span><br><span class="line">艺多不压身</span><br><span class="line">学习了swing还有必要学习awt吗？</span><br><span class="line">swing是建立在awt基础上的。</span><br><span class="line">还是有必要学习一下的.原因如下:</span><br><span class="line">知识的关联性 . 比如 布局 , 颜色, 字体,事件机制 等....这些都是awt里的内容. 但在swing里也经常使</span><br><span class="line">用到.</span><br><span class="line">学习成本低, 因为awt和swing在编码上区别不大, 写法基本一致, 组件使用上也差不多,(只需要记住</span><br><span class="line">少数有区别的地方就可以了)</span><br><span class="line">使用场景存在不同. awt消耗资源少, 运行速度快. 适合嵌入式等. swing跨平台,组件丰富.</span><br><span class="line">虽然现在用Java做cs的很少，但是对于我们学习Java基础来说，我觉得这个还是很好的资源，我们可以</span><br><span class="line">利用它把以前的所有知识贯穿起来，做一些小应用，游戏，等都可以，可以将自己的一些小想法，做成</span><br><span class="line">工具分享出来！</span><br><span class="line"></span><br><span class="line">AWT</span><br><span class="line">一、AWT介绍</span><br><span class="line">AWT（Abstract Window Toolkit）包括了很多类和接口，用于Java Application的GUI（Graphics</span><br><span class="line">User Interface 图形用户界面）编程。</span><br><span class="line">GUI的各种元素（如：窗口，按钮，文本框等）由Java类来实现。</span><br><span class="line">使用AWT所涉及的类一般在Java.AWT包及其子包中。</span><br><span class="line">Container和Component是AWT中的两个核心类。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/cq93tdzrS64nsDO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所有的可以显示出来的图形元素都称为Component，Component代表了所有的可见的图形元素，</span><br><span class="line">Component里面有一种比较特殊的图形元素叫Container，Container(容器)在图形界面里面是一种可以</span><br><span class="line">容纳其它Component元素的一种容器，Container本身也是一种Component的，Container里面也可以</span><br><span class="line">容纳别的Container。</span><br><span class="line">Container里面又分为Window和Pannel，Window是可以独立显示出来的，平时我们看到的各种各样的</span><br><span class="line">应用程序的窗口都可以称为Window，Window作为一个应用程序窗口独立显示出来，Pannel也可以容</span><br><span class="line">纳其它的图形元素，但一般看不见Pannel，Pannel不能作为应用程序的独立窗口显示出来，Pannel要想</span><br><span class="line">显示出来就必须得把自己装入到Window里面才能显示出来。</span><br><span class="line"></span><br><span class="line">Pannel应用比较典型的就是Applet(JAVA的页面小应用程序)，现在基本上已经不用了，AJAX和</span><br><span class="line">JAVASCRIPT完全取代了它的应用。</span><br><span class="line"></span><br><span class="line">Window本身又可以分为Frame和Dialog，Frame就是我们平时看到的一般的窗口，而Dialog则是那</span><br><span class="line">些需要用户进行了某些操作(如点击某个下拉菜单的项)才出现的对话框，这种对话框就是Dialog。</span><br><span class="line"></span><br><span class="line">二、组件和容器(Component和Container)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/MeyJ7TCFDwfg5Uv.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.1</span>.Frame</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/vNWUJjd3Bizl9CY.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【Frame范例】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.gui编程;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class frame示例 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="comment">//学习JAVA的GUI编程编写的第一个图形界面窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里只是在内存里面创建了一个窗口对象 还不能真正显示出来然我们看到</span></span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;我的第一个JAVA图形界面窗口&quot;</span>);</span><br><span class="line"><span class="comment">//设置窗体的背景颜色</span></span><br><span class="line">        frame.setBackground(Color.blue);</span><br><span class="line"><span class="comment">//设置窗体是否可见</span></span><br><span class="line"><span class="comment">//要想看到在内存里面创建出来的窗口对象</span></span><br><span class="line"><span class="comment">//必须调用setVisble()方法</span></span><br><span class="line"><span class="comment">//并且把参数true传入才能看得见窗体</span></span><br><span class="line"><span class="comment">//如果传入的参数是false</span></span><br><span class="line"><span class="comment">//那么窗体也是看不见的</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置窗体的初始大小</span></span><br><span class="line">        frame.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"><span class="comment">//设置窗体出现时的位置，如果不设置则默认在左上角(0,0)位置显示</span></span><br><span class="line">        frame.setLocation(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 设置窗体能否被改变大小</span></span><br><span class="line"><span class="comment">// 设置为false后表示不能改变窗体的显示大小</span></span><br><span class="line"><span class="comment">// 这里将窗体显示的大小设置为200X200</span></span><br><span class="line"><span class="comment">// 那么窗体的显示只能是这个大小了，不能再使用鼠标拖大或者缩小</span></span><br><span class="line">        frame.setResizable(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:(通过停止程序关闭)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/63ahmURElQTxySc.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【演示二：展示多个窗口】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMultiFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyFrame f1 = <span class="keyword">new</span> MyFrame(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,Color.blue);</span><br><span class="line">        MyFrame f2 = <span class="keyword">new</span> MyFrame(<span class="number">300</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,Color.yellow);</span><br><span class="line">        MyFrame f3 = <span class="keyword">new</span> MyFrame(<span class="number">100</span>,<span class="number">300</span>,<span class="number">200</span>,<span class="number">200</span>,Color.red);</span><br><span class="line">        MyFrame f4 = <span class="keyword">new</span> MyFrame(<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,<span class="number">200</span>,Color.MAGENTA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义一个类MyFrame，并且从Frame类继承</span></span><br><span class="line"><span class="comment">//这样MyFrame类就拥有了Frame类的一切属性和方法</span></span><br><span class="line"><span class="comment">//并且MyFrame类还可以自定义属性和方法</span></span><br><span class="line"><span class="comment">//因此使用从Frame类继承而来的自定义类来创建图形窗口比直接使用Frame类来创建图形窗口要灵活</span></span><br><span class="line"><span class="comment">//所以一般使用从Frame类继承而来的自定义类创建图形窗口界面比较好，</span></span><br><span class="line"><span class="comment">//不推荐直接使用Frame类来创建图形窗口界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个静态成员变量id，用来记录创建出来的窗口的数目</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自定义构成方法，在构造方法体内使用super调用父类Frame的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFrame</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> h,Color color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;MyFrame&quot;</span>+(++id));</span><br><span class="line">        <span class="comment">/*使用从父类Frame继承而来的方法设置窗体的相关属性*/</span></span><br><span class="line">        setBackground(color);</span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setBounds(x,y,w,h);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/BbAGKfp3d26oTea.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.2</span>.Panel</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/f4orxXsL3ayStg9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPanel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;JAVA Frame With Panel&quot;</span>);</span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel(<span class="keyword">null</span>);</span><br><span class="line">        frame.setLayout(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//这里设置的坐标(300,300)是相对于整个屏幕的</span></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"><span class="comment">//设置背景颜色时使用三基色(红，绿，蓝)的比例来调配背景色</span></span><br><span class="line">        frame.setBackground(<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">102</span>));</span><br><span class="line"><span class="comment">//这里设置的坐标(50,50)是相对于Frame窗体的</span></span><br><span class="line">        panel.setBounds(<span class="number">50</span>,<span class="number">50</span>,<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">        panel.setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>,<span class="number">255</span>));</span><br><span class="line"><span class="comment">//把Panel容器装入到Frame容器中，使其能在Frame窗口中显示出来</span></span><br><span class="line">        frame.add(panel);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//解决关闭问题</span></span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> WindowListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/YcvglZGI783XDid.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">三、布局管理器</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/CamqowSN2FH5Lxv.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.1</span>.第一种布局管理器——FlowLayout</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/nswWGNF4iZBM57r.png"></p>
<p><img src="https://i.loli.net/2020/09/28/WaVXAnRBPQNeyZU.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFlowLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;FlowLayout&quot;</span>);</span><br><span class="line"><span class="comment">//使用Button类创建按钮</span></span><br><span class="line"><span class="comment">// 按钮类的其中一个构造方法：Button(String label) label为按钮显示的文本</span></span><br><span class="line">        Button button1 = <span class="keyword">new</span> Button(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">        Button button2 = <span class="keyword">new</span> Button(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">        Button button3 = <span class="keyword">new</span> Button(<span class="string">&quot;button3&quot;</span>);</span><br><span class="line"><span class="comment">// setLayout方法的定义：public void setLayout(LayoutManager mgr)</span></span><br><span class="line"><span class="comment">// 使用流水(Flow)线般的布局</span></span><br><span class="line">        frame.setLayout(<span class="keyword">new</span> FlowLayout());</span><br><span class="line"><span class="comment">// 使用了布局管理器FlowLayout，这里的布局采用默认的水平居中模式</span></span><br><span class="line"><span class="comment">// frame.setLayout(new FlowLayout(FlowLayout.LEFT));</span></span><br><span class="line"><span class="comment">// 这里在布局的时候使用了FlowLayout.LEFT常量，这样就将按钮设置为左对齐</span></span><br><span class="line"><span class="comment">// frame.setLayout(new FlowLayout(FlowLayout.RIGHT));</span></span><br><span class="line"><span class="comment">//这里在布局的时候使用了FlowLayout.RIGHT常量，这样就将按钮设置为右对齐</span></span><br><span class="line">        frame.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        frame.add(button1); <span class="comment">// 把创建出来的按钮放置到Frame窗体中</span></span><br><span class="line">        frame.add(button2); <span class="comment">// 这里并没有设置按钮的大小与位置</span></span><br><span class="line">        frame.add(button3); <span class="comment">// 设置按钮的大小与位置都是由布局管理器来做的</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/NJXWBelcYj9H3VS.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.2</span>.第二种布局管理器——BorderLayout</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/twdrSgoVqyTCM58.png"></p>
<p><img src="https://i.loli.net/2020/09/28/MFo7Q46JcAP5naX.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBorderLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;TestBorderLayout&quot;</span>);</span><br><span class="line">        Button buttonEast = <span class="keyword">new</span> Button(<span class="string">&quot;East&quot;</span>);</span><br><span class="line">        Button buttonWest = <span class="keyword">new</span> Button(<span class="string">&quot;West&quot;</span>);</span><br><span class="line">        Button buttonSouth = <span class="keyword">new</span> Button(<span class="string">&quot;South&quot;</span>);</span><br><span class="line">        Button buttonNorth = <span class="keyword">new</span> Button(<span class="string">&quot;North&quot;</span>);</span><br><span class="line">        Button buttonCenter = <span class="keyword">new</span> Button(<span class="string">&quot;Center&quot;</span>);</span><br><span class="line"><span class="comment">//把按钮放置到Frame窗体时按照东西南北中五个方向排列好,推荐使用这种方式去排列窗体元素</span></span><br><span class="line"><span class="comment">//这样容易检查出错误 因为这样写如果写错了编译器会提示出错</span></span><br><span class="line">        frame.add(buttonEast,BorderLayout.EAST);</span><br><span class="line">        frame.add(buttonWest,BorderLayout.WEST);</span><br><span class="line">        frame.add(buttonSouth,BorderLayout.SOUTH);</span><br><span class="line">        frame.add(buttonNorth,BorderLayout.NORTH);</span><br><span class="line">        frame.add(buttonCenter,BorderLayout.CENTER);</span><br><span class="line"><span class="comment">//也可以使用这样的方式排列按钮 在把按钮放置到Frame窗体时使用方向定位的字符串指定按钮的放置位置</span></span><br><span class="line"><span class="comment">//这种使用方向定位的字符串指定按钮的放置方式不推荐使用 一旦写错了方向字符串就不好检查出来</span></span><br><span class="line"><span class="comment">//因为即使是写错了仍然可以编译通过</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">frame.add(buttonEast,&quot;EAST&quot;);</span></span><br><span class="line"><span class="comment">frame.add(buttonWest,&quot;West&quot;);</span></span><br><span class="line"><span class="comment">frame.add(buttonSouth,&quot;South&quot;);</span></span><br><span class="line"><span class="comment">frame.add(buttonNorth,&quot;North&quot;);</span></span><br><span class="line"><span class="comment">frame.add(buttonCenter,&quot;Center&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        frame.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/pE6VJ5oAqwTkKds.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.3</span>.第三种布局管理器——GridLayout（表格布局管理器）</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/EDuA5alNV62MqIi.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGridLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;TestGridLayout&quot;</span>);</span><br><span class="line">        Button btn1 = <span class="keyword">new</span> Button(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">        Button btn2 = <span class="keyword">new</span> Button(<span class="string">&quot;btn2&quot;</span>);</span><br><span class="line">        Button btn3 = <span class="keyword">new</span> Button(<span class="string">&quot;btn3&quot;</span>);</span><br><span class="line">        Button btn4 = <span class="keyword">new</span> Button(<span class="string">&quot;btn4&quot;</span>);</span><br><span class="line">        Button btn5 = <span class="keyword">new</span> Button(<span class="string">&quot;btn5&quot;</span>);</span><br><span class="line">        Button btn6 = <span class="keyword">new</span> Button(<span class="string">&quot;bnt6&quot;</span>);</span><br><span class="line"><span class="comment">// 把布局划分成3行2列的表格布局形式</span></span><br><span class="line">        frame.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">3</span>,<span class="number">2</span>));</span><br><span class="line">        frame.add(btn1);</span><br><span class="line">        frame.add(btn2);</span><br><span class="line">        frame.add(btn3);</span><br><span class="line">        frame.add(btn4);</span><br><span class="line">        frame.add(btn5);</span><br><span class="line">        frame.add(btn6);</span><br><span class="line"><span class="comment">// Frame.pack()是JAVA语言的一个函数</span></span><br><span class="line"><span class="comment">// 这个函数的作用就是根据窗口里面的布局及组件的preferredSize来确定frame的最佳大小。</span></span><br><span class="line">        frame.pack();</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/LvcP7tDX5ZqOgjs.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.4</span>.布局练习</span><br><span class="line"></span><br><span class="line">这几种布局管理器可以设置在Frame里面，也可以设置在Panel里面，而Panel本身也可以加入到Frame</span><br><span class="line">里面，因此通过Frame与Panel的嵌套就可以实现比较复杂的布局；</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTenButtons</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里主要是对显示窗体进行设置</span></span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;布局管理器的嵌套使用&quot;</span>);</span><br><span class="line"><span class="comment">//把整个窗体分成2行1列的表格布局</span></span><br><span class="line">        frame.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        frame.setLocation(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">        frame.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        frame.setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>,<span class="number">255</span>));</span><br><span class="line"><span class="comment">//这里主要是对Panel进行布局的设置</span></span><br><span class="line">        Panel p1 = <span class="keyword">new</span> Panel(<span class="keyword">new</span> BorderLayout());</span><br><span class="line"><span class="comment">//p2使用2行1列的表格布局</span></span><br><span class="line">        Panel p2 = <span class="keyword">new</span> Panel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        Panel p3 = <span class="keyword">new</span> Panel(<span class="keyword">new</span> BorderLayout());</span><br><span class="line"><span class="comment">//p4使用2行2列的表格布局</span></span><br><span class="line">        Panel p4 = <span class="keyword">new</span> Panel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">//这里主要是把按钮元素加入到Panel里面</span></span><br><span class="line">        p1.add(<span class="keyword">new</span> Button(<span class="string">&quot;East(p1-东)&quot;</span>),BorderLayout.EAST);</span><br><span class="line">        p1.add(<span class="keyword">new</span> Button(<span class="string">&quot;West(p1-西)&quot;</span>),BorderLayout.WEST);</span><br><span class="line">        p2.add(<span class="keyword">new</span> Button(<span class="string">&quot;p2-Button1&quot;</span>));</span><br><span class="line">        p2.add(<span class="keyword">new</span> Button(<span class="string">&quot;p2-Button2&quot;</span>));</span><br><span class="line"><span class="comment">//p1里面嵌套p2，把p2里面的按钮作为p的中间部分装入到p1里面</span></span><br><span class="line"><span class="comment">//把p2作为元素加入到p1里面</span></span><br><span class="line">        p1.add(p2,BorderLayout.CENTER);</span><br><span class="line">        p3.add(<span class="keyword">new</span> Button(<span class="string">&quot;East(p3-东)&quot;</span>),BorderLayout.EAST);</span><br><span class="line">        p3.add(<span class="keyword">new</span> Button(<span class="string">&quot;West(p3-西)&quot;</span>),BorderLayout.WEST);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            p4.add(<span class="keyword">new</span> Button(<span class="string">&quot;p4-Button&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//p3里面嵌套p4，把p4里面的按钮作为p的中间部分装入到p3里面</span></span><br><span class="line">        p3.add(p4,BorderLayout.CENTER);</span><br><span class="line"><span class="comment">//把Panel装入Frame里面,以便于在Frame窗体中显示出来</span></span><br><span class="line">        frame.add(p1);</span><br><span class="line">        frame.add(p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/T7RgJwVKEmnkqh2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">四、布局管理器总结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/e29CXLgwGEDPahJ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">五、事件监听</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/2oWlZFKuyT6Hkjc.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">点击按钮控制台输出:<span class="string">&quot;A Button has been Pressed&quot;</span></span><br><span class="line">点击关闭按钮窗口关闭</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActionEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;TestActionEvent&quot;</span>);</span><br><span class="line">        Button button = <span class="keyword">new</span> Button(<span class="string">&quot;Press Me&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个监听对象</span></span><br><span class="line">        MyActionListener listener = <span class="keyword">new</span> MyActionListener();</span><br><span class="line"><span class="comment">// 把监听加入到按钮里面，监听按钮的动作，</span></span><br><span class="line"><span class="comment">// 当按钮触发打击事件时，就会返回一个监听对象e</span></span><br><span class="line"><span class="comment">// 然后就会自动执行actionPerformed方法</span></span><br><span class="line">        button.addActionListener(listener);</span><br><span class="line">        frame.add(button, BorderLayout.CENTER);</span><br><span class="line">        frame.pack();</span><br><span class="line">        addWindowClosingEvent(frame);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//点击窗体上的关闭按钮关闭窗体</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addWindowClosingEvent</span><span class="params">(Frame frame)</span></span>&#123;</span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义Monitor(监听)类实现事件监听接口ActionListener</span></span><br><span class="line"><span class="comment">// 一个类要想成为监听类，那么必须实现ActionListener接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActionListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写ActionListener接口里面的actionPerformed(ActionEvent e)方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A Button has been Pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对两个按钮的监听</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActionEvent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;TestActionEvent&quot;</span>);</span><br><span class="line">        Button btn1 = <span class="keyword">new</span> Button(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        Button btn2 = <span class="keyword">new</span> Button(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line"><span class="comment">//创建监听对象</span></span><br><span class="line">        MyMonitor monitor = <span class="keyword">new</span> MyMonitor();</span><br><span class="line"><span class="comment">//一个监听对象同时监听两个按钮的动作</span></span><br><span class="line">        btn1.addActionListener(monitor);</span><br><span class="line">        btn2.addActionListener(monitor);</span><br><span class="line"><span class="comment">//设置btn2的执行单击命令后的返回信息</span></span><br><span class="line">        btn2.setActionCommand(<span class="string">&quot;GameOver&quot;</span>);</span><br><span class="line">        frame.add(btn1,BorderLayout.NORTH);</span><br><span class="line">        frame.add(btn2,BorderLayout.CENTER);</span><br><span class="line">        frame.pack();</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMonitor</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用返回的监听对象e调用getActionCommand()方法获取两个按钮执行单击命令后的返回信息</span></span><br><span class="line"><span class="comment">//根据返回信息的不同区分开当前操作的是哪一个按钮,btn1没有使用setActionCommand()方法设置</span></span><br><span class="line"><span class="comment">//则btn1返回的信息就是按钮上显示的文本</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a button has been pressed,&quot;</span>+<span class="string">&quot;the relative info is:\n&quot;</span></span><br><span class="line">                +e.getActionCommand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">六、TextField事件监听</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/E8AOuewrM5kylNY.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在控制台输出窗口输入的字符串,并在窗口用*号加密</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTextField</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyFrameTextField();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrameTextField</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    MyFrameTextField()&#123;</span><br><span class="line">        TextField textField = <span class="keyword">new</span> TextField();</span><br><span class="line">        add(textField);</span><br><span class="line">        textField.addActionListener(<span class="keyword">new</span> MyMonitor2());</span><br><span class="line"><span class="comment">//这个setEchoChar()方法是设置文本框输入时显示的字符，这里设置为*，</span></span><br><span class="line"><span class="comment">//这样输入任何内容就都以*显示出来，不过打印出来时依然可以看到输入的内容</span></span><br><span class="line">        textField.setEchoChar(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMonitor2</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//接口里面的所有方法都是public(公共的)</span></span><br><span class="line"><span class="comment">//所以从API文档复制void actionPerformed(ActionEvent e)时 要在void前面加上</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//事件的相关信息都封装在了对象e里面，通过对象e的相关方法就可以获取事件的相关信息</span></span><br><span class="line"><span class="comment">//getSource()方法是拿到事件源，注意：拿到这个事件源的时候</span></span><br><span class="line"><span class="comment">//是把它当作TextField的父类来对待</span></span><br><span class="line"><span class="comment">//getSource()方法的定义是：“public Object getSource()”返回值是一个Object对象</span></span><br><span class="line"><span class="comment">//所以要强制转换成TextField类型的对象</span></span><br><span class="line"><span class="comment">//在一个类里面想访问另外一个类的事件源对象可以通过getSource()方法</span></span><br><span class="line">        TextField textField = (TextField) e.getSource();</span><br><span class="line"><span class="comment">// textField.getText()是取得文本框里面的内容</span></span><br><span class="line">        System.out.println(textField.getText());</span><br><span class="line"><span class="comment">// 把文本框里面的内容清空</span></span><br><span class="line">        textField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【使用TextField类实现简单的计算器】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里主要是完成计算器元素的布局</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    Calculator()&#123;</span><br><span class="line"><span class="comment">//创建3个文本框，并指定其初始大小分别为10个字符和15个字符的大小 这里使用的是TextField类的另外一种构造方法public TextField(int columns)</span></span><br><span class="line">        TextField num1 = <span class="keyword">new</span> TextField(<span class="number">10</span>);</span><br><span class="line">        TextField num2 = <span class="keyword">new</span> TextField(<span class="number">10</span>);</span><br><span class="line">        TextField num3 = <span class="keyword">new</span> TextField(<span class="number">15</span>);</span><br><span class="line"><span class="comment">//创建等号按钮</span></span><br><span class="line">        Button btnEqual = <span class="keyword">new</span> Button(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="comment">//给等号按钮加上监听，让点击按钮后有响应事件发生</span></span><br><span class="line">        btnEqual.addActionListener(</span><br><span class="line">                <span class="keyword">new</span> MyMonitor(num1, num2, num3)</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//“+”是一个静态文本，所以使用Label类创建一个静态文本对象</span></span><br><span class="line">        Label lblPlus = <span class="keyword">new</span> Label(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="comment">//把Frame默认的BorderLayout布局改成FlowLayout布局</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> FlowLayout());</span><br><span class="line">        add(num1);</span><br><span class="line">        add(lblPlus);</span><br><span class="line">        add(num2);</span><br><span class="line">        add(btnEqual);</span><br><span class="line">        add(num3);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMonitor</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line"><span class="comment">//为了使对按钮的监听能够对文本框也起作用</span></span><br><span class="line"><span class="comment">//所以在自定义类MyMonitor里面定义三个TextField类型的对象 num1,num2,num3,</span></span><br><span class="line"><span class="comment">//并且定义了MyMonitor类的一个构造方法 这个构造方法带有三个TextField类型的参数，</span></span><br><span class="line"><span class="comment">//用于接收 从TFFrame类里面传递过来的三个TextField类型的参数</span></span><br><span class="line"><span class="comment">//然后把接收到的三个TextField类型的参数赋值给在本类中声明的 三个TextField类型的参数num1,num2,num3</span></span><br><span class="line">    <span class="comment">//然后再在actionPerformed()方法里面处理num1,num2,num3</span></span><br><span class="line">    TextField num1, num2, num3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMonitor</span><span class="params">(TextField num1, TextField num2, TextField num3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num1 = num1;</span><br><span class="line">        <span class="keyword">this</span>.num2 = num2;</span><br><span class="line">        <span class="keyword">this</span>.num3 = num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件的相关信息都封装在了对象e里面，通过对象e的相关方法就可以获取事件的相关信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// num对象调用getText()方法取得自己显示的文本字符串</span></span><br><span class="line">        <span class="keyword">int</span> n1 = Integer.parseInt(num1.getText());</span><br><span class="line">        <span class="keyword">int</span> n2 = Integer.parseInt(num2.getText());</span><br><span class="line"><span class="comment">//num3对象调用setText()方法设置自己的显示文本</span></span><br><span class="line"><span class="comment">//字符串与任意类型的数据使用“+”连接时得到的一定是字符串，</span></span><br><span class="line"><span class="comment">//这里使用一个空字符串与int类型的数连接，这样就可以直接把(n1+n2)得到的int类型的数隐式地转换成字符串了，</span></span><br><span class="line"><span class="comment">//这是一种把别的基础数据类型转换成字符串的一个小技巧。</span></span><br><span class="line"><span class="comment">//也可以使用“String.valueOf((n1+n2))”把(n1+n2)的和转换成字符串</span></span><br><span class="line">        num3.setText(<span class="string">&quot;&quot;</span> + (n1 + n2));</span><br><span class="line"><span class="comment">//num3.setText(String.valueOf((n1+n2)));</span></span><br><span class="line"><span class="comment">//计算结束后清空num1,num2文本框里面的内容</span></span><br><span class="line">        num1.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        num2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【JAVA里面的经典用法：在一个类里面持有另外一个类的引用】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Calculator2().launchFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做好计算器的窗体界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator2</span> <span class="keyword">extends</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把设计计算器窗体的代码封装成一个方法</span></span><br><span class="line">    TextField num1, num2, num3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num1 = <span class="keyword">new</span> TextField(<span class="number">10</span>);</span><br><span class="line">        num2 = <span class="keyword">new</span> TextField(<span class="number">10</span>);</span><br><span class="line">        num3 = <span class="keyword">new</span> TextField(<span class="number">15</span>);</span><br><span class="line">        Label lblPlus = <span class="keyword">new</span> Label(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        Button btnEqual = <span class="keyword">new</span> Button(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        btnEqual.addActionListener(<span class="keyword">new</span> MyMonitorbtnEqual(<span class="keyword">this</span>));</span><br><span class="line">        setLayout(<span class="keyword">new</span> FlowLayout());</span><br><span class="line">        add(num1);</span><br><span class="line">        add(lblPlus);</span><br><span class="line">        add(num2);</span><br><span class="line">        add(btnEqual);</span><br><span class="line">        add(num3);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里通过取得Calculator2类的引用，然后使用这个引用去访问Calculator2类里面的成员变量</span></span><br><span class="line"><span class="comment">//这种做法比上一种直接去访问Calculator2类里面的成员变量要好得多</span></span><br><span class="line"><span class="comment">//因为现在不需要知道 Calculator2类里面有哪些成员变量了，</span></span><br><span class="line"><span class="comment">//现在要访问Calculator2类里面的成员变量，直接使用 Calculator2类对象的引用去访问即可</span></span><br><span class="line"><span class="comment">//这个Calculator2类的对象好比是一个大管家， 而我告诉大管家，我要访问Calculator2类里面的那些成员变量，</span></span><br><span class="line"><span class="comment">//大管家的引用就会去帮我找，不再需要我自己去找了。</span></span><br><span class="line"><span class="comment">//这种在一个类里面持有另一个类的引用的用法是一种非常典型的用法</span></span><br><span class="line"><span class="comment">//使用获取到的引用就可以在一个类里面访问另一个类的所有成员了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMonitorbtnEqual</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    Calculator2 calculator2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMonitorbtnEqual</span><span class="params">(Calculator2 calculator2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator2 = calculator2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = Integer.parseInt(calculator2.num1.getText());</span><br><span class="line">        <span class="keyword">int</span> n2 = Integer.parseInt(calculator2.num2.getText());</span><br><span class="line">        calculator2.num3.setText(<span class="string">&quot;&quot;</span> + (n1 + n2));</span><br><span class="line">        calculator2.num1.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        calculator2.num2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">七、内部类</span><br><span class="line"></span><br><span class="line">好处：</span><br><span class="line">可以方便的访问包装类的成员</span><br><span class="line">可以更清楚的组织逻辑，防止不应该被其他类 访问的类 进行访问</span><br><span class="line">何时使用：</span><br><span class="line">该类不允许或不需要其它类进行访问时</span><br><span class="line">【内部类的使用范例】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyMathFrame().launchFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">    TextField num1, num2, num3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num1 = <span class="keyword">new</span> TextField(<span class="number">10</span>);</span><br><span class="line">        num2 = <span class="keyword">new</span> TextField(<span class="number">15</span>);</span><br><span class="line">        num3 = <span class="keyword">new</span> TextField(<span class="number">15</span>);</span><br><span class="line">        Label lblPlus = <span class="keyword">new</span> Label(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        Button btnEqual = <span class="keyword">new</span> Button(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        btnEqual.addActionListener(<span class="keyword">new</span> MyMonitor());</span><br><span class="line">        setLayout(<span class="keyword">new</span> FlowLayout());</span><br><span class="line">        add(num1);</span><br><span class="line">        add(lblPlus);</span><br><span class="line">        add(num2);</span><br><span class="line">        add(btnEqual);</span><br><span class="line">        add(num3);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这个MyMonitor类是内部类，它在MyFrame类里面定义 MyFrame类称为MyMonitor类的包</span></span><br><span class="line"><span class="comment">    装类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用内部类的好处：</span></span><br><span class="line"><span class="comment">     * 第一个巨大的好处就是可以畅通无阻地访问外部类(即内部类的包装类)的所有成员变量和方法</span></span><br><span class="line"><span class="comment">     * 如这里的在MyFrame类(外部类)定义的三个成员变量num1,num2,num3，</span></span><br><span class="line"><span class="comment">     * 在MyMonitor(内部类)里面就可以直接访问</span></span><br><span class="line"><span class="comment">     * 这相当于在创建外部类对象时内部类对象默认就拥有了一个外部类对象的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMonitor</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = Integer.parseInt(num1.getText());</span><br><span class="line">            <span class="keyword">int</span> n2 = Integer.parseInt(num2.getText());</span><br><span class="line">            num3.setText(<span class="string">&quot;&quot;</span> + (n1 + n2));</span><br><span class="line">            num1.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            num2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">内部类带来的巨大好处是：</span><br><span class="line"><span class="number">1.</span> 可以很方便地访问外部类定义的成员变量和方法</span><br><span class="line"><span class="number">2.</span> 当某一个类不需要其他类访问的时候就把这个类声明为内部类。</span><br><span class="line"></span><br><span class="line">八、Graphics 类</span><br><span class="line"></span><br><span class="line">每个Component都有一个paint（Graphics g）用于实现绘图目的，每次重画该Component时都自动调</span><br><span class="line">用paint方法。</span><br><span class="line">Graphics类中提供了许多绘图方法，如：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/HPsz2IjyB4gwtXn.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPaint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyPaint().launchFrame();</span><br><span class="line"><span class="comment">//在main()方法里面并没有显示调用paint(Graphics g)方法</span></span><br><span class="line"><span class="comment">//可是当创建出Frame窗体后却可以看到Frame窗体上画出了圆和矩形</span></span><br><span class="line"><span class="comment">//这是因为paint()方法是一个比较特殊的方法</span></span><br><span class="line"><span class="comment">//在创建Frame窗体时会自动隐式调用</span></span><br><span class="line"><span class="comment">//当我们把Frame窗体最小化又再次打开时</span></span><br><span class="line"><span class="comment">//又会再次调用paint()方法重新把圆和矩形在Frame窗体上画出来</span></span><br><span class="line"><span class="comment">//即每次需要重画Frame窗体的时候就会自动调用paint()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPaint</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchFrame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span>&#123;</span><br><span class="line"><span class="comment">//paint(Graphics g)方法有一个Graphics类型的参数g</span></span><br><span class="line"><span class="comment">//我们可以把这个g当作是一个画家，这个画家手里拿着一只画笔</span></span><br><span class="line"><span class="comment">//我们通过设置画笔的颜色与形状来画出我们想要的各种各样的图像</span></span><br><span class="line">        <span class="comment">/*设置画笔的颜色*/</span></span><br><span class="line">        g.setColor(Color.red);</span><br><span class="line">        g.fillOval(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">/*画一个实心椭圆*/</span></span><br><span class="line">        g.setColor(Color.green);</span><br><span class="line">        g.fillRect(<span class="number">150</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);<span class="comment">/*画一个实心矩形*/</span></span><br><span class="line"><span class="comment">//这下面的两行代码是为了写程序的良好编程习惯而写的</span></span><br><span class="line"><span class="comment">//前面设置了画笔的颜色，现在就应该把画笔的初始颜色恢复过来</span></span><br><span class="line"><span class="comment">//就相当于是画家用完画笔之后把画笔上的颜色清理掉一样</span></span><br><span class="line">        Color c = g.getColor();</span><br><span class="line">        g.setColor(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;gogoogo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/PbgDiyQ1pmx6Gzj.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">九、鼠标事件适配器</span><br><span class="line">抽象类java.awt.event.MouseAdapter实现了MouseListener接口，可以使用其子类作为</span><br><span class="line">MouseEvent的监听器，只要重写其相应的方法即可。</span><br><span class="line">对于其他的监听器，也有对应的适配器。</span><br><span class="line">适用适配器可以避免监听器定义没有必要的空方法。</span><br><span class="line">【测试代码：画点】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMouseAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyFrame(<span class="string">&quot;drawing....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    ArrayList points = <span class="keyword">null</span>;</span><br><span class="line">    MyFrame(String s)&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">        points = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>,<span class="number">255</span>));</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.addMouseListener(<span class="keyword">new</span> Monitor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span>&#123;</span><br><span class="line">        Iterator i = points.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">            Point p = (Point)i.next();</span><br><span class="line">            g.setColor(Color.BLUE);</span><br><span class="line">            g.fillOval(p.x,p.y,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPoint</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">        points.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> <span class="keyword">extends</span> <span class="title">MouseAdapter</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mousePressed</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">            MyFrame frame = (MyFrame) e.getSource();</span><br><span class="line">            frame.addPoint(<span class="keyword">new</span> Point(e.getX(),e.getY()));</span><br><span class="line">            frame.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">十、window事件</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/DVyWEFkLqwlCZc3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWindowClose</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WindowFrame(<span class="string">&quot;关闭WindowFrame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowFrame</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>,<span class="number">255</span>));</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowMonitor());</span><br><span class="line">        <span class="comment">/*监听本窗体的动作，把所有的动作信息封装成一个对象传递到监听类里面*/</span></span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(</span><br><span class="line"><span class="comment">/*在一个方法里面定义一个类，这个类称为局部类，也叫匿名的内部类，</span></span><br><span class="line"><span class="comment">这里的&#123;……代码……&#125;里面的代码很像一个类的类体，只不过这个类没有名字，所以叫匿名类</span></span><br><span class="line"><span class="comment">在这里是把这个匿名类当成WindowAdapter类来使用，语法上这样写的本质意义是相当于这</span></span><br><span class="line"><span class="comment">个匿名类</span></span><br><span class="line"><span class="comment">从WindowAdapter类继承，现在new了一个匿名类的对象出来然后把这个对象当成</span></span><br><span class="line"><span class="comment">WindowAdapter来使用</span></span><br><span class="line"><span class="comment">这个匿名类出了()就没有人认识了*/</span></span><br><span class="line">                <span class="keyword">new</span> WindowAdapter()&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span>&#123;</span><br><span class="line">                        setVisible(<span class="keyword">false</span>);</span><br><span class="line">                        System.exit(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里也是将监听类定义为内部类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WindowMonitor</span> <span class="keyword">extends</span> <span class="title">WindowAdapter</span></span>&#123;</span><br><span class="line">        <span class="comment">/*WindowAdapter(Window适配器)类实现了WindowListener监听接口</span></span><br><span class="line"><span class="comment">        重写了WindowListener接口里面的所有方法</span></span><br><span class="line"><span class="comment">        如果直接使用自定义WindowMonitor类直接去</span></span><br><span class="line"><span class="comment">        实现WindowListener接口，那么就得要重写WindowListener接口</span></span><br><span class="line"><span class="comment">        里面的所有方法，但现在只需要用到这些方法里面的其中一个方法</span></span><br><span class="line"><span class="comment">        所以采用继承实现WindowListener监听接口的一个子类</span></span><br><span class="line"><span class="comment">        并重写这个子类里面需要用到的那个方法即可</span></span><br><span class="line"><span class="comment">        这种做法比直接实现WindowListener监听接口要重写很多个用不到的方法要简洁方便得多</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*重写需要用到的windowClosing(WindowEvent e)方法*/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span>&#123;</span><br><span class="line">            setVisible(<span class="keyword">false</span>);<span class="comment">/*将窗体设置为不显示，即可实现窗体关闭*/</span></span><br><span class="line">            System.exit(<span class="number">0</span>);<span class="comment">/*正常退出*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">十一、键盘响应事件</span><br><span class="line">【键盘响应事件——KeyEvent】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestKeyEvent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> KeyFrame(<span class="string">&quot;键盘响应事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyFrame</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        addKeyListener(<span class="keyword">new</span> KeyMonitor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*把自定义的键盘的监听类定义为内部类</span></span><br><span class="line"><span class="comment">    这个监听类从键盘适配器KeyAdapter类继承</span></span><br><span class="line"><span class="comment">    从KeyAdapter类继承也是为了可以简洁方便</span></span><br><span class="line"><span class="comment">    只需要重写需要用到的方法即可，这种做法比</span></span><br><span class="line"><span class="comment">    直接实现KeyListener接口要简单方便，如果</span></span><br><span class="line"><span class="comment">    直接实现KeyListener接口就要把KeyListener</span></span><br><span class="line"><span class="comment">    接口里面的所有方法重写一遍，但真正用到的</span></span><br><span class="line"><span class="comment">    只有一个方法，这样重写其他的方法但又用不到</span></span><br><span class="line"><span class="comment">    难免会做无用功*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyMonitor</span> <span class="keyword">extends</span> <span class="title">KeyAdapter</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> keycode = e.getKeyCode();</span><br><span class="line">            <span class="comment">/*使用getKeyCode()方法获取按键的虚拟码*/</span></span><br><span class="line"><span class="comment">/*如果获取到的键的虚拟码等于up键的虚拟码</span></span><br><span class="line"><span class="comment">则表示当前按下的键是up键</span></span><br><span class="line"><span class="comment">KeyEvent.VK_UP表示取得up键的虚拟码</span></span><br><span class="line"><span class="comment">键盘中的每一个键都对应有一个虚拟码</span></span><br><span class="line"><span class="comment">这些虚拟码在KeyEvent类里面都被定义为静态常量</span></span><br><span class="line"><span class="comment">所以可以使用“类名.静态常量名”的形式访问得到这些静态常量*/</span></span><br><span class="line">            <span class="keyword">if</span>(keycode == KeyEvent.VK_UP)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你按的是up键&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*键盘的处理事件是这样的：每一个键都对应着一个虚拟的码，</span></span><br><span class="line"><span class="comment">当按下某一个键时，系统就会去找这个键对应的虚拟的码，以此来确定当前按下的是那个键</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Swing</span><br><span class="line">Swing是GUI（图形用户界面）开发工具包，内容有很多，这里会分块编写，但在进阶篇中只编写</span><br><span class="line">Swing中的基本要素，包括容器、组件和布局等，更深入的内容这里就不介绍了。想深入学习的朋友们</span><br><span class="line">可查阅有关资料或图书，比如《Java Swing图形界面开发与案例详解》——清华大学出版社。</span><br><span class="line">早期的AWT（抽象窗口工具包）组件开发的图形用户界面，要依赖本地系统，当把AWT组件开发的</span><br><span class="line">应用程序移植到其他平台的系统上运行时，不能保证其外观风格，因此AWT是依赖于本地系统平台的。</span><br><span class="line">而使用Swing开发的Java应用程序，其界面是不受本地系统平台限制的，也就是说Swing开发的Java应用</span><br><span class="line">程序移植到其他系统平台上时，其界面外观是不会改变的。但要注意的是，虽然Swing提供的组件可以</span><br><span class="line">方便开发Java应用程序，但是Swing并不能取代AWT，在开发Swing程序时通常要借助与AWT的一些对象</span><br><span class="line">来共同完成应用程序的设计。</span><br><span class="line"></span><br><span class="line">一、常用窗体</span><br><span class="line">Swing窗体是Swing的一个组件，同时也是创建图形化用户界面的容器，可以将其它组件放置在窗体容器</span><br><span class="line">中。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> JFrame框架窗体</span><br><span class="line"> JFrame窗体是一个容器，在Swing开发中我们经常要用到，它是Swing程序中各个组件的载体。语法格</span><br><span class="line">式如下：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line">JFrame jf = <span class="keyword">new</span> JFrame(title);</span><br><span class="line"></span><br><span class="line">当然，在开发中更常用的方式是通过继承java.swing.JFrame类创建一个窗体，可通过<span class="keyword">this</span>关键字调用其</span><br><span class="line">方法。</span><br><span class="line">在JFrame对象创建完成后，需要调用getContentPane()方法将窗体转换为容器，然后在容器中添加组件</span><br><span class="line">或设置布局管理器，通常这个容器用来包含和显示组件。如果需要将组件添加至容器，可以使用来自</span><br><span class="line">Container类的add()方法进行设置。至于JPanel容器会在后面提到。</span><br><span class="line">【下面举一个JFrame窗体的例子】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JFrameDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateJFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实例化一个JFrame对象</span></span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;这是一个JFrame窗体&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗体可视</span></span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 设置窗体大小</span></span><br><span class="line">        jf.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line"><span class="comment">// 设置窗体关闭方式</span></span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JFrameDemo().CreateJFrame(); <span class="comment">// 调用CreateJFrame()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/iz7Hp6rQWCAJMgh.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这就是一个<span class="number">500</span>*<span class="number">350</span>的窗体，用的是setSize()方法；</span><br><span class="line">标题为“这是一个JFrame窗体”，在实例化对象时就可以定义；</span><br><span class="line">窗体关闭方式见窗体右上角为“EXIT_ON_CLOSE”；</span><br><span class="line">窗体可视setVisible()方法中的参数为“<span class="keyword">false</span>”或不写setVisible()方法时，此窗体不可见。</span><br><span class="line">常用的窗体关闭方式有四种：</span><br><span class="line">“DO_NOTHING_ON_CLOSE” ：什么也不做就将窗体关闭；</span><br><span class="line">“DISPOSE_ON_CLOSE” ：任何注册监听程序对象后会自动隐藏并释放窗体；</span><br><span class="line">“HIDE_ON_CLOSE” ： 隐藏窗口的默认窗口关闭；</span><br><span class="line">“EXIT_ON_CLOSE”：退出应用程序默认窗口关闭。</span><br><span class="line">【下面再举一个用继承JFrame的方式编写的代码，并加入Container容器及JLabel标签（后面会提到），</span><br><span class="line">来看一下具体的流程。】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.SwingConstants;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">JFrameDemo2</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 可视化</span></span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 大小</span></span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">        <span class="keyword">this</span>.setTitle(<span class="string">&quot;西部开源&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭方式</span></span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"><span class="comment">// 创建一个JLabel标签</span></span><br><span class="line">        JLabel jl = <span class="keyword">new</span> JLabel(<span class="string">&quot;欢迎来到java学习！&quot;</span>);</span><br><span class="line"><span class="comment">// 使标签文字居中</span></span><br><span class="line">        jl.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line"><span class="comment">// 获取一个容器</span></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line"><span class="comment">// 将标签添加至容器</span></span><br><span class="line">        container.add(jl);</span><br><span class="line"><span class="comment">// 设置容器背景颜色</span></span><br><span class="line">        container.setBackground(Color.YELLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JFrameDemo2().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里继承了JFrame类，所以方法中实现时用<span class="keyword">this</span>关键字即可（或直接实现，不加<span class="keyword">this</span>）。</span><br><span class="line"><span class="number">2.</span> JDialog窗体</span><br><span class="line"> JDialog窗体是Swing组件中的对话框，继承了AWT组件中的java.awt.Dialog类。功能是从一个窗体中弹</span><br><span class="line">出另一个窗体。</span><br><span class="line">【下面来看一个实例】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JDialog;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="comment">// 继承JDialog类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDialogDemo</span> <span class="keyword">extends</span> <span class="title">JDialog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个JDialog类对象，指定其父窗体、窗口标题和类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDialogDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> MyJFrame(), <span class="string">&quot;这是一个JDialog窗体&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        container.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;学Java&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JDialogDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这部分内容包含监听器，可自行查阅资料</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyJFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">700</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        container.setLayout(<span class="keyword">null</span>);</span><br><span class="line">        JButton jb = <span class="keyword">new</span> JButton(<span class="string">&quot;点击弹出对话框&quot;</span>); <span class="comment">// 创建按钮</span></span><br><span class="line">        jb.setBounds(<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">50</span>); <span class="comment">// 按钮位置及大小</span></span><br><span class="line">        jb.addActionListener(<span class="keyword">new</span> ActionListener() &#123; <span class="comment">// 监听器，用于监听点击事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> JDialogDemo().setVisible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        container.add(jb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当我们点击按钮时，触发点击事件，创建一个JDialog的实例化对象，弹出一个窗口。这里出现了许多我</span><br><span class="line">们之前学过的知识，比如<span class="keyword">super</span>关键字，在之前提到过，这里相当于使用了JDialog(Frame f, String title,</span><br><span class="line"><span class="keyword">boolean</span> model)形式的构造方法；监听器的实现就是一个匿名内部类，之前也提到过。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二、标签组件</span><br><span class="line">在Swing中显示文本或提示信息的方法是使用标签，它支持文本字符串和图标。上面我们提到的</span><br><span class="line">JLabel就是这里的内容。</span><br><span class="line"><span class="number">1.</span> 标签</span><br><span class="line">标签由JLabel类定义，可以显示一行只读文本、一个图像或带图像的文本。</span><br><span class="line">JLabel类提供了许多构造方法，可查看API选择需要的使用，如显示只有文本的标签、只有图标的标签或</span><br><span class="line">包含文本与图标的标签等。因为上面已经出现过了，这里就不再举例了。常用语法格式如下，创建的是</span><br><span class="line">一个不带图标和文本的JLabel对象：</span><br><span class="line"></span><br><span class="line"> JLabel jl = <span class="keyword">new</span> JLabel();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/HKOjhDsJluk2bZM.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> 图标</span><br><span class="line"> Swing中的图标可以放置在按钮、标签等组件上，用于描述组件的用途。图标可以用Java支持的图片文</span><br><span class="line">件类型进行创建，也可以使用java.awt.Graphics类提供的功能方法来创建。</span><br><span class="line">在Swing中通过Icon接口来创建图标，可以在创建时给定图标的大小、颜色等特性。</span><br><span class="line">注意，Icon是接口，在使用Icon接口的时候，必须实现Icon接口的三个方法：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconWidth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintIcon</span><span class="params">(Component arg0, Graphics arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">前两个方法用于获取图片的长宽，<span class="title">paintIcon</span><span class="params">()</span>方法用于实现在指定坐标位置画图。</span></span><br><span class="line"><span class="function">下面看一个用Icon接口创建图标的实例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">代码示例:</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.awt.Component</span>;</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Icon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.SwingConstants;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IconDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width; <span class="comment">// 声明图标的宽</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height; <span class="comment">// 声明图标的长</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IconDemo</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 定义无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IconDemo</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123; <span class="comment">// 定义有参构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconHeight</span><span class="params">()</span> </span>&#123; <span class="comment">// 实现getIconHeight()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconWidth</span><span class="params">()</span> </span>&#123; <span class="comment">// 实现getIconWidth()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintIcon</span><span class="params">(Component arg0, Graphics arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 实现paintIcon()方法</span></span><br><span class="line">        arg1.fillOval(arg2, arg3, width, height); <span class="comment">// 绘制一个圆形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">// 定义一个方法用于实现界面</span></span><br><span class="line">        IconDemo iconDemo = <span class="keyword">new</span> IconDemo(<span class="number">15</span>, <span class="number">15</span>); <span class="comment">// 定义图标的长和宽</span></span><br><span class="line">        JLabel jb = <span class="keyword">new</span> JLabel(<span class="string">&quot;icon测试&quot;</span>, iconDemo, SwingConstants.CENTER);</span><br><span class="line"><span class="comment">// 设置标签上的文字在标签正中间</span></span><br><span class="line">        Container container = getContentPane();</span><br><span class="line">        container.add(jb);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> IconDemo().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/D9yF8Q5i7pELJPw.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这样如果需要在窗体中使用图标，就可以用如下代码创建图标：</span><br><span class="line">IconDemo iconDemo = <span class="keyword">new</span> IconDemo(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 图片图标</span><br><span class="line">Swing中的图标除了可以绘制之外，还可以使用某个特定的图片创建。利用javax.swing.ImageIcon类根</span><br><span class="line">据现有图片创建图标。</span><br><span class="line">下面看一个实例，我们先在包下放一个图片（注意放置位置，不同位置路径不同），如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/GhQ5KgiYMn7W8jc.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Icon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.SwingConstants;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageIconDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageIconDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JLabel jl = <span class="keyword">new</span> JLabel(<span class="string">&quot;这是一个JFrame窗体，旁边是一个图片&quot;</span>);</span><br><span class="line">        URL url = ImageIconDemo.class.getResource(&quot;猫咪.jpg&quot;); //获得图片所在URL</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(url); <span class="comment">// 实例化Icon对象</span></span><br><span class="line">        jl.setIcon(icon); <span class="comment">// 为标签设置图片</span></span><br><span class="line">        jl.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line">        jl.setOpaque(<span class="keyword">true</span>); <span class="comment">// 设置标签为不透明状态</span></span><br><span class="line">        Container container = getContentPane();</span><br><span class="line">        container.add(jl);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ImageIconDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/nDhj1MXrqy8C3Bt.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于图片标签，我们经常将图片放置在标签上，用JLabel中的setIcon()方法即可，当然也可以在初始化</span><br><span class="line">JLabel对象时为标签指定图标，这需要获取一个Icon实例。</span><br><span class="line">而getResource()方法可以获得资源文件的URL路径，这里的路径是相对于前面的那个类的，所以可将该</span><br><span class="line">图片与该类放在同一个文件夹下；如果不在同一个文件夹下，需通过其它方法获取路径。</span><br><span class="line"></span><br><span class="line">三、布局管理器</span><br><span class="line"> Swing中，每个组件在容器中都有一个具体的位置和大小，在容器中摆放各自组件时很难判断其具体位</span><br><span class="line">置和大小，这里我们就要引入布局管理器了，它提供了基本的布局功能，可以有效的处理整个窗体的布</span><br><span class="line">局。常用的布局管理器包括流布局管理器、边界布局管理器、网格布局管理器等。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 绝对布局</span><br><span class="line">绝对布局在上一篇的例子中已经出现过了，是硬性指定组件在容器中的位置和大小，可以使用绝对坐标</span><br><span class="line">的方式来指定组件的位置。步骤如下：</span><br><span class="line"><span class="number">1.</span> 使用Container.setLayout(<span class="keyword">null</span>)方法取消布局管理器</span><br><span class="line"><span class="number">2.</span> 使用Container.setBounds()方法设置每个组件的位置和大小</span><br><span class="line"></span><br><span class="line">【举一个简单的例子】</span><br><span class="line">Container container = getContentPane(); <span class="comment">// 创建容器</span></span><br><span class="line">JButton jb = <span class="keyword">new</span> JButton(<span class="string">&quot;按钮&quot;</span>); <span class="comment">// 创建按钮</span></span><br><span class="line">jb.setBounds(<span class="number">10</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">30</span>); <span class="comment">// 设置按钮位置和大小</span></span><br><span class="line">container.add(jb); <span class="comment">// 将按钮添加到容器中</span></span><br><span class="line"></span><br><span class="line">setBounds()方法中，前两个参数是位置的xy坐标，后两个参数是按钮的长和宽。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 流布局管理器</span><br><span class="line">流布局管理器是布局管理器中最基本的布局管理器，使用FlowLayout类，像“流”一样从左到右摆放</span><br><span class="line">组件，直到占据了这一行的所有空间，再向下移动一行。组件在每一行的位置默认居中排列，要更改位</span><br><span class="line">置可自行设置。</span><br><span class="line">在FlowLayout的有参构造方法中，alignment设置为<span class="number">0</span>时，每一行的组件将被指定左对齐排列；当</span><br><span class="line">alignment被设置为<span class="number">2</span>时，每一行的组件将被指定右对齐排列；而为<span class="number">1</span>时是默认的居中排列。</span><br><span class="line">下面举个例子，创建<span class="number">10</span>个按钮并用流布局管理器排列。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.awt.FlowLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlowLayoutDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowLayoutDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line"><span class="comment">// 设置流布局管理器，2是右对齐，后两个参数分别为组件间的水平间隔和垂直间隔</span></span><br><span class="line">        <span class="keyword">this</span>.setLayout(<span class="keyword">new</span> FlowLayout(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 循环添加按钮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            container.add(<span class="keyword">new</span> JButton(<span class="string">&quot;按钮&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FlowLayoutDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第一个参数为<span class="number">2</span>是右对齐，每个按钮间的水平、垂直间隔都为<span class="number">10</span>。后两个图分别为参数为<span class="number">1</span>居中排列和参</span><br><span class="line">数为<span class="number">0</span>左对齐。运行结果如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/NBREZMXVo9cWlfS.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span> 边界布局管理器</span><br><span class="line">在不指定窗体布局时，Swing组件默认的布局管理器是边界布局管理器，使用的是BorderLayout类。在</span><br><span class="line">上篇例子中，一个JLabel标签占据了整个空间，实质上是默认使用了边界布局管理器。边界布局管理器</span><br><span class="line">还可以容器分为东、南、西、北、中五个区域，可以将组件加入这五个区域中。</span><br><span class="line">【演示】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorderLayoutDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] border = &#123;BorderLayout.CENTER, BorderLayout.NORTH,</span><br><span class="line">            BorderLayout.SOUTH, BorderLayout.WEST, BorderLayout.EAST&#125;; <span class="comment">// 此数组用于存放组件摆放位置</span></span><br><span class="line">    <span class="keyword">private</span> String[] button = &#123;<span class="string">&quot;中&quot;</span>, <span class="string">&quot;北&quot;</span>, <span class="string">&quot;南&quot;</span>, <span class="string">&quot;西&quot;</span>, <span class="string">&quot;东&quot;</span>&#125;; <span class="comment">// 此数组用于存放按钮名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BorderLayoutDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        <span class="keyword">this</span>.setLayout(<span class="keyword">new</span> BorderLayout()); <span class="comment">// 设置容器为边界布局管理器</span></span><br><span class="line"><span class="comment">// 循环添加按钮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;button.length ; i++) &#123;</span><br><span class="line">            container.add(border[i], <span class="keyword">new</span> JButton(button[i])); <span class="comment">// 左参数为设置布局，右参数为创建按钮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BorderLayoutDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/A5ckvqPNfwg8olm.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span> 网格布局管理器</span><br><span class="line">网格布局管理器将容器划分为网格，组件按行按列排列，使用GridLayout类。在此布局管理器中，每个</span><br><span class="line">组件的大小都相同，且会填满整个网格，改变窗体大小，组件也会随之改变。</span><br><span class="line">【演示】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.awt.GridLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirdLayoutDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GirdLayoutDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        <span class="keyword">this</span>.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// 前两个参数为7行3列，后两个参数为网格间的间距</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++) &#123;</span><br><span class="line">            container.add(<span class="keyword">new</span> JButton(<span class="string">&quot;按钮&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GirdLayoutDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/OjStfDKC4lBGgwu.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">四、面板</span><br><span class="line">面板也是一个容器，可作为容器容纳其他组件，但也必须被添加到其他容器中。Swing中常用面板有</span><br><span class="line">JPanel面板和JScrollPane面板。</span><br><span class="line"><span class="number">1.</span> JPanel</span><br><span class="line">JPanel面板可以聚集一些组件来布局。继承自java.awt.Container类。</span><br><span class="line">【演示】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> java.awt.GridLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPanelDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JPanelDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        container.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 整个容器为2行1列</span></span><br><span class="line">        JPanel p1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 初始化一个面板，设置1行3列的网格布局</span></span><br><span class="line">        JPanel p2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 初始化一个面板，设置1行2列的网格布局</span></span><br><span class="line">        JPanel p3 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>, <span class="number">1</span>)); <span class="comment">// 初始化一个面板，设置2行1列的网格布局</span></span><br><span class="line">        JPanel p4 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 初始化一个面板，设置3行2列的网格布局</span></span><br><span class="line">        p1.add(<span class="keyword">new</span> JButton(<span class="string">&quot;1&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p1.add(<span class="keyword">new</span> JButton(<span class="string">&quot;1&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p1.add(<span class="keyword">new</span> JButton(<span class="string">&quot;1&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p2.add(<span class="keyword">new</span> JButton(<span class="string">&quot;2&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p2.add(<span class="keyword">new</span> JButton(<span class="string">&quot;2&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p3.add(<span class="keyword">new</span> JButton(<span class="string">&quot;3&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p3.add(<span class="keyword">new</span> JButton(<span class="string">&quot;3&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        p4.add(<span class="keyword">new</span> JButton(<span class="string">&quot;4&quot;</span>)); <span class="comment">// 在JPanel面板中添加按钮</span></span><br><span class="line">        container.add(p1); <span class="comment">// 在容器中添加面板</span></span><br><span class="line">        container.add(p2); <span class="comment">// 在容器中添加面板</span></span><br><span class="line">        container.add(p3); <span class="comment">// 在容器中添加面板</span></span><br><span class="line">        container.add(p4); <span class="comment">// 在容器中添加面板</span></span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JPanelDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下，可自行对比代码与结果理解JPanel。其中，容器的GridLayout布局设置了横纵都为<span class="number">10</span>的</span><br><span class="line">间距，JPanel的GridLayout布局没有设置网格间距。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/wM8aFt1y2eox5OD.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> JScrollPane</span><br><span class="line">若遇到一个较小的容器窗体中显示一个较大部分内容的情况，可用JScrollPane面板。这是一个带滚</span><br><span class="line">动条的面板，就像平时浏览网页，经常遇到的滚动条一样。</span><br><span class="line">如果需要在JScrollPane面板中放置多个组件，需将这多个组件放置在JPanel面板上，然后将JPanel</span><br><span class="line">面板作为一个整体组件添加在JScrollPane面板上。</span><br><span class="line">【演示】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.awt.Container;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JScrollPane;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"><span class="keyword">import</span> javax.swing.WindowConstants;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JScrollPaneDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JScrollPaneDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        JTextArea tArea = <span class="keyword">new</span> JTextArea(<span class="number">20</span>, <span class="number">50</span>); <span class="comment">// 创建文本区域组件</span></span><br><span class="line">        tArea.setText(<span class="string">&quot;欢迎学Java&quot;</span>);</span><br><span class="line">        JScrollPane sp = <span class="keyword">new</span> JScrollPane(tArea);</span><br><span class="line">        container.add(sp);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JScrollPaneDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/03/kX8CA2r69KYUicT.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中JTextArea是创建一个文本区域组件，大小为<span class="number">20</span>*<span class="number">50</span>，setText()方法是给该文本区域填值。这里在</span><br><span class="line"><span class="keyword">new</span>一个JScrollPane时，就将文本区域组件添加到其上。</span><br><span class="line">五、按钮组件</span><br><span class="line"><span class="number">1.</span> 提交按钮组件（JButton）</span><br><span class="line"> JButton在之前的例子中已经出现多次，是较为常用的组件，用于触发特定动作。可以在按钮上显示文</span><br><span class="line">本标签，还可以显示图标，如下：</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;风景.jpg&quot;));</span><br><span class="line">        JButton jb = <span class="keyword">new</span> JButton();</span><br><span class="line">        jb.setIcon(icon); <span class="comment">// 设置图标</span></span><br><span class="line">        jb.setToolTipText(<span class="string">&quot;图片按钮&quot;</span>); <span class="comment">// 设置按钮提示</span></span><br><span class="line">        container.add(jb);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> 单选按钮组件（JRadioButton）</span><br><span class="line">默认情况下，单选按钮显示一个圆形图标，通常在其旁放置一些说明性文字。当用户选中某个单选按钮</span><br><span class="line">后，按钮组中其它按钮将被自动取消，这时就需要按钮组（ButtonGroup）来将同组按钮放在一起，该</span><br><span class="line">按钮组中的按钮只能选择一个，而不在此按钮中的按钮不受影响。语法格式如下：</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;风景.jpg&quot;));</span><br><span class="line"><span class="comment">//单选框</span></span><br><span class="line">        JRadioButton jr1 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;JRadioButton1&quot;</span>);</span><br><span class="line">        JRadioButton jr2 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;JRadioButton2&quot;</span>);</span><br><span class="line">        JRadioButton jr3 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;JRadioButton3&quot;</span>);</span><br><span class="line"><span class="comment">//按钮组，单选框只能选择一个</span></span><br><span class="line">        ButtonGroup group = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        group.add(jr1);</span><br><span class="line">        group.add(jr2);</span><br><span class="line">        group.add(jr3);</span><br><span class="line">        container.add(jr1,BorderLayout.CENTER);</span><br><span class="line">        container.add(jr2,BorderLayout.NORTH);</span><br><span class="line">        container.add(jr3,BorderLayout.SOUTH);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span> 复选框组件（JCheckBox）</span><br><span class="line">复选框是一个方块图标，外加一段描述性文字，与单选按钮的区别就是可以多选。每一个复选框都提供</span><br><span class="line">“选中”与“不选中”两种状态。语法格式如下：</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;tx-old.jpg&quot;));</span><br><span class="line"><span class="comment">//多选框</span></span><br><span class="line">        JCheckBox jrb = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        JCheckBox jrb2 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        container.add(jrb);</span><br><span class="line">        container.add(jrb2,BorderLayout.NORTH);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">六、列表组件</span><br><span class="line"><span class="number">1.</span> 下拉列表（JComboBox）</span><br><span class="line">下拉列表框使用JComboBox类对象来表示，如下方代码：</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;tx-old.jpg&quot;));</span><br><span class="line">        JComboBox status = <span class="keyword">new</span> JComboBox();</span><br><span class="line">        status.addItem(<span class="keyword">null</span>);</span><br><span class="line">        status.addItem(<span class="string">&quot;正在上映&quot;</span>);</span><br><span class="line">        status.addItem(<span class="string">&quot;即将上映&quot;</span>);</span><br><span class="line">        status.addItem(<span class="string">&quot;下架&quot;</span>);</span><br><span class="line">        container.add(status);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> 列表框（JList）</span><br><span class="line">列表框只是在窗体上占据固定的大小，如果要使列表框具有滚动效果，可以将列表框放入滚动面板中。</span><br><span class="line">使用数组初始化列表框的参数如下</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;tx-old.jpg&quot;));</span><br><span class="line"><span class="comment">//使用数组初始化列表框的参数如下。</span></span><br><span class="line">        String[] contents = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        JList jl = <span class="keyword">new</span> JList(contents);</span><br><span class="line">        container.add(jl);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将Vector类型的数据作为初始化JList的参数如下。</span><br><span class="line"></span><br><span class="line">代码示例:(空指针异常)</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        Icon icon = <span class="keyword">new</span> ImageIcon(Demo.class.getResource(&quot;tx-old.jpg&quot;));</span><br><span class="line"><span class="comment">//将Vector类型的数据作为初始化JList的参数如下</span></span><br><span class="line">        Vector contents = <span class="keyword">new</span> Vector();</span><br><span class="line">        JList jl = <span class="keyword">new</span> JList(contents);</span><br><span class="line">        contents.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        contents.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        contents.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        container.add(jl);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">500</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">七、文本组件</span><br><span class="line"><span class="number">1.</span> 文本框（JTextField）</span><br><span class="line">文本框用来显示或编辑一个单行文本，语法格式如下：</span><br><span class="line">JTextField jt = <span class="keyword">new</span> JTextField(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 创建一个文本框，值为aaa</span></span><br><span class="line">JTextField jt2 = <span class="keyword">new</span> JTextField(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>); <span class="comment">// 创建一个长度为20的文本框，值为</span></span><br><span class="line">aaa</span><br><span class="line">jt.setText(<span class="string">&quot;&quot;</span>); <span class="comment">// 将文本框置空</span></span><br><span class="line"></span><br><span class="line">其余构造方法可参考API或源码。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 密码框（JPasswordField）</span><br><span class="line">密码框与文本框的定义与用法类似，但会使用户输入的字符串以某种符号进行加密。如下方代码：</span><br><span class="line">JPasswordField jp = <span class="keyword">new</span> JPasswordField();</span><br><span class="line">jp.setEchoChar(<span class="string">&#x27;#&#x27;</span>); <span class="comment">// 设置回显符号</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 文本域（JTextArea）</span><br><span class="line">文本域组件在上面的代码中已经出现了，如下方代码所示：</span><br><span class="line">JTextArea tArea = <span class="keyword">new</span> JTextArea(<span class="number">20</span>, <span class="number">50</span>); <span class="comment">// 创建文本区域组件</span></span><br><span class="line">tArea.setText(<span class="string">&quot;欢迎来到西部开源学Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">我们对GUI编程就讲到这里了，授人以鱼不如授人以渔，相信大家经过这一小段的学习已经能掌握看方</span><br><span class="line">法和源码学习的能力了，之后我们会有一些小游戏专题来巩固我们JavaSE阶段的学习。</span><br><span class="line"></span><br><span class="line">小游戏：<span class="number">2048</span></span><br><span class="line">思路：</span><br><span class="line">使用了<span class="number">4</span>x4的GridLayout作为布局，然后使用<span class="number">16</span>个JLabel作为方块ui。数据上则是使用一个长度为<span class="number">16</span>的</span><br><span class="line"><span class="keyword">int</span>数组储存方块的数值，通过监听上下左右的按键进行相应的数据处理，最后通过刷新函数将数据显示</span><br><span class="line">出来并设置颜色。这里提一下胜负判定的实现，胜的判定很简单，就是玩家凑出了至少一个<span class="number">2048</span>的方块</span><br><span class="line">即为胜利，而失败的判定思路略复杂，主要是通过模拟用户分别按下上、下、左、右键后，判断格子里</span><br><span class="line">是否还有空位，如分别向四个方向移动后都无法产生空位，则判负。</span><br><span class="line"></span><br><span class="line">【Game类】</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.小游戏<span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class game &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyListener;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于储存颜色的实体类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Color</span><span class="params">(<span class="keyword">int</span> fc, <span class="keyword">int</span> bgc)</span> </span>&#123;</span><br><span class="line">            fontColor = fc;<span class="comment">//字体颜色</span></span><br><span class="line">            bgColor = bgc;<span class="comment">//背景颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> fontColor;<span class="comment">//字体颜色</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> bgColor;<span class="comment">//背景颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    JFrame mainFrame;<span class="comment">//主窗口对象</span></span><br><span class="line">    JLabel[] jLabels;<span class="comment">//方块，用jlabel代替</span></span><br><span class="line">    <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//每个方块上的数值</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//方块移动算法中抽离的的临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>];<span class="comment">//用于检测方块是否有合并</span></span><br><span class="line">    List emptyBlocks = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">16</span>);<span class="comment">//在生成新方块时用到的临时list，用以存放空方块</span></span><br><span class="line">    <span class="comment">//存放颜色的map</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Integer, Color&gt; colorMap = <span class="keyword">new</span> HashMap&lt;Integer, Color&gt;()</span><br><span class="line">    &#123;&#123;</span><br><span class="line">        put(<span class="number">0</span>, <span class="keyword">new</span> Color(<span class="number">0x776e65</span>, <span class="number">0xCDC1B4</span>));</span><br><span class="line">        put(<span class="number">2</span>, <span class="keyword">new</span> Color(<span class="number">0x776e65</span>, <span class="number">0xeee4da</span>));</span><br><span class="line">        put(<span class="number">4</span>, <span class="keyword">new</span> Color(<span class="number">0x776e65</span>, <span class="number">0xede0c8</span>));</span><br><span class="line">        put(<span class="number">8</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xf2b179</span>));</span><br><span class="line">        put(<span class="number">16</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xf59563</span>));</span><br><span class="line">        put(<span class="number">32</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xf67c5f</span>));</span><br><span class="line">        put(<span class="number">64</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xf65e3b</span>));</span><br><span class="line">        put(<span class="number">128</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xedcf72</span>));</span><br><span class="line">        put(<span class="number">256</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xedcc61</span>));</span><br><span class="line">        put(<span class="number">512</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xe4c02a</span>));</span><br><span class="line">        put(<span class="number">1024</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xe2ba13</span>));</span><br><span class="line">        put(<span class="number">2048</span>, <span class="keyword">new</span> Color(<span class="number">0xf9f6f2</span>, <span class="number">0xecc400</span>));</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initGameFrame();</span><br><span class="line">        initGame();</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开局时生成两个2的方块和一个4的方块</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            generateBlock(datas, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        generateBlock(datas, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机生成4或者2的方块</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomGenerate</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ran = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (ran &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            generateBlock(arr, <span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            generateBlock(arr, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机生成新的方块，参数：要生成的方块数值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBlock</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        emptyBlocks.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                emptyBlocks.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = emptyBlocks.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>) % len;</span><br><span class="line">        arr[(<span class="keyword">int</span>) emptyBlocks.get(pos)] = num;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//胜负判定并做终局处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isWin(arr)) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">&quot;恭喜，你已经成功凑出2048的方 块&quot;</span>, <span class="string">&quot;你赢了&quot;</span>, JOptionPane.PLAIN_MESSAGE);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEnd(arr)) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = getMax(datas);</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">&quot;抱歉，你没有凑出2048的方块,你 的最大方块是：&quot;</span> + max, <span class="string">&quot;游戏结束&quot;</span>, JOptionPane.PLAIN_MESSAGE);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断玩家是否胜利，只要有一个方块大于等于2048即为胜利</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWin</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2048</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//此函数用于判断游戏是否结束，如上下左右移后均无法产生空块，即代表方块已满，则返回真，表示游戏结束</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">int</span> isend = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        left(tmp);</span><br><span class="line">        <span class="keyword">if</span> (isNoBlank(tmp)) &#123;</span><br><span class="line">            isend++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        right(tmp);</span><br><span class="line">        <span class="keyword">if</span> (isNoBlank(tmp)) &#123;</span><br><span class="line">            isend++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        up(tmp);</span><br><span class="line">        <span class="keyword">if</span> (isNoBlank(tmp)) &#123;</span><br><span class="line">            isend++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        down(tmp);</span><br><span class="line">        <span class="keyword">if</span> (isNoBlank(tmp)) &#123;</span><br><span class="line">            isend++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isend == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否无空方块</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNoBlank</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最大的方块数值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= max) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//刷新每个方块显示的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JLabel j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> arr = datas[i];</span><br><span class="line">            j = jLabels[i];</span><br><span class="line">            <span class="keyword">if</span> (arr == <span class="number">0</span>) &#123;</span><br><span class="line">                j.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr &gt;= <span class="number">1024</span>) &#123;</span><br><span class="line">                j.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;Dialog&quot;</span>, <span class="number">1</span>, <span class="number">42</span>));</span><br><span class="line">                j.setText(String.valueOf(datas[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;Dialog&quot;</span>, <span class="number">1</span>, <span class="number">50</span>));</span><br><span class="line">                j.setText(String.valueOf(arr));</span><br><span class="line">            &#125;</span><br><span class="line">            Color currColor = colorMap.get(arr);</span><br><span class="line">            j.setBackground(<span class="keyword">new</span> java.awt.Color(currColor.bgColor));</span><br><span class="line">            j.setForeground(<span class="keyword">new</span> java.awt.Color(currColor.fontColor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化游戏窗口，做一些繁杂的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGameFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建JFrame以及做一些设置</span></span><br><span class="line">        mainFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;2048 Game&quot;</span>);</span><br><span class="line">        mainFrame.setSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">        mainFrame.setResizable(<span class="keyword">false</span>);<span class="comment">//固定窗口尺寸</span></span><br><span class="line">        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        mainFrame.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        mainFrame.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">        mainFrame.getContentPane().setBackground(<span class="keyword">new</span></span><br><span class="line">                java.awt.Color(<span class="number">0xCDC1B4</span>));</span><br><span class="line"><span class="comment">//添加按键监听</span></span><br><span class="line">        mainFrame.addKeyListener(<span class="keyword">new</span> KeyListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyTyped</span><span class="params">(KeyEvent keyEvent)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent keyEvent)</span> </span>&#123;</span><br><span class="line">                System.arraycopy(datas, <span class="number">0</span>, temp2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">//根据按键的不同调用不同的处理函数</span></span><br><span class="line">                <span class="keyword">switch</span> (keyEvent.getKeyCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_UP:</span><br><span class="line">                        up(datas);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_DOWN:</span><br><span class="line">                        down(datas);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_LEFT:</span><br><span class="line">                        left(datas);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_RIGHT:</span><br><span class="line">                        right(datas);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//判断移动后是否有方块合并，若有，生成新方块，若无，不产生新方块</span></span><br><span class="line">                <span class="keyword">if</span> (!Arrays.equals(datas, temp2)) &#123;</span><br><span class="line">                    randomGenerate(datas);</span><br><span class="line">                &#125;</span><br><span class="line">                refresh();</span><br><span class="line">                judge(datas);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent keyEvent)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//使用系统默认的ui风格</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//使用16个JLabel来显示16个方块</span></span><br><span class="line">        jLabels = <span class="keyword">new</span> JLabel[<span class="number">16</span>];</span><br><span class="line">        JLabel j; <span class="comment">//引用复用，避免for里创建过多引用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            jLabels[i] = <span class="keyword">new</span> JLabel(<span class="string">&quot;0&quot;</span>, JLabel.CENTER);</span><br><span class="line">            j = jLabels[i];</span><br><span class="line">            j.setOpaque(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 设置边界，参数：上，左，下，右，边界颜色</span></span><br><span class="line">            j.setBorder(BorderFactory.createMatteBorder(<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="keyword">new</span></span><br><span class="line">                    java.awt.Color(<span class="number">0xBBADA0</span>)));</span><br><span class="line"><span class="comment">//j.setForeground(new java.awt.Color(0x776E65));</span></span><br><span class="line">            j.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;Dialog&quot;</span>, <span class="number">1</span>, <span class="number">52</span>));</span><br><span class="line">            mainFrame.add(j);</span><br><span class="line">        &#125;</span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        moveLeft(arr);</span><br><span class="line">        combineLeft(arr);</span><br><span class="line">        moveLeft(arr);<span class="comment">//合并完后会产生空位，所以要再次左移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左合并方块</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineLeft</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line"><span class="comment">//0 1 2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[l * <span class="number">4</span> + i] != <span class="number">0</span> &amp;&amp; arr[l * <span class="number">4</span> + i + <span class="number">1</span>] != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        arr[l * <span class="number">4</span> + i] == arr[l * <span class="number">4</span> + i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[l * <span class="number">4</span> + i] *= <span class="number">2</span>;</span><br><span class="line">                    arr[l * <span class="number">4</span> + i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方块左移，针对每一行利用临时数组实现左移</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveLeft</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = <span class="number">0</span>, fz = <span class="number">0</span>;<span class="comment">//z(零）;fz（非零）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[l * <span class="number">4</span> + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    z++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp[fz] = arr[l * <span class="number">4</span> + i];</span><br><span class="line">                    fz++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fz; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                temp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                arr[l * <span class="number">4</span> + j] = temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        moveRight(arr);</span><br><span class="line">        combineRight(arr);</span><br><span class="line">        moveRight(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineRight</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line"><span class="comment">//3 2 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[l * <span class="number">4</span> + i] != <span class="number">0</span> &amp;&amp; arr[l * <span class="number">4</span> + i - <span class="number">1</span>] != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        arr[l * <span class="number">4</span> + i] == arr[l * <span class="number">4</span> + i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[l * <span class="number">4</span> + i] *= <span class="number">2</span>;</span><br><span class="line">                    arr[l * <span class="number">4</span> + i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveRight</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = <span class="number">3</span>, fz = <span class="number">3</span>;<span class="comment">//z(零）;fz（非零）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[l * <span class="number">4</span> + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    z--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp[fz] = arr[l * <span class="number">4</span> + i];</span><br><span class="line">                    fz--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fz; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                temp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                arr[l * <span class="number">4</span> + j] = temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        moveUp(arr);</span><br><span class="line">        combineUp(arr);</span><br><span class="line">        moveUp(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineUp</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[r + <span class="number">4</span> * i] != <span class="number">0</span> &amp;&amp; arr[r + <span class="number">4</span> * (i + <span class="number">1</span>)] != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        arr[r + <span class="number">4</span> * i] == arr[r + <span class="number">4</span> * (i + <span class="number">1</span>)]) &#123;</span><br><span class="line">                    arr[r + <span class="number">4</span> * i] *= <span class="number">2</span>;</span><br><span class="line">                    arr[r + <span class="number">4</span> * (i + <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveUp</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = <span class="number">0</span>, fz = <span class="number">0</span>;<span class="comment">//z(零）;fz（非零）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[r + <span class="number">4</span> * i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    z++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp[fz] = arr[r + <span class="number">4</span> * i];</span><br><span class="line">                    fz++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fz; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                temp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                arr[r + <span class="number">4</span> * j] = temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        moveDown(arr);</span><br><span class="line">        combineDown(arr);</span><br><span class="line">        moveDown(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineDown</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[r + <span class="number">4</span> * i] != <span class="number">0</span> &amp;&amp; arr[r + <span class="number">4</span> * (i - <span class="number">1</span>)] != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        arr[r + <span class="number">4</span> * i] == arr[r + <span class="number">4</span> * (i - <span class="number">1</span>)]) &#123;</span><br><span class="line">                    arr[r + <span class="number">4</span> * i] *= <span class="number">2</span>;</span><br><span class="line">                    arr[r + <span class="number">4</span> * (i - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveDown</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = <span class="number">3</span>, fz = <span class="number">3</span>;<span class="comment">//z(零）;fz（非零）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[r + <span class="number">4</span> * i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    z--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp[fz] = arr[r + <span class="number">4</span> * i];</span><br><span class="line">                    fz--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fz; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                temp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                arr[r + <span class="number">4</span> * j] = temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【StartFrame类】</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.小游戏<span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class StartFrame &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartFrame</span> </span>&#123;</span><br><span class="line">    JFrame mainFrame;</span><br><span class="line">    <span class="keyword">final</span> String gameRule = <span class="string">&quot;2048游戏共有16个格子，开始时会随机生成两个数值为2的方块和一个数值为4的方块，\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;玩家可通过键盘上的上、下、左、右方向键来操控方块的滑动方向，\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;每按一次方向键，所有的方块会向一个方向靠拢，相同数值的方块将会相加并合并成一个方块，\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;此外，每滑动一次将会随机生成一个数值为2或者4的方块，\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;玩家需要想办法在这16个格子里凑出2048数值的方块，若16个格子被填满且无法再移动，\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;则游戏结束。&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StartFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initFrame();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;2048 Game&quot;</span>);</span><br><span class="line">        mainFrame.setSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">        mainFrame.setResizable(<span class="keyword">false</span>);<span class="comment">//固定窗口尺寸</span></span><br><span class="line">        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        mainFrame.setLocationRelativeTo(<span class="keyword">null</span>);<span class="comment">//窗口居中</span></span><br><span class="line">        JPanel jPanel = <span class="keyword">new</span> JPanel();</span><br><span class="line"><span class="comment">//BoxLayout.Y_AXIS是指定从上到下垂直布置组件。</span></span><br><span class="line">        jPanel.setLayout(<span class="keyword">new</span> BoxLayout(jPanel, BoxLayout.Y_AXIS));</span><br><span class="line">        jPanel.add(newLine(Box.createVerticalStrut(<span class="number">25</span>)));<span class="comment">//添加空白区域</span></span><br><span class="line">        JLabel jLabel = <span class="keyword">new</span> JLabel(<span class="string">&quot;2048&quot;</span>);</span><br><span class="line">        jLabel.setForeground(<span class="keyword">new</span> Color(<span class="number">0x776e65</span>));</span><br><span class="line">        jLabel.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;Dialog&quot;</span>, <span class="number">1</span>, <span class="number">92</span>));</span><br><span class="line">        jPanel.add(newLine(jLabel));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JLabel author = new JLabel(&quot;by xxx&quot;);</span></span><br><span class="line"><span class="comment">jPanel.add(newLine(author));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        jPanel.add(newLine(Box.createVerticalStrut(<span class="number">50</span>)));</span><br><span class="line">        JButton btn1 = <span class="keyword">new</span> JButton(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        btn1.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> Game();</span><br><span class="line">                mainFrame.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jPanel.add(newLine(btn1));</span><br><span class="line">        jPanel.add(newLine(Box.createVerticalStrut(<span class="number">50</span>)));</span><br><span class="line">        JButton btn2 = <span class="keyword">new</span> JButton(<span class="string">&quot;游戏规则&quot;</span>);</span><br><span class="line">        btn2.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, gameRule, <span class="string">&quot;游戏规则&quot;</span>,</span><br><span class="line">                        JOptionPane.PLAIN_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jPanel.add(newLine(btn2));</span><br><span class="line">        jPanel.add(newLine(Box.createVerticalStrut(<span class="number">50</span>)));</span><br><span class="line">        JButton btn3 = <span class="keyword">new</span> JButton(<span class="string">&quot;退出游戏&quot;</span>);</span><br><span class="line">        btn3.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jPanel.add(newLine(btn3));</span><br><span class="line">        mainFrame.add(jPanel);</span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加新一行垂直居中的控件，通过在控件两边填充glue对象实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JPanel <span class="title">newLine</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel();</span><br><span class="line">        jp.setLayout(<span class="keyword">new</span> BoxLayout(jp, BoxLayout.X_AXIS));</span><br><span class="line">        jp.add(Box.createHorizontalGlue());</span><br><span class="line">        jp.add(c);</span><br><span class="line">        jp.add(Box.createHorizontalGlue());</span><br><span class="line">        jp.setOpaque(<span class="keyword">false</span>);<span class="comment">//设置不透明</span></span><br><span class="line">        <span class="keyword">return</span> jp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【Main】</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StartFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、注解和反射"><a href="#七、注解和反射" class="headerlink" title="七、注解和反射"></a>七、注解和反射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解Annotation</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、什么是注解</span><br><span class="line">Annotation 是从JDK5.<span class="number">0</span>开始引入的新技术 .</span><br><span class="line"></span><br><span class="line">Annotation的作用</span><br><span class="line">不是程序本身 , 可以对程序作出解释.(这一点和注释(comment)没什么区别)</span><br><span class="line">可以被其他程序(比如:编译器等)读取.</span><br><span class="line"></span><br><span class="line">Annotation的格式</span><br><span class="line">注解是以<span class="string">&quot;@注释名&quot;</span>在代码中存在的</span><br><span class="line">还可以添加一些参数值 , 例如:<span class="meta">@SuppressWarnings(value=&quot;unchecked&quot;)</span></span><br><span class="line"></span><br><span class="line">Annotation在哪里使用?</span><br><span class="line">可以附加在<span class="keyword">package</span> , <span class="class"><span class="keyword">class</span> , <span class="title">method</span> , <span class="title">field</span> 等上面 , 相当于给他们添加了额外的辅助信息</span></span><br><span class="line"><span class="class">我们可以通过反射机制实现对这些元数据的访问</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">2、内置注解</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Override</span></span></span><br><span class="line"><span class="class">定义在 <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Override</span> 中 , 此注释只适用于修辞方法 , 表示一个方法声明打算重写超类中</span></span><br><span class="line"><span class="class">的另一个方法声明.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Deprecated</span></span></span><br><span class="line"><span class="class">定义在<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Deprecated</span>中 , 此注释可以用于修辞方法 , 属性 , 类 ,</span></span><br><span class="line"><span class="class">表示不鼓励程序员使用这样的元素 , 通常是因为它很危险或者存在更好的选择 .</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">SuppressWarnings</span></span></span><br><span class="line"><span class="class">定义在<span class="title">java</span>.<span class="title">lang</span>.<span class="title">SuppressWarnings</span>中,用来抑制编译时的警告信息.</span></span><br><span class="line"><span class="class">与前两个注释有所不同,你需要添加一个参数才能正确使用,这些参数都是已经定义好了的,我们</span></span><br><span class="line"><span class="class">选择性的使用就好了 .</span></span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(value=&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;)</span></span><br><span class="line">等等 .....</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//所有类默认继承Object类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Override 表示方法重写</span></span><br><span class="line"><span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line"><span class="comment">//--&gt; 测试名字不同产生的效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法过时了, 不建议使用 , 可能存在问题 , 并不是不能使用!</span></span><br><span class="line"><span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试 @Deprecated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@SuppressWarnings 抑制警告 , 可以传参数</span></span><br><span class="line"><span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line"><span class="comment">//查看源码:发现 参数类型 和 参数名称 , 并不是方法!</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、元注解</span><br><span class="line">元注解的作用就是负责注解其他注解 , Java定义了<span class="number">4</span>个标准的meta-annotation类型,他们被用来提供</span><br><span class="line">对其他annotation类型作说明 .</span><br><span class="line"></span><br><span class="line">这些类型和它们所支持的类在java.lang.annotation包中可以找到 .( <span class="meta">@Target</span> , <span class="meta">@Retention</span> ,</span><br><span class="line"><span class="meta">@Documented</span> , <span class="meta">@Inherited</span> )</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span> : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</span><br><span class="line"><span class="meta">@Retention</span> : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期</span><br><span class="line">(SOURCE &lt; CLASS &lt; RUNTIME)</span><br><span class="line"><span class="meta">@Document</span>：说明该注解将被包含在javadoc中</span><br><span class="line"><span class="meta">@Inherited</span>：说明子类可以继承父类中的该注解</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">//测试元注解</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"><span class="comment">//测试作用域 , 了解@Retention的概念</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、自定义注解</span><br><span class="line">使用 <span class="meta">@interface</span>自定义注解时 , 自动继承了java.lang.annotation.Annotation接口</span><br><span class="line">分析 :</span><br><span class="line">@ interface用来声明一个注解 , 格式 : public @ interface 注解名 &#123; 定义内容 &#125;</span><br><span class="line">其中的每一个方法实际上是声明了一个配置参数.</span><br><span class="line">方法的名称就是参数的名称.</span><br><span class="line">返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , <span class="keyword">enum</span> ).</span><br><span class="line">可以通过<span class="keyword">default</span>来声明参数的默认值</span><br><span class="line">如果只有一个参数成员 , 一般参数名为value</span><br><span class="line">注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,<span class="number">0</span>作为默认值 .</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="comment">//测试自定义注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示定义值 / 不显示值就是默认值</span></span><br><span class="line">    <span class="meta">@MyAnnotation2(age = 18,name = &quot;秦疆&quot;,id = 001,schools = &#123;&quot;西工大&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有一个参数, 默认名字一般是value.使用可省略不写</span></span><br><span class="line">    <span class="meta">@MyAnnotation3(&quot;aaa&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//参数类型 , 参数名</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>; <span class="comment">//String indexOf(&quot;abc&quot;) -1 , 不存在,找不到</span></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;西部开源&quot;</span>,<span class="string">&quot;狂神说Java&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation3&#123;</span><br><span class="line">    <span class="comment">// 参数类型 参数名称</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、反射读取注解</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.注解与反射.反射;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 反射读取注解 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="comment">//测试ORM:对象关系映射</span></span><br><span class="line"><span class="comment">//使用反射读取注解信息三步:</span></span><br><span class="line"><span class="comment">// 1.定义注解 ,</span></span><br><span class="line"><span class="comment">// 2.在类中使用注解 ,</span></span><br><span class="line"><span class="comment">// 3. 使用反射获取注解 , 一般都是现成框架实现 , 我们手动实现</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//反射 , Class可以获得类的全部信息 , 所有的东西</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;javaStudy.java高级学习.注解与反射.反射.Student&quot;</span>);</span><br><span class="line"><span class="comment">//获得这个类的注解</span></span><br><span class="line">            Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation annotation:annotations)&#123;</span><br><span class="line">                System.out.println(annotation);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//获得类的注解value的值</span></span><br><span class="line">            TableKuang table = (TableKuang)</span><br><span class="line">                    clazz.getAnnotation(TableKuang.class);</span><br><span class="line">            System.out.println(table.value());</span><br><span class="line"><span class="comment">//获得类指定注解的值</span></span><br><span class="line">            Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            FieldKuang fieldKuang = name.getAnnotation(FieldKuang.class);</span><br><span class="line">            System.out.println(fieldKuang.columnName()+<span class="string">&quot;-- &gt;&quot;</span>+fieldKuang.type()</span><br><span class="line">                    +<span class="string">&quot;--&gt;&quot;</span>+fieldKuang.length());</span><br><span class="line"><span class="comment">//我们可以根据得到的类的信息 , 通过JDBC生成相关的SQL语句,执行就可以动态生成数据库表</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@TableKuang(&quot;db_student&quot;)</span> <span class="comment">//假设数据库表名为db_student .</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieldKuang(columnName = &quot;db_id&quot;,type=&quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@FieldKuang(columnName = &quot;db_name&quot;,type=&quot;varchar&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@FieldKuang(columnName = &quot;db_age&quot;,type=&quot;int&quot;,length = 3)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表名注解 , 只有一个参数 , 建议使用value命名</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableKuang&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性注解</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.FIELD&#125;)</span> <span class="comment">//注意字段</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldKuang&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>; <span class="comment">//列名</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>; <span class="comment">//类型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反射机制Reflection</span><br><span class="line"><span class="number">1</span>、静态 VS 动态语言</span><br><span class="line">动态语言</span><br><span class="line">是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的</span><br><span class="line">函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自</span><br><span class="line">身结构。</span><br><span class="line">主要动态语言：Object-C、C#、JavaScript、PHP、Python等。</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">//体现动态语言的代码</span></span><br><span class="line"><span class="function">function <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;var a=3;var b=5;alert(a+b)&quot;</span>;</span><br><span class="line">eval(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态语言</span><br><span class="line">与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</span><br><span class="line">Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用</span><br><span class="line">反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Java Reflection</span><br><span class="line">Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取</span><br><span class="line">得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</span><br><span class="line"></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line"></span><br><span class="line">加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这</span><br><span class="line">个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，</span><br><span class="line">透过这个镜子看到类的结构，所以，我们形象的称之为：反射</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/3RN5obdkAFjOWan.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.注解与反射.反射;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 得到class的几种方式 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//通过反射获取类的Class</span></span><br><span class="line"><span class="comment">//---&gt;查看JDK帮助文档</span></span><br><span class="line">            Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;javaStudy.java高级学习.注解与反射.反射.User&quot;</span>);</span><br><span class="line"><span class="comment">//一个类被加载后 , 类的整个结构信息会被放到对应的Class对象中</span></span><br><span class="line">            System.out.println(c1);</span><br><span class="line"><span class="comment">//一个类只对应一个Class对象</span></span><br><span class="line">            Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;javaStudy.java高级学习.注解与反射.反射.User&quot;</span>);</span><br><span class="line">            System.out.println(c1.hashCode());</span><br><span class="line">            System.out.println(c2.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 创建一个实体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&quot;</span> + name +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java反射机制提供的功能</span><br><span class="line">在运行时判断任意一个对象所属的类</span><br><span class="line">在运行时构造任意一个类的对象</span><br><span class="line">在运行时判断任意一个类所具有的成员变量和方法</span><br><span class="line">在运行时获取泛型信息</span><br><span class="line">在运行时调用任意一个对象的成员变量和方法</span><br><span class="line">在运行时处理注解</span><br><span class="line">生成动态代理</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Java反射优点和缺点</span><br><span class="line">优点：可以实现动态创建对象和编译，体现出很大的灵活性 !</span><br><span class="line">缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满</span><br><span class="line">足我们的要求。这类操作总是慢于 直接执行相同的操作。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、反射相关的主要API</span><br><span class="line">java.lang.Class : 代表一个类</span><br><span class="line">java.lang.reflect.Method : 代表类的方法</span><br><span class="line">java.lang.reflect.Field : 代表类的成员变量</span><br><span class="line">java.lang.reflect.Constructor : 代表类的构造器</span><br><span class="line">.......</span><br><span class="line"><span class="number">4</span>、Class类</span><br><span class="line">在Object类中定义了以下的方法，此方法将被所有子类继承</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来</span><br><span class="line">看也很好理解，即：可以通过对象反射求出类的名称。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/DbxoAimJSwGWd5q.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个</span><br><span class="line">类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构</span><br><span class="line">(class/interface/enum/annotation/primitive type/void/[])的有关信息。</span><br><span class="line"></span><br><span class="line">Class 本身也是一个类</span><br><span class="line">Class 对象只能由系统建立对象</span><br><span class="line">一个加载的类在 JVM 中只会有一个Class实例</span><br><span class="line">一个Class对象对应的是一个加载到JVM中的一个.class文件</span><br><span class="line">每个类的实例都会记得自己是由哪个 Class 实例所生成</span><br><span class="line">通过Class可以完整地得到一个类中的所有被加载的结构</span><br><span class="line">Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.注解与反射.反射;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 得到class类的几种方式 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//测试各种类型获得Class对象的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;这个人是:&quot;</span>+person.name);</span><br><span class="line"><span class="comment">//获得class办法一:通过对象获得</span></span><br><span class="line">        Class clazz1 = person.getClass();</span><br><span class="line"><span class="comment">//获得class办法二:通过字符串获得(包名+类名)</span></span><br><span class="line">        Class clazz2 = Class.forName(<span class="string">&quot;javaStudy.java高级学习.注解与反射.反射.Student&quot;</span>);</span><br><span class="line"><span class="comment">//获得class办法三:通过类的静态成员class获得</span></span><br><span class="line">        Class clazz3 = Person.class;</span><br><span class="line"><span class="comment">//获得class办法四:只针对内置的基本数据类型</span></span><br><span class="line">        Class clazz4 = Integer.TYPE;</span><br><span class="line"><span class="comment">//获得父类类型</span></span><br><span class="line">        Class clazz5 = clazz2.getSuperclass();</span><br><span class="line">        System.out.println(clazz1);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line">        System.out.println(clazz4);</span><br><span class="line">        System.out.println(clazz5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;老师&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class类的常用方法</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/wHW1xqQ2iPmFASE.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取Class类的实例</span><br><span class="line">a）若已知具体的类，通过类的<span class="class"><span class="keyword">class</span>属性获取，该方法最为安全可靠，程序性能最高。</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">clazz</span> </span>= Person.class;</span><br><span class="line">b）已知某个类的实例，调用该实例的getClass()方法获取Class对象</span><br><span class="line">Class clazz = person.getClass();</span><br><span class="line">c）已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出</span><br><span class="line">ClassNotFoundException</span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;demo01.Student&quot;</span>);</span><br><span class="line">d）内置基本数据类型可以直接用类名.Type</span><br><span class="line">e）还可以利用ClassLoader我们之后讲解</span><br><span class="line"></span><br><span class="line">哪些类型可以有Class对象？</span><br><span class="line"><span class="class"><span class="keyword">class</span>：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</span></span><br><span class="line"><span class="class"><span class="title">interface</span>：接口</span></span><br><span class="line">[]：数组</span><br><span class="line"><span class="keyword">enum</span>：枚举</span><br><span class="line">annotation：注解<span class="meta">@interface</span></span><br><span class="line">primitive type：基本数据类型</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">package</span> javaStudy.java高级学习.注解与反射.反射;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class 判断是否是同一个类 &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="comment">//演示 : 所有类型的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = Object.class;</span><br><span class="line">        Class c2 = Comparable.class;</span><br><span class="line">        Class c3 = String[].class;</span><br><span class="line">        Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">        Class c5 = ElementType.class;</span><br><span class="line">        Class c6 = Override.class;</span><br><span class="line">        Class c7 = Integer.class;</span><br><span class="line">        Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">        Class c9 = Class.class;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Class c10 = a.getClass();</span><br><span class="line">        Class c11 = b.getClass();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line">        System.out.println(c10);</span><br><span class="line">        System.out.println(c11);</span><br><span class="line"><span class="comment">//只要元素类型与维度一样,就是同一个Class</span></span><br><span class="line">        System.out.println(c11==c10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、Java内存分析</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/As38RyzWblNnqHE.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类的加载过程</span><br><span class="line"></span><br><span class="line">当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通过如下三个步骤来对该类进行初始化</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/V5cpz71imd4LPtA.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类的加载与ClassLoader的理解</span><br><span class="line"></span><br><span class="line">加载：</span><br><span class="line">将<span class="class"><span class="keyword">class</span>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，</span></span><br><span class="line"><span class="class">然后生成一个代表这个类的<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>对象.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">链接：将<span class="title">Java</span>类的二进制代码合并到<span class="title">JVM</span>的运行状态之中的过程。</span></span><br><span class="line"><span class="class">验证：确保加载的类信息符合<span class="title">JVM</span>规范，没有安全方面的问题</span></span><br><span class="line"><span class="class">准备：正式为类变量（<span class="title">static</span>）分配内存并设置类变量默认初始值的阶段，这些内存都将在方</span></span><br><span class="line"><span class="class">法区中进行分配。</span></span><br><span class="line"><span class="class">解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">初始化：</span></span><br><span class="line"><span class="class">执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作</span></span><br><span class="line"><span class="class">和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造</span></span><br><span class="line"><span class="class">器）。</span></span><br><span class="line"><span class="class">当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</span></span><br><span class="line"><span class="class">虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">什么时候会发生类初始化？</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">类的主动引用（一定会发生类的初始化）</span></span><br><span class="line"><span class="class">当虚拟机启动，先初始化<span class="title">main</span>方法所在的类</span></span><br><span class="line"><span class="class"><span class="title">new</span>一个类的对象</span></span><br><span class="line"><span class="class">调用类的静态成员（除了<span class="title">final</span>常量）和静态方法</span></span><br><span class="line"><span class="class">使用<span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>包的方法对类进行反射调用</span></span><br><span class="line"><span class="class">当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">类的被动引用（不会发生类的初始化）</span></span><br><span class="line"><span class="class">当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静</span></span><br><span class="line"><span class="class">态变量，不会导致子类初始化</span></span><br><span class="line"><span class="class">通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line"><span class="class">引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">类加载器的作用</span></span><br><span class="line"><span class="class">类加载的作用：将<span class="title">class</span>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数</span></span><br><span class="line"><span class="class">据结构，然后在堆中生成一个代表这个类的<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>对象，作为方法区中类数据的访问入</span></span><br><span class="line"><span class="class">口。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">类缓存：标准的<span class="title">JavaSE</span>类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持</span></span><br><span class="line"><span class="class">加载（缓存）一段时间。不过<span class="title">JVM</span>垃圾回收机制可以回收这些<span class="title">Class</span>对象</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/dBm9eNnq6gWKCGw.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类加载器作用是用来把类(<span class="class"><span class="keyword">class</span>)装载进内存的。<span class="title">JVM</span> 规范定义了如下类型的类的加载器</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/x9ioljNgQIvRtPL.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>、创建运行时类的对象</span><br><span class="line"></span><br><span class="line">通过反射获取运行时类的完整结构</span><br><span class="line">Field、Method、Constructor、Superclass、Interface、Annotation</span><br><span class="line">实现的全部接口</span><br><span class="line">所继承的父类</span><br><span class="line">全部的构造器</span><br><span class="line">全部的方法</span><br><span class="line">全部的Field</span><br><span class="line">注解</span><br><span class="line">。。。</span><br><span class="line">小结</span><br><span class="line">在实际的操作中，取得类的信息的操作代码，并不会经常开发。</span><br><span class="line">一定要熟悉java.lang.reflect包的作用，反射机制。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、有了Class对象,能做什么?</span><br><span class="line">    </span><br><span class="line">创建类的对象：调用Class对象的newInstance()方法</span><br><span class="line">类必须有一个无参数的构造器。</span><br><span class="line">类的构造器的访问权限需要足够</span><br><span class="line">    </span><br><span class="line">思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，</span><br><span class="line">并将参数传递进去之后，才可以实例化操作。</span><br><span class="line">    </span><br><span class="line">步骤如下：</span><br><span class="line">通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型</span><br><span class="line">的构造器</span><br><span class="line">向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</span><br><span class="line">通过Constructor实例化对象</span><br><span class="line">    </span><br><span class="line">调用指定的方法</span><br><span class="line">通过反射，调用类中的方法，通过Method类完成。</span><br><span class="line">通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对</span><br><span class="line">象，并设置此方法操作时所需要的参数类型。</span><br><span class="line">之后使用<span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span>进行调用，并向方法中传递要设置的obj对</span></span><br><span class="line"><span class="function">象的参数信息。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/vzrbcqINxXMtjdn.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object 对应原方法的返回值，若原方法无返回值，此时返回<span class="keyword">null</span></span><br><span class="line">若原方法若为静态方法，此时形参Object obj可为<span class="keyword">null</span></span><br><span class="line">若原方法形参列表为空，则Object[] args为<span class="keyword">null</span></span><br><span class="line">若原方法声明为<span class="keyword">private</span>,则需要在调用此invoke()方法前，显式调用方法对象的</span><br><span class="line">setAccessible(<span class="keyword">true</span>)方法，将可访问<span class="keyword">private</span>的方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、setAccessible</span><br><span class="line">Method和Field、Constructor对象都有setAccessible()方法。</span><br><span class="line">setAccessible作用是启动和禁用访问安全检查的开关。</span><br><span class="line">参数值为<span class="keyword">true</span>则指示反射的对象在使用时应该取消Java语言访问检查。</span><br><span class="line">提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为<span class="keyword">true</span>。</span><br><span class="line">使得原本无法访问的私有成员也可以访问</span><br><span class="line">参数值为<span class="keyword">false</span>则指示反射的对象应该实施Java语言访问检查</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、反射操作泛型</span><br><span class="line">Java采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性</span><br><span class="line">和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除</span><br><span class="line">为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable</span><br><span class="line">和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型.</span><br><span class="line">ParameterizedType : 表示一种参数化类型,比如Collection</span><br><span class="line">GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型</span><br><span class="line">TypeVariable : 是各种类型变量的公共父接口</span><br><span class="line">WildcardType : 代表一种通配符类型表达式</span><br><span class="line">反射操作注解</span><br><span class="line">getAnnotations</span><br><span class="line">getAnnotation</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三、前端"><a href="#三、前端" class="headerlink" title="三、前端"></a>三、前端</h1><h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span>、什么是HTM</span><br><span class="line">HTML：Hyper Text Markup Language（超文本标记语言）</span><br><span class="line">超文本包括：文字、图片、音频、视频、动画等</span><br><span class="line"><span class="number">1.</span> 网页的组成</span><br><span class="line"><span class="number">2.</span> 标签作用是什么</span><br><span class="line"><span class="number">3.</span> 浏览器打开后，会从上到下解释这些代码，并呈现相应的效果</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>、发展史、优势</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/1cDJLS3wAgHo2zu.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HTML：Hyper Text Markup Language超文本标记语言</span><br><span class="line">超文本标记语言—在<span class="number">1993</span>年<span class="number">6</span>月互联网工程工作小组工作案发布（并非标准）</span><br><span class="line">HTML2.<span class="number">0</span>—<span class="number">1995</span>年<span class="number">11</span>月作为RFC1866发布，在RFC2854于<span class="number">2000</span>年<span class="number">6</span>月发布之后被宣布过时。</span><br><span class="line">HTML3.<span class="number">2</span>—<span class="number">1996</span>年<span class="number">1</span>月<span class="number">14</span>日，W3C推荐标准</span><br><span class="line">HTML4.<span class="number">0</span>—<span class="number">1997</span>年<span class="number">12</span>月<span class="number">18</span>日，W3C推荐标准</span><br><span class="line">HTML4.<span class="number">01</span>（微小改进）—<span class="number">1999</span>年<span class="number">12</span>月<span class="number">24</span>日，W3C推荐标准，<span class="number">2000</span>年<span class="number">5</span>月<span class="number">15</span>日发布基本严格的</span><br><span class="line">HTML4.<span class="number">01</span>语法，是国标标准化组织和国际电工委员会的标准</span><br><span class="line">XHTML1.<span class="number">0</span>—发布于<span class="number">2000</span>年<span class="number">1</span>月<span class="number">26</span>日，是W3C推荐标准，后来经过修订于<span class="number">2002</span>年<span class="number">8</span>月<span class="number">1</span>日重新发布</span><br><span class="line">XHTML1.<span class="number">1</span>—<span class="number">2001</span>年<span class="number">5</span>月<span class="number">31</span>日发布</span><br><span class="line">XHTML2.<span class="number">0</span>是W3C的工作草案，由于改动过大，学习这个新技术的成本过高而最终胎死腹中，因</span><br><span class="line">此，现在最常用的还是XHTML1.<span class="number">0</span>标准。</span><br><span class="line">目前最新的版本为HTML5，它是<span class="number">2004</span>年被提出，<span class="number">2007</span>年被W3C接纳并成立新的HTML工作团队，</span><br><span class="line"><span class="number">2008</span>年<span class="number">1</span>月<span class="number">22</span>日公布HTML5第一份正式草案，<span class="number">2012</span>年<span class="number">12</span>月<span class="number">17</span>日HTML5规范正式定稿，<span class="number">2013</span>年<span class="number">5</span>月</span><br><span class="line"><span class="number">6</span>日，HTML5.<span class="number">1</span>正式草案公布。</span><br><span class="line">HTML <span class="number">5</span>作为最新版本，提供了一些新的元素和一些有趣的新特性，同时也建立了一些新的规则。</span><br><span class="line">这些元素、特性和规则的建立，提供了许多新的网页功能，如使用网页实现动态渲染图形、图表、</span><br><span class="line">图像和动画，以及不需要安装任何插件直接使用网页播放视频等。目前企业开发中也在增大使用</span><br><span class="line">HTML5的力度</span><br><span class="line"></span><br><span class="line">HTML5的优势</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>世界知名浏览器厂商对HTML5的支持</span><br><span class="line">通过对Internet Explorer、Google、Firefox、Safari、Opera等主要的Web浏览器发展策略调查，发现</span><br><span class="line">他们都在支持HTMl5上采取措施。</span><br><span class="line">微软：<span class="number">2010</span>年<span class="number">3</span>月<span class="number">16</span>日，微软于拉斯维加斯市举行的MIX10技术大会上宣布已推出IE9浏览器开发者预览</span><br><span class="line">版。此版本将更多的支持CSS3、SVG和HTML5等互联网浏览通用标准。</span><br><span class="line">Google：<span class="number">2010</span>年<span class="number">2</span>月<span class="number">19</span>日，谷歌Gears项目经理伊安一费特通过博客宣布，谷歌将放弃对Gears浏览器</span><br><span class="line">插件项目的支持，以此重点开发HTML5项目。</span><br><span class="line">苹果：<span class="number">2010</span>年<span class="number">6</span>月<span class="number">7</span>日，苹果在开发者大会的会后发布了Safari <span class="number">5</span>，这款浏览器支持<span class="number">10</span>个以上HTML5新技</span><br><span class="line">术，包括全屏播放、HTML5视频、HTML5地理位置、HTML5的形式验证等功能。</span><br><span class="line">Opera：<span class="number">2010</span>年<span class="number">5</span>月<span class="number">5</span>日，Opera软件公司首席技术官Hakon Wium Lie先生在访华之际，接受中国软件</span><br><span class="line">资讯网等少数几家媒体采访，他认为HTMl5和CSS3将是全球互联网发展的未来趋势。</span><br><span class="line">mozilla firefox：<span class="number">2010</span>年<span class="number">7</span>月，Mozilla基金会发布了Firefox <span class="number">4</span>浏览器的第一个测试版，从官方文档看，</span><br><span class="line">它对HTML5是完全级别的支持。</span><br><span class="line">以上证据表明，目前这些浏览器已经纷纷朝着支持HTML5、结合HTML5的方向迈进，因此HTML5已经</span><br><span class="line">被广泛的推行开来。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>．市场的需求</span><br><span class="line">现在的市场已经迫不及待的要求有一个统一的互联网通用标准。HTML5之前的情况是，由于各浏览器之</span><br><span class="line">间的不统一，光是修改Web浏览器之间的由于兼容性而引起的bug就浪费了大量的时间。而HTML5的目</span><br><span class="line">标就是将Web带入一个成熟的应用平台，在HTML5平台上，视频、音频、图像、动画以及同电脑的交互</span><br><span class="line">都被标准化。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>．跨平台</span><br><span class="line">HTML5可以做到跨平台开发，用户只用打开浏览器即可访问应用，PC网站、各种移动设备、插件等核心</span><br><span class="line">代码就可以不需要重复编写，极大的减少了开发人员的工作量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span>、W3C标准</span><br><span class="line">W3C</span><br><span class="line">World Wide Web Consortium（万维网联盟）</span><br><span class="line">成立于<span class="number">1994</span>年，Web技术领域最权威和具影响力的国际中立性技术标准机构</span><br><span class="line">http:<span class="comment">//www.w3.org/</span></span><br><span class="line">http:<span class="comment">//www.chinaw3c.org/</span></span><br><span class="line">W3C标准包括</span><br><span class="line">结构化标准语言（XHTML 、XML）</span><br><span class="line">表现标准语言（CSS）</span><br><span class="line">行为标准（DOM、ECMAScript ）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctrl + /快捷注释</span><br><span class="line">代码示例:</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;静夜思&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;静夜思&lt;/h1&gt;</span><br><span class="line">&lt;em&gt;朝代:唐代&lt;/em&gt; &amp;nbsp;&amp;nbsp; 作者:&lt;strong&gt;李白&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">原文：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">床前明月光，&lt;br/&gt;</span><br><span class="line">疑是地上霜。&lt;br/&gt;</span><br><span class="line">举头望明月，&lt;br/&gt;</span><br><span class="line">低头思故乡。&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">常见的网页编辑工具IDE：</span><br><span class="line">记事本</span><br><span class="line">NotePad++</span><br><span class="line">Sublime</span><br><span class="line">VsCode</span><br><span class="line">WebStorm</span><br><span class="line">HBuidler</span><br><span class="line">IDEA</span><br><span class="line">....</span><br><span class="line">没有最好的，只有最合适的。</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span>、HTML基本结构</span><br><span class="line">HTML网页基本结构</span><br><span class="line">1. 强调HTML标签都以“&lt; &gt;”开始、“&lt;/ &gt;”结束</span><br><span class="line"><span class="number">2.</span> 说明网页基本结构中这几个标签的用法</span><br><span class="line"><span class="number">3.</span> 网页中所有的内容都放在之间</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/4tQe3dfsr2HwGg5.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DOCTYPE声明</span><br><span class="line">百度搜索DOCTYPE声明，查看菜鸟教程：https:<span class="comment">//www.runoob.com/tags/tag-doctype.html</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/UfS6diV74JKoMRs.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt; title&gt;标签</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/qedMBWrzfh9JonO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt; meta&gt;标签</span><br><span class="line">详细讲解字符编码在网页中的作用，网页常用的字符编码有gb2312、utf-<span class="number">8</span>，两者之间的区别。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/J7Uzyi8ckrS2xIO.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.5</span>、网页的基本标签</span><br><span class="line"><span class="number">1</span>、标题标签</span><br><span class="line">先讲解标题标签代码写法，说明标题标签在网页中的作用，通常用于标题或主题，体现标签语义</span><br><span class="line">化。</span><br><span class="line">h1最大，h6最小，对比效果图讲解</span><br><span class="line">最后演示示例，演示效果图</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/hecvNMKPyrpauA2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、段落标签</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/IUGVetnyTcXbM8u.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、换行标签</span><br><span class="line">换行标签，查看效果图,看段落标签和换行标签的不同</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/C8SeJBsWctuQobF.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>、水平线标签</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/24oxkuK7t9CNTwn.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>、字体样式标签</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/sNxaH5fYkpS1njV.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>、注释和特殊符号</span><br><span class="line"></span><br><span class="line">注释</span><br><span class="line">&lt;!--我是注释--&gt;</span><br><span class="line"></span><br><span class="line">特殊符号</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/wVljeciaUW6CIXJ.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码示例:</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;特殊符号&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--空格--&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">狂神说 Java&lt;br/&gt;</span><br><span class="line">狂神说 Java&lt;br/&gt;</span><br><span class="line">狂神说&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;!--大于小于--&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&gt; &lt; &lt;br&gt;</span><br><span class="line">&amp;gt; &amp;lt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;!--引号--&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&amp;quot;狂神&amp;quot;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;!--版权--&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&amp;copy; <span class="number">2017</span>-<span class="number">2019</span> 狂神说Java</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;!--万能的公式 &amp;符号+xxx --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">1.6</span>、图像标签</span><br><span class="line">常见的图像格式：jpg、gif、png、bmp、</span><br><span class="line">说明JPG、gif是网页中最常用的格式，PNG受浏览器兼容性的限制</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1.</span> 先讲解图像语法，对每个参数详细讲解，并且强调说明alt属性和title属性在什么情况下可以看到替</span><br><span class="line">代文字和提示文字，并且说明alt属性常和src配合使用。</span><br><span class="line"><span class="number">2.</span> 说明img标签的与之前学习的&lt; br/&gt;标签一样，不是成对的标签，直接在最后以“/”闭合，体现标签</span><br><span class="line">的语义化。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/VLjx13n26kIzZGE.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.7</span>、链接标签</span><br><span class="line"></span><br><span class="line">页面间链接：从一个页面链接到另外一个页面</span><br><span class="line">锚链接</span><br><span class="line">功能性链接</span><br><span class="line">说明：</span><br><span class="line">讲解语法，详细说明每个参数的用法，强调一下路径的表示方法，相对路径和绝对路径，说明</span><br><span class="line">target常用值为self和blank，还有其他值，以后用到再讲。</span><br><span class="line">讲解给出的例子代码，一个文本超链接一个图像超链接</span><br><span class="line">最后演示，只演示超链接效果即可，演示时更改target的参数，让学员看到目标窗口打开的不同位</span><br><span class="line">置。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/Zn3FV5azWK4lStY.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">锚链接</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/o3F94Ap2zjvNCJn.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">功能性链接</span><br><span class="line">这几种都是常用的功能性链接，例如在网上单击一些QQ图标直接弹出QQ对话框，或单击MSN图标直接</span><br><span class="line">弹出MSN对话框，这些都是使用了功能有性链接</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/X8UkGWxV7a4uQed.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.8</span>、行内元素和块元素</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/jqWt89pIBKATGZu.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/NCdcQyePgEkY4nB.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、列表、表格与媒体元素</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span>、列表</span><br><span class="line">无序列表和定义列表在网页制作中应用非常广泛</span><br><span class="line">什么是列表：</span><br><span class="line">列表就是信息资源的一种展示形式。它可以使信息结构化和条理化，并以列表的样式显示出来，以</span><br><span class="line">便浏览者能更快捷地获得相应的信息。</span><br><span class="line"></span><br><span class="line">无序列表</span><br><span class="line">代码示例:</span><br><span class="line">&lt;!--ul 声明无序列表--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;!--li 声明列表项--&gt;</span><br><span class="line">&lt;li&gt;语文&lt;/li&gt;</span><br><span class="line">&lt;li&gt;数学&lt;/li&gt;</span><br><span class="line">&lt;li&gt;英语&lt;/li&gt;</span><br><span class="line">&lt;li&gt;计算机&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">列表项中可以包含图片、文本，还可以嵌套列表、其他标签等</span><br><span class="line">无序列表的特性</span><br><span class="line">没有顺序，每个&lt; li&gt;标签独占一行（块元素）</span><br><span class="line">默认&lt; li&gt;标签项前面有个实心小圆点</span><br><span class="line">一般用于无序类型的列表，如导航、侧边栏新闻、有规律的图文组合模块等</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line">代码示例:</span><br><span class="line">&lt;!--ol 声明有序列表--&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;语文&lt;/li&gt;</span><br><span class="line">&lt;li&gt;数学&lt;/li&gt;</span><br><span class="line">&lt;li&gt;英语&lt;/li&gt;</span><br><span class="line">&lt;li&gt;计算机&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">有序列表默认以数字序号显示</span><br><span class="line">有序列表与无序列表一样，也可以嵌套列表、可以包含图片、文本、其他标签等</span><br><span class="line">有序列表的特性</span><br><span class="line">有顺序，每个&lt; li&gt;标签独占一行（块元素）</span><br><span class="line">默认&lt; li&gt;标签项前面有顺序标记</span><br><span class="line">一般用于排序类型的列表，如试卷、问卷选项等</span><br><span class="line"></span><br><span class="line">自定义列表</span><br><span class="line">代码示例:</span><br><span class="line">&lt;!--dl 声明定义列表--&gt;</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">&lt;!--dt 声明列表项--&gt;</span><br><span class="line">&lt;dt&gt;水果&lt;/dt&gt;</span><br><span class="line">&lt;!--dd 定义列表项内容--&gt;</span><br><span class="line">&lt;dd&gt;苹果&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;桃子&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;李子&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">定义列表也可以嵌套列表、包含图片、文本、其他标签等</span><br><span class="line">以后的网页制作中经常会用到定义列表，特别是图文混排的情况</span><br><span class="line">定义列表的特性</span><br><span class="line">没有顺序，每个&lt; dt&gt;标签、&lt; dd&gt;标签独占一行（块元素）</span><br><span class="line">默认没有标记</span><br><span class="line">一般用于一个标题下有一个或多个列表项的情况</span><br><span class="line"></span><br><span class="line">小结：列表对比</span><br><span class="line">列表之间可以互相嵌套，进行页面的局部布局</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/AlvfBxHbS4L81RY.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表格</span><br><span class="line">为什么使用表格</span><br><span class="line">简单通用</span><br><span class="line">结构稳定</span><br><span class="line">基本结构</span><br><span class="line">单元格</span><br><span class="line">行</span><br><span class="line">列</span><br><span class="line"></span><br><span class="line">表格的基本语法</span><br><span class="line">代码示例:</span><br><span class="line"><span class="comment">&lt;!--table表格标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tr 行标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--td 单元格标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第1个单元格的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第2个单元格的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第1个单元格的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>第2个单元格的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/8LM635UtVFBxSOQ.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表格的跨列</span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--colspan 所跨的列数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;n&quot;</span>&gt;</span>单元格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/21ivF6GtJlWrEdz.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表格的跨行</span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--rowspan 所跨的行数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;n&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/tDIyqnfcX2CW568.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表格的跨行和跨列</span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--跨列--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>学生成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--跨行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>98<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/SwfEi2pK7eRzs1W.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.3、音频、视频</span><br><span class="line">如何实现在网页上播放视频和音频？</span><br><span class="line">第三方自主开发的播放器</span><br><span class="line">Flash</span><br><span class="line">HTML5媒体元素</span><br><span class="line">在HTML5问世之前，要在网页上展示视频、音频、动画等，除了使用第三方自主开发的播放器外，使用</span><br><span class="line">最多的工具应该算是Flash了，但是它需要在浏览器上安装各种插件才能使用，有时候速度也会非常慢。</span><br><span class="line">HTML5的出现改变了这一状况，在网页中使用HTML5来播放音频、视频再也不需要安装插件，只需要一</span><br><span class="line">个支持HTML5的浏览器就可以了。</span><br><span class="line"></span><br><span class="line">视频标签</span><br><span class="line">src：指定要播放的视频文件的路径</span><br><span class="line">controls：提供播放、暂停和音量的控件</span><br><span class="line">autoplay：自动播放属性</span><br><span class="line">loop：视频的循环播放</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;视频路径&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">音频标签</span><br><span class="line">src：指定要播放的音频文件的路径</span><br><span class="line">trols：提供播放、暂停和音量的控件</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;音频路径&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2.4、页面结构分析</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/s37vPaY2hwdVRoT.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML5结构元素</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/GQzyvo2VamBfbRN.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.5、内联框架</span><br><span class="line"></span><br><span class="line">iframe 单页面内联</span><br><span class="line">src：引用页面地址</span><br><span class="line">name：框架标识名</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;path&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mainFrame&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">iframe属性（实现页面间的相互跳转）</span><br><span class="line">在被打开的框架上加name属性</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;mainFrame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">在超链接上设置target目标窗口属性为希望显示的框架窗口名</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;mainFrame&quot;</span>&gt;</span>加载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/HCAGEirg9LbcxZM.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3、表单</span><br><span class="line">本章目标</span><br><span class="line">会使用表单元素布局表单</span><br><span class="line">会制作语义化的表单</span><br><span class="line">会使用HTML5属性初步验证表单</span><br><span class="line">提问：大家在上网时，看到的表单在网页中的应用有哪些？</span><br><span class="line">登录</span><br><span class="line">注册</span><br><span class="line"></span><br><span class="line">3.1、表单语法</span><br><span class="line">method: 规定如何发送表单数据常用值：get post</span><br><span class="line">在实际网页开发中通常采用post方式提交表单数据</span><br><span class="line">action: 表示向何处发送表单数据</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;result.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> &gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> &gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重填&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">讲解表单的创建方法，以及method和action的作用</span><br><span class="line">分别把method的值设置为get和post，然后提交表单，查看页面效果；通过演示可看到method设</span><br><span class="line">置不同值时，表单数据在地址栏显示的不同情况</span><br><span class="line">最后根据演示情况说明get和post两者的区别</span><br><span class="line">最后总结：post方式提交的数据安全性要明显高于get方式提交的数据。因此在实际开发中通常采</span><br><span class="line">用post方式提交表单数据。</span><br><span class="line"></span><br><span class="line">3.2、13个表单元素</span><br><span class="line"></span><br><span class="line">1、文本框</span><br><span class="line"><span class="comment">&lt;!--type=&quot;text&quot;</span></span><br><span class="line"><span class="comment">name：文本框名称(必填)</span></span><br><span class="line"><span class="comment">value：文本框初始值</span></span><br><span class="line"><span class="comment">size：文本框长度</span></span><br><span class="line"><span class="comment">maxlength：文本框可输入最多字符</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line">2、密码框</span><br><span class="line">向密码框中输入字符时，显示的效果，密码字符以黑色实心的圆点来显示。</span><br><span class="line"><span class="comment">&lt;!--type=&quot;password&quot;</span></span><br><span class="line"><span class="comment">name：密码框名称(必填)</span></span><br><span class="line"><span class="comment">size：密码框长度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">3、单选按钮</span><br><span class="line">同一组单选按钮，name属性值必须相同，才能在选中单选按钮时达到互斥</span><br><span class="line"><span class="comment">&lt;!--type=&quot;radio&quot;</span></span><br><span class="line"><span class="comment">name：单选框名称(必填)，一组的名称需要相同</span></span><br><span class="line"><span class="comment">checked：单选按钮选中状态</span></span><br><span class="line"><span class="comment">value：单选框的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gen&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gen&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> /&gt;</span>女</span><br><span class="line"></span><br><span class="line">4、复选框</span><br><span class="line">同一组复选框，根据需要可设置name属性值相同</span><br><span class="line"><span class="comment">&lt;!--type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="comment">name：复选框名称(必填)，一组的名称需要相同</span></span><br><span class="line"><span class="comment">checked：复选按钮选中状态</span></span><br><span class="line"><span class="comment">value：复选框的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sports&quot;</span>/&gt;</span>运动</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;talk&quot;</span> <span class="attr">checked</span> /&gt;</span>聊天</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;play&quot;</span>/&gt;</span>玩游戏</span><br><span class="line"></span><br><span class="line">5、下拉列表框</span><br><span class="line">一个<span class="tag">&lt;<span class="name">select</span>&gt;</span>中至少包含一下<span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">希望在页面加载时有默认选中的选中项，则必须使用selected属性，如果没有默认选中项则第一个选项</span><br><span class="line">默认被选中；演示时改变size的值和selected默认值，</span><br><span class="line"><span class="comment">&lt;!--select:下拉列表框--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--option：选项--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;列表名称&quot;</span> <span class="attr">size</span>=<span class="string">&quot;行数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;选项的值&quot;</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>…<span class="tag">&lt;/<span class="name">option</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;选项的值&quot;</span>&gt;</span>…<span class="tag">&lt;/<span class="name">option</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">6、按钮</span><br><span class="line"><span class="comment">&lt;!--重置按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">name</span>=<span class="string">&quot;butReset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reset按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提交按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;butSubmit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--普通按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;butButton&quot;</span> <span class="attr">value</span>=<span class="string">&quot;button按钮&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--图片按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/login.gif&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">7、多行文本域</span><br><span class="line">强调多行文本域的内</span><br><span class="line">容是在标签之间。</span><br><span class="line">textarea：多行文本域</span><br><span class="line">cols：显示的列数</span><br><span class="line">rows：显示的行数</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;showText&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;x&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;y&quot;</span>&gt;</span>文本内容 <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line">8、文件域</span><br><span class="line">在表单中使用文件域时，必须设置表单的“enctype”编码属性为“multipart/form-data”，表示将表单数据</span><br><span class="line">分为多部分提交。未来文件上传和下载会详细讲解，现在了解即可！</span><br><span class="line">enctype：表单编码属性</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type=&quot;file&quot; 文件域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">9、邮箱</span><br><span class="line">会自动验证Email地址格式是否正确</span><br><span class="line">邮箱:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">10、网址</span><br><span class="line">会自动验证URL地址格式是否正确</span><br><span class="line">请输入你的网址:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userUrl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">11、数字</span><br><span class="line">min：最小值</span><br><span class="line">max：最大值</span><br><span class="line">step：步长</span><br><span class="line">请输入数字:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">step</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">12、滑块</span><br><span class="line">type值为range即为滑块。</span><br><span class="line">请输入数字:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;range1&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">13、搜索框</span><br><span class="line">type值为search即为搜索框。</span><br><span class="line">请输入搜索的关键词:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sousuo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">3.4、表单的高级应用</span><br><span class="line">在某些注册页面或本图片中订单信息页面，必须同意一些条款按钮才能使用等等</span><br><span class="line"></span><br><span class="line">隐藏域</span><br><span class="line">在浏览器中看不到隐藏域，但是在提交表单时可以看到隐藏域的内容被提交至服务器</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userid&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">只读、禁用</span><br><span class="line">W3C HTML5标准中，规定对于布尔类型的属性，属性值可以省略</span><br><span class="line">讲解只读和禁用的语法，强调不能单写readonly或disabled，必须写readonly</span><br><span class="line">＝”readonly”和disabled=“disabled”，介绍只读和禁用的使用场合</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">表单元素的标注</span><br><span class="line">增强鼠标的可用性</span><br><span class="line">自动将焦点转移到与该标注相关的表单元素上</span><br><span class="line"><span class="comment">&lt;!--它的for属性对应的id与表单元素id一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id&quot;</span>&gt;</span>标注的文本<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">3.5、表单的初级验证</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/P5dXYDKAT2je1IS.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如果用户填写的表单内容不进行验证就发给服务器，那么服务器发现填写的不合法，或是没有填写，就</span><br><span class="line">会返回响应给用户，用户重新填写再提交，如此多次持续直到用户输入正确。它们之间的通信是通过网</span><br><span class="line">络进行的，如果网络很差，那么注册一个账号就得花很长时间，对用户来说是非常烦的，对服务器来说</span><br><span class="line">也增加了其工作压力。</span><br><span class="line">要是有恶意的用户向服务器发送病毒或是有害于服务器安全的程序就更危险了。</span><br><span class="line">表单验证的好处：</span><br><span class="line">（1）减轻服务器的压力。</span><br><span class="line">（2）保证数据的可行性和安全性。</span><br><span class="line">在客户端就对表单进行验证是非常有必要的</span><br><span class="line">表单初级验证的方法</span><br><span class="line">这三个属性是html5中很实用的属性，后面javaScript课程中还会详细的讲解。现在大家就大概认识者三</span><br><span class="line">种属性即可。</span><br><span class="line"></span><br><span class="line">placeholder</span><br><span class="line">提示语默认显示，当文本框中输入内容时提示语消失</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sousuo&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入要搜索的关键字&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">required</span><br><span class="line">规定文本框填写内容不能为空，否则不允许用户提交表单</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">required</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">pattern</span><br><span class="line">用户输入的内容必须符合正则表达式所指的规则，否则就不能提交表单</span><br><span class="line">（javaScript课程会详解）</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">required</span> <span class="attr">pattern</span>=<span class="string">&quot;^1[358]\d&#123;9&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">3.6、小结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/7DvObfgxVMK9i4d.png"></p>
<h3 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、初识CSS3</span><br><span class="line">本章目标：</span><br><span class="line">会使用行内样式、内部样式表和外部样式表三种方式为HTML5文档添加CSS样式</span><br><span class="line">会使用CSS3的基本选择器设置字体大小和颜色</span><br><span class="line">会使用复合选择器为特定的网页元素添加CSS样式</span><br><span class="line">会使用CSS3高级选择器为网页元素添加CSS样式</span><br><span class="line"></span><br><span class="line">1.1、什么是CSS</span><br><span class="line">Cascading Style Sheet 级联样式表。</span><br><span class="line">表现HTML或XHTML文件样式的计算机语言。</span><br><span class="line">包括对字体、颜色、边距、高度、宽度、背景图片、网页定位等设定。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/WlDSLpMwQ4aeUCg.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">说明：</span><br><span class="line">首先介绍什么是CSS</span><br><span class="line">然后对比讲解使用CSS和没有使用CSS的两个相同的HTML代码页面显示效果，说明CSS的重要性</span><br><span class="line">最后根据图说明CSS在网页中的应用</span><br><span class="line">1.2、CSS的发展史</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/hS67n2PZpMWNuIC.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CSS1.0 读者可以从其他地方去使用自己喜欢的设计样式去继承性地使用样式；</span><br><span class="line">CSS2.0 融入了DIV+CSS的概念，提出了HTML结构与CSS样式表的分离</span><br><span class="line">CSS2.1 融入了更多高级的用法，如浮动，定位等。</span><br><span class="line">CSS3.0 它包括了CSS2.1下的所有功能，是目前最新的版本，它向着模块化的趋势发展，又加了很多使用</span><br><span class="line">的新技术，如字体、多背景、圆角、阴影、动画等高级属性，但是它需要高级浏览器的支持。</span><br><span class="line">由于现在IE 6、IE 7使用比例已经很少，对市场企业进行调研发现使用CSS3的频率大幅增加，学习CSS3</span><br><span class="line">已经成为一种趋势，因此本书会讲解最新的CSS3版本</span><br><span class="line">本课程中主要讲解css2.1和css3</span><br><span class="line"></span><br><span class="line">CSS的优势</span><br><span class="line">内容与表现分离</span><br><span class="line">网页的表现统一，容易修改</span><br><span class="line">丰富的样式，使得页面布局更加灵活</span><br><span class="line">减少网页的代码量，增加网页的浏览速度，节省网络带宽</span><br><span class="line">运用独立于页面的CSS，有利于网页被搜索引擎收录</span><br><span class="line"></span><br><span class="line">1.3、CSS的基本语法</span><br><span class="line">首先讲解CSS的基本语法结构，由选择器和声明构成</span><br><span class="line">然后对照具体的样式详细讲解语法，强调声明必须在&#123; &#125;中</span><br><span class="line">最后说明基本W3C的规范，每条声明后的;都要写上</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/SEFXhuK1cMd7nHl.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Style标签</span><br><span class="line">讲解CSS样式如何在HTML中应用，引入style标签的应用</span><br><span class="line">讲解style标签，说明type=“text/css的用法</span><br><span class="line">说明style标签在HTML文档中的位置，在与之间</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/MSjsJerTB2CwFXq.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.4、引入CSS方式</span><br><span class="line">行内样式</span><br><span class="line">使用style属性引入CSS样式</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>style属性的应用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px; color:green;&quot;</span>&gt;</span>直接在HTML标签中设置的样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用style属性设置CSS样式仅对当前的HTML标签起作为，并且是写在HTML标签中的</span><br><span class="line">这种方式不能起到内容与表现相分离，本质上没有体现出CSS的优势，因此不推荐使用。</span><br><span class="line"></span><br><span class="line">内部样式表</span><br><span class="line">CSS代码写在 <span class="tag">&lt;<span class="name">head</span>&gt;</span> 的 <span class="tag">&lt;<span class="name">style</span>&gt;</span> 标签中</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>: green; &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">优点：方便在同页面中修改样式</span><br><span class="line">缺点：不利于在多页面间共享复用代码及维护，对内容与样式的分离也不够彻底</span><br><span class="line">引出外部样式表</span><br><span class="line"></span><br><span class="line">外部样式表</span><br><span class="line">CSS代码保存在扩展名为.css的样式表中</span><br><span class="line">HTML文件引用扩展名为.css的样式表，有两种方式</span><br><span class="line">链接式（使用的最多）</span><br><span class="line">使用 <span class="tag">&lt;<span class="name">link</span>&gt;</span> 标签链接外部样式表，并讲解各参数的含义， <span class="tag">&lt;<span class="name">link</span>&gt;</span> 标签必须放在</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> 标签中</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/2UajJXrsRh1e78M.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">链接式与导入式的区别</span><br><span class="line">1. <span class="tag">&lt;<span class="name">link</span>/&gt;</span> 标签是属于XHTML范畴的，@import是属于CSS2.1中特有的。</span><br><span class="line">2. 使用 <span class="tag">&lt;<span class="name">link</span>/&gt;</span> 链接的CSS是客户端浏览网页时先将外部CSS文件加载到网页当中，然后再进行编</span><br><span class="line">译显示，所以这种情况下显示出来的网页与用户预期的效果一样，即使网速再慢也一样的效果。</span><br><span class="line">3. 使用@import导入的CSS文件，客户端在浏览网页时是先将HTML结构呈现出来，再把外部CSS文件</span><br><span class="line">加载到网页当中，当然最终的效果也与使用 <span class="tag">&lt;<span class="name">link</span>/&gt;</span> 链接文件效果一样，只是当网速较慢时会</span><br><span class="line">先显示没有CSS统一布局的HTML网页，这样就会给用户很不好的感觉。这个也是现在目前大多少</span><br><span class="line">网站采用链接外部样式表的主要原因。</span><br><span class="line">4. 由于@import是属于CSS2.1中特有的，因此对于不兼容CSS2.1的浏览器来说就是无效的。</span><br><span class="line"></span><br><span class="line">CSS样式优先级</span><br><span class="line">行内样式&gt;内部样式表&gt;外部样式表</span><br><span class="line">就近原则：越接近标签的样式优先级越高</span><br><span class="line"></span><br><span class="line">1.5、CSS基本选择器</span><br><span class="line">标签选择器</span><br><span class="line">HTML标签作为标签选择器的名称</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>…<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/TE9hRwKy7VFkBDc.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">类选择器</span><br><span class="line">一些特殊的实现效果，单纯使用标签选择器不能实现，从而引出类选择器</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/OUlQIGFytwxoLkZ.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ID选择器</span><br><span class="line">ID选择器的名称就是HTML中标签的ID名称，ID全局唯一</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/FXGHLIAzB6oYh4T.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">小结</span><br><span class="line">标签选择器直接应用于HTML标签</span><br><span class="line">类选择器可在页面中多次使用</span><br><span class="line">ID选择器在同一个页面中只能使用一次</span><br><span class="line"></span><br><span class="line">基本选择器的优先级</span><br><span class="line">ID选择器&gt;类选择器&gt;标签选择器</span><br><span class="line">标签选择器是否也遵循“就近原则”？</span><br><span class="line">不遵循，无论是哪种方式引入CSS样式，一般都遵循ID选择器 &gt; class类选择器 &gt; 标签选择器的优先级</span><br><span class="line"></span><br><span class="line">1.6、CSS高级选择器</span><br><span class="line">1、层次选择器</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xBCDGm7NFywWoE8.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">后代选择器</span><br><span class="line"></span><br><span class="line">body p&#123;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/XAbsztcUrS39Via.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">后代选择器两个选择符之间必须要以空格隔开，中间不能有任何其他的符号插入</span><br><span class="line"></span><br><span class="line">子选择器</span><br><span class="line">body&gt;p&#123;</span><br><span class="line">background: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/fghlc1HxTBC8WE9.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">相邻兄弟选择器</span><br><span class="line"></span><br><span class="line">.active+p &#123;</span><br><span class="line">background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/6A1btLOoUj8aGrS.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通用兄弟选择器</span><br><span class="line"></span><br><span class="line">.active~p&#123;</span><br><span class="line">background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/r9o3BZKMmi4QbUH.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2、结构伪类选择器</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/R5wAiqCLu4spD3O.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>使用CSS3结构伪类选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>li1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>li2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>li3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/7FAfLXUTpVzY1hR.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul li:first-child&#123; background: red;&#125;</span><br><span class="line">ul li:last-child&#123; background: green;&#125;</span><br><span class="line">p:nth-child(1)&#123; background: yellow;&#125;</span><br><span class="line">p:nth-of-type(2)&#123; background: blue;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/hxAPwYitNIgS3qU.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">小结</span><br><span class="line">使用E F:nth-child(n)和E F:nth-of-type(n)的 关键点</span><br><span class="line">E F:nth-child(n)在父级里从一个元素开始查找，不分类型</span><br><span class="line">E F:nth-of-type(n)在父级里先看类型，再看位置</span><br><span class="line">3、属性选择器</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/NRFMOix8Y5pC7Kf.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E[attr]属性选择器</span><br><span class="line">a[id] &#123;</span><br><span class="line">background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/L2oxWMsYFdibkta.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E[attr=val]属性选择器</span><br><span class="line"></span><br><span class="line">a[id=first] &#123;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/d8rpvu4PmJskA5L.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E[attr*=val]属性选择器</span><br><span class="line"></span><br><span class="line">a[class*=links] &#123;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/TkSOb6hqrxF97lu.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E[attr^=val]属性选择器</span><br><span class="line">a[href^=http] &#123;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/ZVMRi4T2GXkwLCo.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E[attr$=val]属性选择器</span><br><span class="line">a[href$=png] &#123;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/PchvDaKNnliLfeH.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">小结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/AtGgduLjSizHUwF.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2、美化网页元素</span><br><span class="line">本章目标：</span><br><span class="line">会使用CSS设置字体样式和文本样式</span><br><span class="line">会使用CSS设置超链接样式</span><br><span class="line">会使用CSS设置列表样式</span><br><span class="line">会使用CSS设置背景样式</span><br><span class="line">会使用CSS设置渐变效果</span><br><span class="line"></span><br><span class="line">2.1、为什么使用CSS</span><br><span class="line">【查看淘宝页面，让学员观察，重点记住了什么东西】</span><br><span class="line">因此使用CSS样式美化网页文本具有如下意义。</span><br><span class="line">1. 有效的传递页面信息</span><br><span class="line">2. 使用CSS美化过的页面文本，使页面漂亮、美观，吸引用户</span><br><span class="line">3. 可以很好的突出页面的主题内容，使用户第一眼可以看到页面主要内容</span><br><span class="line">4. 具有良好的用户体验</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">span</span>&gt;</span>标签</span><br><span class="line"><span class="tag">&lt; <span class="attr">span</span>&gt;</span>标签 的作用：能让某几个文字或者某个词语凸显出来，从而添加对应的样式！</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>好好学习，<span class="tag">&lt;<span class="name">span</span>&gt;</span>天天向上<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2.2、字体样式</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/byoAx9G7j8nuB4v.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">字体类型 font-family</span><br><span class="line"></span><br><span class="line">p&#123;font-family:Verdana,&quot;楷体&quot;;&#125;</span><br><span class="line">body&#123;font-family: Times,&quot;Times New Roman&quot;, &quot;楷体&quot;;&#125;</span><br><span class="line"></span><br><span class="line">同时设置中文和英文时，计算机如何识别中英文不同类型</span><br><span class="line"></span><br><span class="line">字体大小 font-size</span><br><span class="line">单位</span><br><span class="line">px（像素）</span><br><span class="line">em、rem、cm、mm、pt、pc</span><br><span class="line">h1&#123;font-size:24px;&#125;</span><br><span class="line">h2&#123;font-size:16px;&#125;</span><br><span class="line">h3&#123;font-size:2em;&#125;</span><br><span class="line">span&#123;font-size:12pt;&#125;</span><br><span class="line">strong&#123;font-size:13pc;&#125;</span><br><span class="line"></span><br><span class="line">字体风格 font-style</span><br><span class="line">normal、italic和oblique</span><br><span class="line"></span><br><span class="line">字体的粗细 font-weight</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/3sOtbaj5iIEMSYV.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">字体属性 font</span><br><span class="line">字体属性的顺序：字体风格→字体粗细→字体大小→字体类型</span><br><span class="line"></span><br><span class="line">p span&#123;</span><br><span class="line">font:oblique bold 12px &quot;楷体&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">文本样式</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/SHjRErOQLAwIFlP.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文本颜色color</span><br><span class="line">RGB</span><br><span class="line">十六进制方法表示颜色：前两位表示红色分量，中间两位表示绿色分量，最后两位表示蓝色分</span><br><span class="line">量</span><br><span class="line">rgb(r,g,b) : 正整数的取值为0～255</span><br><span class="line">RGBA</span><br><span class="line">在RGB基础上增加了控制alpha透明度的参数，其中这个透明通道值为0～1</span><br><span class="line"></span><br><span class="line">color:#A983D8;</span><br><span class="line">color:#EEFF66;</span><br><span class="line">color:rgb(0,255,255);</span><br><span class="line">color:rgba(0,0,255,0.5);</span><br><span class="line"></span><br><span class="line">排版文本段落</span><br><span class="line">水平对齐方式：text-align属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/x7u9wFNftpYG4Xn.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">首行缩进：text-indent：em或px</span><br><span class="line">行高：line-height：px</span><br><span class="line"></span><br><span class="line">文本修饰和垂直对齐</span><br><span class="line">文本装饰：text-decoration属性（后面的讲解中会大量用到）</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/n7OrSilJwUDdvfp.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">垂直对齐方式：vertical-align属性：middle、top、bottom</span><br><span class="line"></span><br><span class="line">2.4、文本阴影</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/gZ8Euk3vFiVUz5B.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">text-shadow属性在CSS2.0中出现，但迟迟未被各大浏览器所支持，因此在CSS2.1中被废弃，如今在</span><br><span class="line">CSS3中得到了各大浏览器的支持！</span><br><span class="line"></span><br><span class="line">2.5、超链接伪类</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/8v5taAzwNSOJIkZ.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用CSS设置超链接</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/BbvcenRTUXZjgou.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.6、列表样式</span><br><span class="line">list-style-type</span><br><span class="line">list-style-image</span><br><span class="line">list-style-position</span><br><span class="line">list-style</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/cewqCufHj5apJ86.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">上网时大家都会看到在浏览的网页中用到列表时很少使用CSS自带的列表标记，而是使用设计的图标，</span><br><span class="line">那么大家会想使用list-style-image就可以了。可是list-style-position不能准确地定位图像标记的位置，通常，网页中图标的位置都是非常精确的。在实际的网页制作中，通常使用list-style或list-style-type设置项目无标记符号，然后通过背景图像的方式把设计的图标设置成列表项标记。在网页制作中，liststyle和list-style-type两个属性是大家经常用到的，而另两个属性则不太常用，因此在这里大家牢记liststyle和list-style-type的用法即可！</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/WLYfJ9nP5piDBCO.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.7、背景样式</span><br><span class="line">常见的背景样式</span><br><span class="line">背景图像</span><br><span class="line">background-image</span><br><span class="line">背景颜色</span><br><span class="line">background-color</span><br><span class="line">设置背景图像</span><br><span class="line">background-image属性</span><br><span class="line">background-repeat属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/OMleacpT7kXhfR8.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">背景定位：background-position属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/NdbGVM189Yw4Rpx.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">设置背景</span><br><span class="line">背景属性：background属性（背景样式简写）</span><br><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">font-size:18px;</span><br><span class="line">font-weight:bold;</span><br><span class="line">color:#FFF;</span><br><span class="line">text-indent:1em;</span><br><span class="line">line-height:35px;</span><br><span class="line">background:#C00 url(../image/arrow-down.gif) 205px 10px no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">background: 背景颜色 背景图像 背景定位 背景不重复显示</span><br><span class="line"></span><br><span class="line">背景尺寸 background-size</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/KGnBiDx6lUhFrsN.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.8、CSS渐变样式</span><br><span class="line">网站推荐：http://color.oulu.me/</span><br><span class="line">线性渐变</span><br><span class="line">颜色沿着一条直线过渡：从左到右、从右到左、从上到下等</span><br><span class="line">径向渐变</span><br><span class="line">圆形或椭圆形渐变，颜色不再沿着一条直线变化，而是从一个起点朝所有方向混合</span><br><span class="line"></span><br><span class="line">CSS3渐变兼容</span><br><span class="line">IE浏览器是Trident内核，加前缀：-msChrome浏览器是Webkit内核，加前缀：-webkitSafari浏览器是Webkit内核，加前缀：-webkitOpera浏览器是Blink内核，加前缀：-oFirefox浏览器是Mozilla内核，加前缀：-moz</span><br><span class="line"></span><br><span class="line">线性渐变</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/frzNOucdmWqhs37.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">兼容Webkit内核的浏览器</span><br><span class="line"></span><br><span class="line">-webkit-linear-gradient ( position, color1, color2,…)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/v71FoLpfQ2ml48C.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3、盒子模型</span><br><span class="line">本章目标</span><br><span class="line">理解盒子模型及其构成</span><br><span class="line">会计算盒子模型尺寸</span><br><span class="line">会使用盒子模型的两种解析方式来布局网页</span><br><span class="line">会使用圆角属性给网页元素添加圆角效果</span><br><span class="line">会使用盒子阴影属性给网页元素添加阴影效果</span><br><span class="line"></span><br><span class="line">3.1、什么是盒子模型</span><br><span class="line">讲解盒子模型及属性，并说明边框、外边框和内边框都是四个边，最后介绍盒子模型的立体结构</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/2BWSvxUsGyXT8h9.png"></p>
<p><img src="https://i.loli.net/2020/10/05/L7BrychXkRAFaYz.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3.2、边框</span><br><span class="line">边框颜色 border-color</span><br><span class="line">边框颜色设置方式与文本颜色对比讲解，都是使用十六进制</span><br><span class="line">强调同时设置4个边框颜色时，顺序为上右下左</span><br><span class="line">详细讲解分别上、下、左、右各边框颜色的不同设置方式，及属性值的顺序</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/hc6QERXmMLtaGWw.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">边框粗细 border-width</span><br><span class="line">thin</span><br><span class="line">medium</span><br><span class="line">thick</span><br><span class="line">像素值</span><br><span class="line"></span><br><span class="line">border-top-width:5px;</span><br><span class="line">border-right-width:10px;</span><br><span class="line">border-bottom-width:8px;</span><br><span class="line">border-left-width:22px;</span><br><span class="line">border-width:5px ;</span><br><span class="line">border-width:20px 2px;</span><br><span class="line">border-width:5px 1px 6px;</span><br><span class="line">border-width:1px 3px 5px 2px;</span><br><span class="line"></span><br><span class="line">边框样式 border-style</span><br><span class="line">none</span><br><span class="line">hidden</span><br><span class="line">dotted</span><br><span class="line">dashed</span><br><span class="line">solid</span><br><span class="line">double</span><br><span class="line"></span><br><span class="line">border-top-style:solid;</span><br><span class="line">border-right-style:solid;</span><br><span class="line">border-bottom-style:solid;</span><br><span class="line">border-left-style:solid;</span><br><span class="line">border-style:solid ;</span><br><span class="line">border-style:solid dotted;</span><br><span class="line">border-style:solid dotted dashed;</span><br><span class="line">border-style:solid dotted dashed double;</span><br><span class="line"></span><br><span class="line">border简写</span><br><span class="line">同时设置边框的颜色、粗细和样式</span><br><span class="line"></span><br><span class="line">border:1px solid #3a6587;</span><br><span class="line">border: 1px dashed red;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/4qUTI8vOGPrpELZ.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3.3、内外边距</span><br><span class="line">外边距 margin</span><br><span class="line">margin-top</span><br><span class="line">margin-right</span><br><span class="line">margin-bottom</span><br><span class="line">margin-left</span><br><span class="line"></span><br><span class="line">margin-top: 1 px</span><br><span class="line">margin-right : 2 px</span><br><span class="line">margin-bottom : 2 px</span><br><span class="line">margin-left : 1 px</span><br><span class="line">margin :3px 5px 7px 4px;</span><br><span class="line">margin :3px 5px;</span><br><span class="line">margin :3px 5px 7px;</span><br><span class="line">margin :8px;</span><br><span class="line"></span><br><span class="line">外边距的妙用：网页居中对齐</span><br><span class="line">margin:0px auto;</span><br><span class="line"></span><br><span class="line">网页居中对齐的必要条件</span><br><span class="line">块元素</span><br><span class="line">固定宽度</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/cEsMl1hPz9jniLk.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">内边距 padding</span><br><span class="line">padding-left</span><br><span class="line">padding-right</span><br><span class="line">padding-top</span><br><span class="line">padding-bottom</span><br><span class="line"></span><br><span class="line">padding-left:10px;</span><br><span class="line">padding-right: 5px;</span><br><span class="line">padding-top: 20px;</span><br><span class="line">padding-bottom:8px;</span><br><span class="line">padding:20px 5px 8px 10px ;</span><br><span class="line">padding:10px 5px;</span><br><span class="line">padding:30px 8px 10px ;</span><br><span class="line">padding:10px;</span><br><span class="line"></span><br><span class="line">3.4、盒子型模尺寸</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xpiz2It7k6draQ5.png"></p>
<p><img src="https://i.loli.net/2020/10/05/gGqD92iHZXk165M.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>box-sizing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">padding: 5px;</span><br><span class="line">margin: 10px;</span><br><span class="line"><span class="css"><span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000000</span>;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line"><span class="css"><span class="comment">/*box-sizing: content-box; /!* 默认值*!/*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.5、圆角边框</span><br><span class="line"> border-radius: 20px 10px 50px 30px;</span><br><span class="line">四个属性值按顺时针排列</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/PqJSI24M69Hw8Gz.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">border-radius制作特殊图形：圆形</span><br><span class="line">利用border-radius属性制作圆形的两个要点</span><br><span class="line">元素的宽度和高度必须相同</span><br><span class="line">圆角的半径为元素宽度的一半，或者直接设置圆角半径值为50%</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">border: 4px solid red;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>border-radius制作圆形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">border: 4px solid red;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用border-radius制作特殊图形：半圆形</span><br><span class="line">利用border-radius属性制作半圆形的两个要点</span><br><span class="line">制作上半圆或下半圆时，元素的宽度是高度的2倍，而且圆角半径为元素的高度值</span><br><span class="line">制作左半圆或右半圆时，元素的高度是宽度的2倍，而且圆角半径为元素的宽度值</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/uFoxYea3Q4rk5vV.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>border-radius制作半圆形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">background: red;</span><br><span class="line">margin: 30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(1)</span>&#123;</span></span><br><span class="line">width: 100px;</span><br><span class="line">height: 50px;</span><br><span class="line">border-radius: 50px 50px 0 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(2)</span>&#123;</span></span><br><span class="line">width: 100px;</span><br><span class="line">height: 50px;</span><br><span class="line"><span class="css"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:0</span> 0 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(3)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 100px;</span><br><span class="line"><span class="css"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:0</span> 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(4)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 100px;</span><br><span class="line">border-radius: 50px 0 0 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用border-radius制作特殊图形：扇形</span><br><span class="line">利用border-radius属性制作扇形遵循“三同，一不同”原则</span><br><span class="line">“三同”是元素宽度、高度、圆角半径相同</span><br><span class="line">“一不同”是圆角取值位置不同</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/DjFO5zvWMKkXyfB.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>border-radius制作扇形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">background: red;</span><br><span class="line">margin: 30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(1)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 50px;</span><br><span class="line">border-radius: 50px 0 0 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(2)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 50px;</span><br><span class="line"><span class="css"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:0</span> 50<span class="selector-tag">px</span> 0 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(3)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 50px;</span><br><span class="line"><span class="css"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:0</span> 0 50<span class="selector-tag">px</span> 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(4)</span>&#123;</span></span><br><span class="line">width: 50px;</span><br><span class="line">height: 50px;</span><br><span class="line">border-radius: 0 0 0 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.6、盒子阴影</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xQLX6UmoGWjlC1p.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>box-shadow的使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">border-radius: 8px;</span><br><span class="line">margin: 20px;</span><br><span class="line"><span class="css"><span class="comment">/*box-shadow: 20px 10px 10px #06c; /!*内阴影*!/*/</span></span></span><br><span class="line">/*box-shadow: 0px 0px 20px #06c; /!*只设置模糊半径的阴影</span><br><span class="line">*!/*/</span><br><span class="line"><span class="css"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-id">#06c</span>; <span class="comment">/*内阴影*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.7、小结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/We1AaoQG7By5NX6.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">4、浮动</span><br><span class="line">本章目标：</span><br><span class="line">会使用display属性排版网页元素</span><br><span class="line">会使用float属性排版网页元素</span><br><span class="line">会使用float属性创建横向多列布局</span><br><span class="line">会使用四种防止父级边框塌陷的清除浮动的方法</span><br><span class="line">4.1、标准文档流</span><br><span class="line">标准文档流：指元素根据块元素或行内元素的特性按从上到下，从左到右的方式自然排列。这也是元素</span><br><span class="line">默认的排列方式</span><br><span class="line">标准文档流组成</span><br><span class="line">块级元素（block）</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>…<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">div</span>&gt;</span>、列表</span><br><span class="line">内联元素（inline）</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>、<span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">img</span>/&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>...</span><br><span class="line">内联标签可以包含于块级标签中，成为它的子元素，而反过来则不成立</span><br><span class="line"></span><br><span class="line">4.2、display</span><br><span class="line">display属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/l9MyKdYhqL5HRBr.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">display:block;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/UEvpc6du5ingYCx.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">display:inline;</span><br><span class="line"></span><br><span class="line">display:inline-block;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/h19IHeNoVY5kA4z.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">display:none;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/C1aRsMjZIFP2XkH.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">display特性</span><br><span class="line">块级元素与行级元素的转变（block、inline）</span><br><span class="line">控制块元素排到一行（inline-block）</span><br><span class="line">控制元素的显示和隐藏（none）</span><br><span class="line"></span><br><span class="line">块元素排在一行的方法</span><br><span class="line">可以使用什么属性使块元素排在一行？</span><br><span class="line">inline-block</span><br><span class="line">float</span><br><span class="line">刚刚学过的inline-block；然后介绍还有一种方式可以实现让块元素排在一行。引出浮动。</span><br><span class="line">4.3、浮动</span><br><span class="line">float属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/Y1Qtclq6uoTXsbV.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日用品&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer02&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图书&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer03&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;鞋子&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer04&quot;</span>&gt;</span>浮动的盒子……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">左浮动</span><br><span class="line">.layer01 &#123;</span><br><span class="line">border:1px #F00 dashed;</span><br><span class="line">float:left;</span><br><span class="line">&#125;</span><br><span class="line">.layer02 &#123;</span><br><span class="line">border:1px #00F dashed;</span><br><span class="line">float:left;</span><br><span class="line">&#125;</span><br><span class="line">.layer03 &#123;</span><br><span class="line">border:1px #060 dashed;</span><br><span class="line">float:left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">右浮动</span><br><span class="line">.layer01 &#123;</span><br><span class="line">border:1px #F00 dashed;</span><br><span class="line">float:right;</span><br><span class="line">&#125;</span><br><span class="line">.layer02 &#123;</span><br><span class="line">border:1px #00F dashed;</span><br><span class="line">float:right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.4、边框塌陷</span><br><span class="line">layer04设置宽度和右浮动后，为什么边框塌陷了？怎么解决？</span><br><span class="line">浮动元素脱离标准文档流</span><br><span class="line">清除浮动</span><br><span class="line">clear属性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/L6gx8dlw4sqa92J.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.layer04 &#123;</span><br><span class="line">clear:both; #清除两侧浮动</span><br><span class="line">&#125;</span><br><span class="line">.layer04 &#123;</span><br><span class="line">clear:left; #清除左侧浮动</span><br><span class="line">&#125;</span><br><span class="line">.layer04 &#123;</span><br><span class="line">clear:right; #清除右侧浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解决父级边框塌陷的方法</span><br><span class="line">clear属性可以清除浮动对其他元素造成的影响，可是依然解决不了父级边框塌陷问题，怎么办？</span><br><span class="line"></span><br><span class="line">浮动元素后面加空div</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日用品&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer02&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图书&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer03&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;鞋子&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer04&quot;</span>&gt;</span>浮动的盒子……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.clear&#123; clear: both; margin: 0; padding: 0;</span><br><span class="line"></span><br><span class="line">设置父元素的高度</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日用品&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer02&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图书&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer03&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;鞋子&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer04&quot;</span>&gt;</span>浮动的盒子……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">#father &#123;height: 400px; border:1px #000 solid; &#125;</span><br><span class="line"></span><br><span class="line">父级添加overflow属性（溢出处理）</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/fBlAqRY5Zsn6NhM.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">hidden属性值，这个值在网页中经常使用，通常与<span class="tag">&lt; <span class="attr">div</span>&gt;</span>宽度结合使用设置<span class="tag">&lt; <span class="attr">div</span>&gt;</span>自动扩展高度，</span><br><span class="line">或者隐藏超出的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日用品&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer02&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图书&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer03&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;鞋子&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer04&quot;</span>&gt;</span>浮动的盒子……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">#father &#123;overflow: hidden;border:1px #000 solid; &#125;</span><br><span class="line"></span><br><span class="line">父级添加伪类after</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日用品&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer02&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图书&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer03&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/photo-3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;鞋子&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer04&quot;</span>&gt;</span>浮动的盒子……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.clear:after&#123;</span><br><span class="line">content: &#x27;&#x27;; /*在clear类后面添加内容为空*/</span><br><span class="line">display: block; /*把添加的内容转化为块元素*/</span><br><span class="line">clear: both; /*清除这个元素两边的浮动*/</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">小结</span><br><span class="line">【清除浮动，防止父级边框塌陷的四种方法】</span><br><span class="line">浮动元素后面加空div</span><br><span class="line">简单，空div会造成HTML代码冗余</span><br><span class="line">设置父元素的高度</span><br><span class="line">简单，元素固定高会降低扩展性</span><br><span class="line">父级添加overflow属性</span><br><span class="line">简单，下拉列表框的场景不能用</span><br><span class="line">父级添加伪类after</span><br><span class="line">写法比上面稍微复杂一点，但是没有副作用，推荐使用</span><br><span class="line"></span><br><span class="line">4.5、inline-block和float区别</span><br><span class="line">display:inline-block</span><br><span class="line">可以让元素排在一行，并且支持宽度和高度，代码实现起来方便</span><br><span class="line">位置方向不可控制，会解析空格</span><br><span class="line">IE 6、IE 7上不支持</span><br><span class="line">float</span><br><span class="line">可以让元素排在一行并且支持宽度和高度，可以决定排列方向</span><br><span class="line">float 浮动以后元素脱离文档流，会对周围元素产生影响，必须在它的父级上添加清除浮动的</span><br><span class="line">样式</span><br><span class="line">4.6、小结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/myAjpwZHF9MvYxn.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">5、定位</span><br><span class="line">本章目标：</span><br><span class="line">会使用position定位网页元素</span><br><span class="line">会使用z-index属性调整定位元素的堆叠次序</span><br><span class="line"></span><br><span class="line">5.1、定位在网页中的应用</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/5jpAiD9WXLqR4v2.png"></p>
<p><img src="https://i.loli.net/2020/10/05/x5bQ7DsgVew3RU1.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">5.2、相对定位</span><br><span class="line">position属性</span><br><span class="line">static：默认值，没有定位</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/HYaMAxTI2WjX6ws.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">relative：相对定位</span><br><span class="line">相对自身原来位置进行偏移，偏移设置：top、left、right、bottom</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/HLpjXlSZobgBa1x.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">相对定位元素的规律</span><br><span class="line">设置相对定位的盒子会相对它原来的位置，通过指定偏移，到达新的位置</span><br><span class="line">设置相对定位的盒子仍在标准文档流中，它对父级盒子和相邻的盒子都没有任何影响</span><br><span class="line">设置相对定位的盒子原来的位置会被保留下来</span><br><span class="line">设置第二个盒子右浮动，再设置第一、第二盒子相对定位</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/sjR15fCSKk92nWY.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#first &#123;</span><br><span class="line">background-color:#FC9;</span><br><span class="line">border:1px #B55A00 dashed;</span><br><span class="line">position:relative;</span><br><span class="line">right:20px;</span><br><span class="line">bottom:20px;</span><br><span class="line">&#125;</span><br><span class="line">#second &#123;</span><br><span class="line">background-color:#CCF;</span><br><span class="line">border:1px #0000A8 dashed;</span><br><span class="line">float:right;</span><br><span class="line">position:relative;</span><br><span class="line">left:20px;</span><br><span class="line">top:-20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/DBbm14ZRhU9vwtW.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">5.3、绝对定位</span><br><span class="line">absolute属性值：偏移设置： left、right、top、bottom</span><br><span class="line">绝对定位：</span><br><span class="line">使用了绝对定位的元素以它最近的一个“已经定位”的“祖先元素” 为基准进行偏移</span><br><span class="line">如果没有已经定位的祖先元素，会以浏览器窗口为基准进行定位</span><br><span class="line">绝对定位的元素从标准文档流中脱离，这意味着它们对其他元素的定位不会造成影响</span><br><span class="line">元素位置发生偏移后，它原来的位置不会被保留下来</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/wuqLtn9z5xbUegN.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">设置了绝对定位但没有设置偏移量的元素将保持在原来的位置。</span><br><span class="line">在网页制作中可以用于需要使某个元素脱离标准流，而仍然希望它保持在原来的位置的情况</span><br><span class="line"></span><br><span class="line">5.4、固定定位</span><br><span class="line">fixed属性值</span><br><span class="line">偏移设置： left、right、top、bottom</span><br><span class="line">类似绝对定位，不过区别在于定位的基准不是祖先元素，而是浏览器窗口</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/gAKws3lriHJjQ81.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">5.5、定位小结</span><br><span class="line"></span><br><span class="line">相对定位</span><br><span class="line">相对定位的特性</span><br><span class="line">相对于自己的初始位置来定位</span><br><span class="line">元素位置发生偏移后，它原来的位置会被保留下来</span><br><span class="line">层级提高，可以把标准文档流中的元素及浮动元素盖在下边</span><br><span class="line">相对定位的使用场景</span><br><span class="line">相对定位一般情况下很少自己单独使用，都是配合绝对定位使用，为绝对定位创造定位父级而</span><br><span class="line">又不设置偏移量</span><br><span class="line"></span><br><span class="line">绝对定位</span><br><span class="line"></span><br><span class="line">绝对定位的特性</span><br><span class="line">绝对定位是相对于它的定位父级的位置来定位，如果没有设置定位父级，则相对浏览器窗口来定位</span><br><span class="line">元素位置发生偏移后，原来的位置不会被保留</span><br><span class="line">层级提高，可以把标准文档流中的元素及浮动元素盖在下边</span><br><span class="line">设置绝对定位的元素脱离文档流</span><br><span class="line"></span><br><span class="line">绝对定位的使用场景</span><br><span class="line">一般情况下，绝对定位用在下拉菜单、焦点图轮播、弹出数字气泡、特别花边等场景</span><br><span class="line"></span><br><span class="line">固定定位</span><br><span class="line"></span><br><span class="line">固定定位的特性</span><br><span class="line">相对浏览器窗口来定位</span><br><span class="line">偏移量不会随滚动条的移动而移动</span><br><span class="line"></span><br><span class="line">固定定位的使用场景</span><br><span class="line">一般在网页中被用在窗口左右两边的固定广告、返回顶部图标、吸顶导航栏等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.6、z-index属性</span><br><span class="line"></span><br><span class="line">调整元素定位时重叠层的上下位置</span><br><span class="line">z-index属性值：整数，默认值为0</span><br><span class="line">设置了positon属性时，z-index属性可以设置各元素之间的重叠高低关系</span><br><span class="line">z-index值大的层位于其值小的层上方</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/eNqLzyx43ZmQ91V.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">5.7、小结</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/MSmXEULIOoHQkc9.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">6、制作网页动画</span><br><span class="line">本章目标</span><br><span class="line">会使用transform 2D变形设置网页元素样式</span><br><span class="line">会使用transition制作过渡动画</span><br><span class="line">会使用animation制作网页动画</span><br><span class="line">如何在网页中实现动画效果？</span><br><span class="line">1. 动态图片</span><br><span class="line">2. Flash</span><br><span class="line">3. JavaScript</span><br><span class="line">Flash需要插件支持，文件体积大</span><br><span class="line">从这次课开始学习使用CSS代码来完成动画：存在兼容性问题</span><br><span class="line">CSS3变形</span><br><span class="line">CSS3过渡</span><br><span class="line">CSS3动画</span><br><span class="line">6.1、CSS变形</span><br><span class="line">CSS3变形是一些效果的集合</span><br><span class="line">如平移、旋转、缩放、倾斜效果</span><br><span class="line">简言之，平移就是一个变形，旋转就是一个变形。。。</span><br><span class="line">每个效果都可以称为变形（transform），它们可以分别操控元素发生平移、旋转、缩放、倾斜等</span><br><span class="line">变化</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/ljrq6Rnw53QYBsE.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">变形函数</span><br><span class="line">translate()：平移函数，基于X、Y坐标重新定位元素的位置</span><br><span class="line">scale()：缩放函数，可以使任意元素对象尺寸发生变化</span><br><span class="line">rotate()：旋转函数，取值是一个度数值</span><br><span class="line">skew()：倾斜函数，取值是一个度数值</span><br><span class="line">2D位移</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/jKQ9DO4g3paeYBt.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">一个方向上的偏移</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/j8NMhKxgOyzQiVm.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2D缩放</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/j8NMhKxgOyzQiVm.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">scale()函数能够用来缩放元素大小，该函数包含两个参数值，分别用来定义宽度和高度的缩放比例，默</span><br><span class="line">认值为1，0～0.99的任意值都可以使元素缩小，而任何大于1的值都能让元素放大。</span><br><span class="line">scale()函数和translate()函数的语法非常相似，可以只接收一个值，也可以接收两个值，只有一个值</span><br><span class="line">时，第二个值默认和第一个值相等，例如，scale（1，1）元素不会有任何变化，而scale（2，2）会让</span><br><span class="line">元素放大2倍</span><br><span class="line"></span><br><span class="line">2D倾斜</span><br><span class="line">可以仅设置沿着X轴或Y轴方向倾斜</span><br><span class="line">skewX（ax）：表示只设置X轴的倾斜</span><br><span class="line">skewY（ay）：表示只设置Y轴的倾斜</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xpW4FzNiohXglSL.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2D旋转</span><br><span class="line"></span><br><span class="line">rotate(a);</span><br><span class="line"></span><br><span class="line">参数a单位使用deg表示</span><br><span class="line">参数a取正值时元素相对原来中心顺时针旋转</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xliKky9jgeSGYnM.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">rotate( )函数只是旋转，而不会改变元素的形状</span><br><span class="line">skew( )函数是倾斜，元素不会旋转，会改变元素的形状</span><br><span class="line"></span><br><span class="line">6.2、CSS过渡</span><br><span class="line">transition呈现的是一种过渡，是一种动画转换的过程，如渐现、渐弱、动画快慢等</span><br><span class="line">CSS3 transition的过渡功能更像是一种“黄油”，通过一些CSS的简单动作触发样式平滑过渡</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/UKrXyF1m7uAoh9T.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">过渡属性的使用</span><br><span class="line">过渡属性（ transition-property ）</span><br><span class="line">定义转换动画的CSS属性名称</span><br><span class="line">IDENT：指定的CSS属性（width、height、background-color属性等）</span><br><span class="line">all：指定所有元素支持transition-property属性的样式，一般为了方便都会使用all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">过渡所需的时间（ transition-duration ）</span><br><span class="line">定义转换动画的时间长度，即从设置旧属性到换新属性所花费的时间，单位为秒（s）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">过渡动画函数（ transition-timing-function ）</span><br><span class="line">指定浏览器的过渡速度，以及过渡期间的操作进展情况，通过给过渡添加一个函数来指定动画</span><br><span class="line">的快慢方式</span><br><span class="line">ease：速度由快到慢（默认值）</span><br><span class="line">linear：速度恒速（匀速运动）</span><br><span class="line">ease-in：速度越来越快（渐显效果）</span><br><span class="line">ease-out：速度越来越慢（渐隐效果）</span><br><span class="line">ease-in-out：速度先加速再减速（渐显渐隐效果）</span><br><span class="line"></span><br><span class="line">过渡延迟时间（ transition-delay ）</span><br><span class="line">指定一个动画开始执行的时间，当改变元素属性值后多长时间去执行过渡效果</span><br><span class="line">正值：元素过渡效果不会立即触发，当过了设置的时间值后才会被触发</span><br><span class="line">负值：元素过渡效果会从该时间点开始显示，之前的动作被截断</span><br><span class="line">0：默认值，元素过渡效果立即执行</span><br><span class="line"></span><br><span class="line">过渡的触发机制</span><br><span class="line">伪类触发</span><br><span class="line">：hover</span><br><span class="line">：active</span><br><span class="line">：focus</span><br><span class="line">：checked</span><br><span class="line">媒体查询：通过@media属性判断设备的尺寸，方向等</span><br><span class="line">JavaScript触发：用JavaScript脚本触发</span><br><span class="line">注意：媒体查询和JavaScript的方法在后面课程会详细讲解，现在只需要大家了解即可。重点需要掌握伪</span><br><span class="line">类触发的方法，这种方法也是实际开发中用的比较多的一种</span><br><span class="line"></span><br><span class="line">使用transition实现过渡动画的使用步骤</span><br><span class="line">在默认样式中声明元素的初始状态样式</span><br><span class="line">声明过渡元素最终状态样式，如悬浮状态</span><br><span class="line">在默认样式中通过添加过渡函数，添加一些不同的样式</span><br><span class="line"></span><br><span class="line">6.3、CSS动画</span><br><span class="line">animation动画简介</span><br><span class="line">animation实现动画主要由两个部分组成</span><br><span class="line">通过类似Flash动画的关键帧来声明一个动画</span><br><span class="line">在animation属性中调用关键帧声明的动画实现一个更为复杂的动画效果</span><br><span class="line"></span><br><span class="line">CSS3动画的使用过程</span><br><span class="line">设置关键帧</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/8kvR1NLtsMpKFU4.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@keyframes的浏览器兼容性</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/19Y7Bmxejw6P8AS.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">写兼容的时候浏览器前缀是放在@keyframes中间</span><br><span class="line">例如：@-webkit-keyframes、@-moz- keyframes</span><br><span class="line">调用关键帧</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/xCEgqoe1IY9a4sw.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">动画的播放次数（animation-iteration-count）</span><br><span class="line">值通常为整数，默认值为1</span><br><span class="line">特殊值infinite，表示动画无限次播放</span><br><span class="line"></span><br><span class="line">动画的播放方向（animation-direction）</span><br><span class="line">normal，动画每次都是循环向前播放</span><br><span class="line">alternate，动画播放为偶数次则向前播放</span><br><span class="line"></span><br><span class="line">动画的播放状态（animation-play-state）</span><br><span class="line">running将暂停的动画重新播放</span><br><span class="line">paused将正在播放的元素动画停下来</span><br><span class="line"></span><br><span class="line">动画发生的操作（animation-fill-mode）</span><br><span class="line">forwards表示动画在结束后继续应用最后关键帧的位置</span><br><span class="line">backwards表示会在向元素应用动画样式时迅速应用动画的初始帧</span><br><span class="line">both表示元素动画同时具有forwards和backwards的效果</span><br><span class="line"></span><br><span class="line">总结:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/05/m7twnjZUOgelF3Y.png"></p>
<h3 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a>三、JavaScript</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">参考网站：https://www.liaoxuefeng.com/wiki/1022910821149312</span><br><span class="line"></span><br><span class="line">1、概述</span><br><span class="line">1.1、前言</span><br><span class="line">JavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于</span><br><span class="line">HTML5的手机App，交互逻辑都是由JavaScript驱动的。</span><br><span class="line">简单地说，JavaScript是一种运行在浏览器中的解释型的编程语言。</span><br><span class="line">那么问题来了，为什么我们要学JavaScript？尤其是当你已经掌握了某些其他编程语言如Java、C++的情</span><br><span class="line">况下。</span><br><span class="line">简单粗暴的回答就是：因为你没有选择。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，</span><br><span class="line">与用户交互。</span><br><span class="line">Flash背后的ActionScript曾经流行过一阵子，不过随着移动应用的兴起，没有人用Flash开发手机App，</span><br><span class="line">所以它目前已经边缘化了。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。</span><br><span class="line">并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。</span><br><span class="line">JavaScript一度被认为是一种玩具编程语言，它有很多缺陷，所以不被大多数后端开发人员所重视。很多</span><br><span class="line">人认为，写JavaScript代码很简单，并且JavaScript只是为了在网页上添加一点交互和动画效果。</span><br><span class="line">但这是完全错误的理解。JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质</span><br><span class="line">量的JavaScript代码更是难上加难。</span><br><span class="line">一个合格的开发人员应该精通JavaScript和其他编程语言。如果你已经掌握了其他编程语言，或者你还什</span><br><span class="line">么都不会，请立刻开始学习JavaScript，不要被Web时代所淘汰。</span><br><span class="line"></span><br><span class="line">1.2、JavaScript历史</span><br><span class="line">要了解JavaScript，我们首先要回顾一下JavaScript的诞生。</span><br><span class="line">在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代</span><br><span class="line">互联网公司。</span><br><span class="line">由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设</span><br><span class="line">计出了JavaScript语言。你没看错，这哥们只用了10天时间。</span><br><span class="line">为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事</span><br><span class="line">实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</span><br><span class="line"></span><br><span class="line">1.3、ECMAScript</span><br><span class="line">因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标</span><br><span class="line">准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语</span><br><span class="line">言的标准，被称为ECMAScript标准。</span><br><span class="line">所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实</span><br><span class="line">现。</span><br><span class="line">那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。</span><br><span class="line">不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为</span><br><span class="line">JavaScript就行了。</span><br><span class="line"></span><br><span class="line">1.4、JavaScript版本</span><br><span class="line">JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任</span><br><span class="line">务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。</span><br><span class="line">此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经</span><br><span class="line">在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪</span><br><span class="line">个版本。</span><br><span class="line">由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导</span><br><span class="line">致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏</span><br><span class="line">览器是无法运行新版本的JavaScript代码的。</span><br><span class="line">不过，JavaScript的核心语法并没有多大变化。我们的教程会先讲JavaScript最核心的用法，然后，针对</span><br><span class="line">ES6讲解新增特性。</span><br><span class="line"></span><br><span class="line">1.5、引入JavaScript</span><br><span class="line">JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到 head 中：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">alert(<span class="string">&#x27;Hello, world&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">由 <span class="tag">&lt;<span class="name">script</span>&gt;</span>...<span class="tag">&lt;/<span class="name">script</span>&gt;</span> 包含的代码就是JavaScript代码，它将直接被浏览器执行。</span><br><span class="line">第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过 <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> 引入这个文件：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">这样， /static/js/abc.js 就会被浏览器执行。</span><br><span class="line">把JavaScript代码放入一个单独的 .js 文件中更利于维护代码，并且多个页面可以各自引用同一</span><br><span class="line">份 .js 文件。</span><br><span class="line">可以在同一个页面中引入多个 .js 文件</span><br><span class="line">还可以在页面中多次编写 <span class="tag">&lt;<span class="name">script</span>&gt;</span> js代码... <span class="tag">&lt;/<span class="name">script</span>&gt;</span> ，浏览器按照顺序依次执行。</span><br><span class="line">有些时候你会看到 <span class="tag">&lt;<span class="name">script</span>&gt;</span> 标签还设置了一个type属性：</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">但这是没有必要的，因为默认的 type 就是JavaScript，所以不必显式地把 type 指定为</span><br><span class="line">JavaScript。</span><br><span class="line"></span><br><span class="line">1.6、IDE推荐</span><br><span class="line">可以用任何文本编辑器来编写JavaScript代码。这里我们推荐以下几种文本编辑器：</span><br><span class="line"></span><br><span class="line">Visual Studio Code</span><br><span class="line">微软出的Visual Studio Code，可以看做迷你版Visual Studio，免费！跨平台！内置</span><br><span class="line">JavaScript支持，强烈推荐使用！</span><br><span class="line"></span><br><span class="line">Sublime Text</span><br><span class="line">Sublime Text是一个好用的文本编辑器，免费，但不注册会不定时弹出提示框。</span><br><span class="line"></span><br><span class="line">Notepad++</span><br><span class="line">Notepad++也是免费的文本编辑器，但仅限Windows下使用。</span><br><span class="line"></span><br><span class="line">WebStorm</span><br><span class="line">WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉</span><br><span class="line">为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。</span><br><span class="line"></span><br><span class="line">IDEA</span><br><span class="line">Java开发人员必备，NB！</span><br><span class="line"></span><br><span class="line">HBuilder</span><br><span class="line">HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。HBuilder的编写用到了</span><br><span class="line">Java、C、Web和Ruby。HBuilder本身主体是由Java编写。它基于Eclipse，所以顺其自然地兼</span><br><span class="line">容了Eclipse的插件。</span><br><span class="line"></span><br><span class="line">1.7、运行JavaScript</span><br><span class="line">要让浏览器运行JavaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript，然后，让浏览器</span><br><span class="line">加载该HTML页面，就可以执行JavaScript代码。</span><br><span class="line">你也许会想，直接在我的硬盘上创建好HTML和JavaScript文件，然后用浏览器打开，不就可以看到效果</span><br><span class="line">了吗？</span><br><span class="line">这种方式运行部分JavaScript代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法</span><br><span class="line">执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以 http:// 开头的地址</span><br><span class="line">来正常执行所有JavaScript代码。</span><br><span class="line"></span><br><span class="line">我的第一个javaScript程序</span><br><span class="line">代码示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 以双斜杠开头直到行末的是注释，注释是浏览器将弹出一个对话框，显示“Hello, world”。你也可以修改两个单引号中间的内容，再试着运行。给人看的，会被浏览器忽略/* 在这中间的也是注释，将被浏览器忽略 */</span></span></span><br><span class="line"><span class="javascript">alert(<span class="string">&#x27;Hello,world&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">浏览器将弹出一个对话框，显示“Hello, world”。你也可以修改两个单引号中间的内容，再试着运行。</span><br><span class="line"></span><br><span class="line">1.8、调试</span><br><span class="line">俗话说得好，“工欲善其事，必先利其器。”，写JavaScript的时候，如果期望显示 ABC ，结果却显示</span><br><span class="line">XYZ ，到底代码哪里出了问题？不要抓狂，也不要泄气，作为小白，要坚信：JavaScript本身没有问</span><br><span class="line">题，浏览器执行也没有问题，有问题的一定是我的代码。</span><br><span class="line">如何找出问题代码？这就需要调试。</span><br><span class="line">怎么在浏览器中调试JavaScript代码呢？</span><br><span class="line">首先，你需要安装Google Chrome浏览器，Chrome浏览器对开发者非常友好，可以让你方便地调试</span><br><span class="line">JavaScript代码。</span><br><span class="line">安装后，随便打开一个网页，然后点击菜单“查看(View)”-“开发者(Developer)”-“开发者工具(Developer</span><br><span class="line">Tools)”，浏览器窗口就会一分为二，下方就是开发者工具：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/09/viKwDnprabgySOI.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">先点击“控制台(Console)“，在这个面板里可以直接输入JavaScript代码，按回车后执行。</span><br><span class="line">要查看一个变量的内容，在Console中输入 <span class="built_in">console</span>.log(a); ，回车后显示的值就是变量的内容。</span><br><span class="line">关闭Console请点击右上角的“×”按钮。请熟练掌握Console的使用方法，在编写JavaScript代码时，经常</span><br><span class="line">需要在Console运行测试代码。</span><br><span class="line">如果你对自己还有更高的要求，可以研究开发者工具的“源码(Sources)”，掌握断点、单步执行等高级调</span><br><span class="line">试技巧。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、快速入门</span><br><span class="line"><span class="number">2.1</span>、基本语法</span><br><span class="line">JavaScript的语法和Java语言类似，每个语句以 ; 结束，语句块用 &#123;...&#125; 。</span><br><span class="line">但是，JavaScript并不强制要求在每个语句的结尾加 ; ，浏览器中负责执行JavaScript代码的引擎会自</span><br><span class="line">动在每个语句的结尾补上 ; 。</span><br><span class="line">让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教</span><br><span class="line">程中，我们不会省略;，所有语句都会添加;。</span><br><span class="line"></span><br><span class="line">例如，下面的一行代码就是一个完整的赋值语句：</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：</span><br><span class="line"><span class="string">&#x27;Hello, world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">下面的一行代码包含两个语句，每个语句用 ; 表示语句结束：</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>; <span class="keyword">var</span> y = <span class="number">2</span>; <span class="comment">// 不建议一行写多个语句!</span></span><br><span class="line"></span><br><span class="line">语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行 &#123;...&#125; 中的所</span><br><span class="line">有语句：</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">z = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意花括号 &#123;...&#125; 内的语句具有缩进，通常是<span class="number">4</span>个空格。缩进不是JavaScript语法要求必须的，但缩进</span><br><span class="line">有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功</span><br><span class="line">能，可以帮助整理代码。</span><br><span class="line">&#123;...&#125; 还可以嵌套，形成层级结构：</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">z = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">z = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">z = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情</span><br><span class="line">况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。</span><br><span class="line">以 <span class="comment">// 开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 这也是注释</span></span><br><span class="line"></span><br><span class="line">另一种块注释是用 <span class="comment">/*...*/</span> 把多行字符包裹起来，把一大“块”视为一个注释：</span><br><span class="line"><span class="comment">/* 从这里开始是块注释</span></span><br><span class="line"><span class="comment">仍然是注释</span></span><br><span class="line"><span class="comment">仍然是注释</span></span><br><span class="line"><span class="comment">注释结束 */</span></span><br><span class="line"></span><br><span class="line">请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span>、数据类型和变量</span><br><span class="line">数据类型</span><br><span class="line">计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，</span><br><span class="line">计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数</span><br><span class="line">据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span></span><br><span class="line">JavaScript不区分整数和浮点数，统一用<span class="built_in">Number</span>表示，以下都是合法的<span class="built_in">Number</span>类型：</span><br><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line"><span class="number">-99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Inf</span></span><br><span class="line"></span><br><span class="line">计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<span class="number">0</span>x前缀和<span class="number">0</span><span class="number">-9</span>，a-f表</span><br><span class="line">示，例如： <span class="number">0xff00</span> ， <span class="number">0xa5b4c3d2</span> ，等等，它们和十进制表示的数值完全一样。</span><br><span class="line"><span class="built_in">Number</span>可以直接做四则运算，规则和数学一致：</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></span><br><span class="line"><span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></span><br><span class="line"></span><br><span class="line">注意 % 是求余运算。</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">字符串是以单引号<span class="string">&#x27;或双引号&quot;括起来的任意文本，比如 &#x27;</span>abc<span class="string">&#x27; ， &quot;xyz&quot; 等等。请注</span></span><br><span class="line"><span class="string">意， &#x27;</span><span class="string">&#x27; 或 &quot;&quot; 本身只是一种表示方式，不是字符串的一部分，因此，字符串 &#x27;</span>abc<span class="string">&#x27; 只有</span></span><br><span class="line"><span class="string">a ， b ， c 这3个字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">布尔值</span></span><br><span class="line"><span class="string">布尔值和布尔代数的表示完全一致，一个布尔值只有 true 、 false 两种值，要么是 true ，要</span></span><br><span class="line"><span class="string">么是 false ，可以直接用 true 、 false 表示布尔值，也可以通过布尔运算计算出来：</span></span><br><span class="line"><span class="string">true; // 这是一个true值</span></span><br><span class="line"><span class="string">false; // 这是一个false值</span></span><br><span class="line"><span class="string">2 &gt; 1; // 这是一个true值</span></span><br><span class="line"><span class="string">2 &gt;= 3; // 这是一个false值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&amp;&amp; 运算是与运算，只有所有都为 true ， &amp;&amp; 运算结果才是 true ：</span></span><br><span class="line"><span class="string">true &amp;&amp; true; // 这个&amp;&amp;语句计算结果为true</span></span><br><span class="line"><span class="string">true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false</span></span><br><span class="line"><span class="string">false &amp;&amp; true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">|| 运算是或运算，只要其中有一个为 true ， || 运算结果就是 true ：</span></span><br><span class="line"><span class="string">false || false; // 这个||语句计算结果为false</span></span><br><span class="line"><span class="string">true || false; // 这个||语句计算结果为true</span></span><br><span class="line"><span class="string">false || true || false; // 这个||语句计算结果为true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">! 运算是非运算，它是一个单目运算符，把 true 变成 false ， false 变成 true ：</span></span><br><span class="line"><span class="string">! true; // 结果为false</span></span><br><span class="line"><span class="string">! false; // 结果为true</span></span><br><span class="line"><span class="string">! (2 &gt; 5); // 结果为true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">布尔值经常用在条件判断中，比如：</span></span><br><span class="line"><span class="string">var age = 15;</span></span><br><span class="line"><span class="string">if (age &gt;= 18) &#123;</span></span><br><span class="line"><span class="string">alert(&#x27;</span>adult<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">alert(&#x27;</span>teenager<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">比较运算符</span></span><br><span class="line"><span class="string">当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</span></span><br><span class="line"><span class="string">2 &gt; 5; // false</span></span><br><span class="line"><span class="string">5 &gt;= 2; // true</span></span><br><span class="line"><span class="string">7 == 7; // true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实际上，JavaScript允许对任意数据类型做比较：</span></span><br><span class="line"><span class="string">false == 0; // true</span></span><br><span class="line"><span class="string">false === 0; // false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要特别注意相等运算符 == 。JavaScript在设计时，有两种比较运算符：</span></span><br><span class="line"><span class="string">第一种是 == 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</span></span><br><span class="line"><span class="string">第二种是 === 比较，它不会自动转换数据类型，如果数据类型不一致，返回 false ，如果一致，</span></span><br><span class="line"><span class="string">再比较。</span></span><br><span class="line"><span class="string">由于JavaScript这个设计缺陷，不要使用 == 比较，始终坚持使用 === 比较。</span></span><br><span class="line"><span class="string">另一个例外是 NaN 这个特殊的Number与所有其他值都不相等，包括它自己：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NaN === NaN; // false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">唯一能判断 NaN 的方法是通过 isNaN() 函数：</span></span><br><span class="line"><span class="string">isNaN(NaN); // true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">最后要注意浮点数的相等比较：</span></span><br><span class="line"><span class="string">1 / 3 === (1 - 2 / 3); // false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小</span></span><br><span class="line"><span class="string">数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</span></span><br><span class="line"><span class="string">Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">null和undefined</span></span><br><span class="line"><span class="string">null 表示一个“空”的值，它和 0 以及空字符串 &#x27;</span><span class="string">&#x27; 不同， 0 是一个数值， &#x27;</span><span class="string">&#x27; 表示长度为0</span></span><br><span class="line"><span class="string">的字符串，而 null 表示“空”。</span></span><br><span class="line"><span class="string">在其他语言中，也有类似JavaScript的 null 的表示，例如Java也用 null ，Swift用 nil ，</span></span><br><span class="line"><span class="string">Python用 None 表示。但是，在JavaScript中，还有一个和 null 类似的 undefined ，它表示“未</span></span><br><span class="line"><span class="string">定义”。</span></span><br><span class="line"><span class="string">JavaScript的设计者希望用 null 表示一个空的值，而 undefined 表示值未定义。事实证明，这并</span></span><br><span class="line"><span class="string">没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用 null 。 undefined 仅仅在判</span></span><br><span class="line"><span class="string">断函数参数是否传递的情况下有用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数组</span></span><br><span class="line"><span class="string">数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例</span></span><br><span class="line"><span class="string">如：</span></span><br><span class="line"><span class="string"> [1, 2, 3.14, &#x27;</span>Hello<span class="string">&#x27;, null, true];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上述数组包含6个元素。数组用 [] 表示，元素之间用 , 分隔。</span></span><br><span class="line"><span class="string">另一种创建数组的方法是通过 Array() 函数实现：</span></span><br><span class="line"><span class="string">new Array(1, 2, 3); // 创建了数组[1, 2, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然而，出于代码的可读性考虑，强烈建议直接使用 [] 。</span></span><br><span class="line"><span class="string">数组的元素可以通过索引来访问。请注意，索引的起始值为 0 ：</span></span><br><span class="line"><span class="string">var arr = [1, 2, 3.14, &#x27;</span>Hello<span class="string">&#x27;, null, true];</span></span><br><span class="line"><span class="string">arr[0]; // 返回索引为0的元素，即1</span></span><br><span class="line"><span class="string">arr[5]; // 返回索引为5的元素，即true</span></span><br><span class="line"><span class="string">arr[6]; // 索引超出了范围，返回undefined</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">对象</span></span><br><span class="line"><span class="string">JavaScript的对象是一组由键-值组成的无序集合，例如：</span></span><br><span class="line"><span class="string">var person = &#123;</span></span><br><span class="line"><span class="string">name: &#x27;</span>Bob<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">age: 20,</span></span><br><span class="line"><span class="string">tags: [&#x27;</span>js<span class="string">&#x27;, &#x27;</span>web<span class="string">&#x27;, &#x27;</span>mobile<span class="string">&#x27;],</span></span><br><span class="line"><span class="string">city: &#x27;</span>Beijing<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">hasCar: true,</span></span><br><span class="line"><span class="string">zipcode: null</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述 person 对象一共定义了6个键值</span></span><br><span class="line"><span class="string">对，其中每个键又称为对象的属性，例如， person 的 name 属性为 &#x27;</span>Bob<span class="string">&#x27; ， zipcode 属性</span></span><br><span class="line"><span class="string">为 null 。</span></span><br><span class="line"><span class="string">要获取一个对象的属性，我们用 对象变量.属性名 的方式：</span></span><br><span class="line"><span class="string">person.name; // &#x27;</span>Bob<span class="string">&#x27;</span></span><br><span class="line"><span class="string">person.zipcode; // null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量</span></span><br><span class="line"><span class="string">变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可</span></span><br><span class="line"><span class="string">以是任意数据类型。</span></span><br><span class="line"><span class="string">变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、 $ 和 _ 的组合，且不能</span></span><br><span class="line"><span class="string">用数字开头。变量名也不能是JavaScript的关键字，如 if 、 while 等。申明一个变量用 var 语</span></span><br><span class="line"><span class="string">句，比如：</span></span><br><span class="line"><span class="string">var a; // 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="string">var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="string">var s_007 = &#x27;</span><span class="number">007</span><span class="string">&#x27;; // s_007是一个字符串</span></span><br><span class="line"><span class="string">var Answer = true; // Answer是一个布尔值true</span></span><br><span class="line"><span class="string">var t = null; // t的值是null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量名也可以用中文，但是，请不要给自己找麻烦。</span></span><br><span class="line"><span class="string">在JavaScript中，使用等号 = 对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反</span></span><br><span class="line"><span class="string">复赋值，而且可以是不同类型的变量，但是要注意只能用 var 申明一次，例如：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var a = 123; // a的值是整数123</span></span><br><span class="line"><span class="string">a = &#x27;</span>ABC<span class="string">&#x27;; // a变为字符串</span></span><br><span class="line"><span class="string">这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须</span></span><br><span class="line"><span class="string">指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int a = 123; // a是整数类型变量，类型用int申明</span></span><br><span class="line"><span class="string">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">和静态语言相比，动态语言更灵活，就是这个原因。</span></span><br><span class="line"><span class="string">请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</span></span><br><span class="line"><span class="string">var x = 10;</span></span><br><span class="line"><span class="string">x = x + 2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果从数学上理解 x = x + 2 那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式 x</span></span><br><span class="line"><span class="string">+ 2 ，得到结果 12 ，再赋给变量 x 。由于 x 之前的值是 10 ，重新赋值后， x 的值变成</span></span><br><span class="line"><span class="string">12 。</span></span><br><span class="line"><span class="string">打印变量X，要显示变量的内容，可以用 console.log(x) ，打开Chrome的控制台就可以看到结果</span></span><br><span class="line"><span class="string">var x = 100;</span></span><br><span class="line"><span class="string">console.log(x);</span></span><br><span class="line"><span class="string">使用 console.log() 代替 alert() 的好处是可以避免弹出烦人的对话框</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.3、strict模式</span></span><br><span class="line"><span class="string">JavaScript在设计之初，为了方便初学者学习，并不强制要求用 var 申明变量。这个设计错误带来了</span></span><br><span class="line"><span class="string">严重的后果：如果一个变量没有通过 var 申明就被使用，那么该变量就自动被申明为全局变量</span></span><br><span class="line"><span class="string">i = 10; // i现在是全局变量</span></span><br><span class="line"><span class="string">在同一个页面的不同的JavaScript文件中，如果都不用 var 申明，恰好都使用了变量 i ，将造成变</span></span><br><span class="line"><span class="string">量 i 互相影响，产生难以调试的错误结果。</span></span><br><span class="line"><span class="string">使用 var 申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍</span></span><br><span class="line"><span class="string">后讲解），同名变量在不同的函数体内互不冲突。</span></span><br><span class="line"><span class="string">为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的</span></span><br><span class="line"><span class="string">JavaScript代码，强制通过 var 申明变量，未使用 var 申明变量就使用的，将导致运行错误。</span></span><br><span class="line"><span class="string">启用strict模式的方法是在JavaScript代码的第一行写上：</span></span><br><span class="line"><span class="string">&#x27;</span>use strict<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器</span></span><br><span class="line"><span class="string">将开启strict模式运行JavaScript。</span></span><br><span class="line"><span class="string">测试一下你的浏览器是否能支持strict模式：</span></span><br><span class="line"><span class="string">&#x27;</span>use strict<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">// 如果浏览器支持strict模式，下面的代码将报ReferenceError错误:</span></span><br><span class="line"><span class="string">abc = &#x27;</span>Hello, world<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">console.log(abc);</span></span><br><span class="line"><span class="string">运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽</span></span><br><span class="line"><span class="string">快升级。</span></span><br><span class="line"><span class="string">不用 var 申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict</span></span><br><span class="line"><span class="string">模式。我们在后面编写的JavaScript代码将全部采用strict模式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.4、字符串</span></span><br><span class="line"><span class="string">JavaScript的字符串就是用 &#x27;</span><span class="string">&#x27; 或 &quot;&quot; 括起来的字符表示。</span></span><br><span class="line"><span class="string">如果 &#x27;</span> 本身也是一个字符，那就可以用 <span class="string">&quot;&quot;</span> 括起来，比如 <span class="string">&quot;I&#x27;m OK&quot;</span> 包含的字符是</span><br><span class="line">I ， <span class="string">&#x27; ， m ，空格， O ， K 这6个字符。</span></span><br><span class="line"><span class="string">如果字符串内部既包含 &#x27;</span> 又包含 <span class="string">&quot; 怎么办？可以用转义字符 \ 来标识，比如：</span></span><br><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">表示的字符串内容是： 还可以用 \u#### 表示一个Unicode字符：I&#x27;m &quot;</span>OK<span class="string">&quot;!</span></span><br><span class="line"><span class="string">转义字符 \ 可以转义很多字符，比如 \n 表示换行， \t 表示制表符，字符 \ 本身也要转义，</span></span><br><span class="line"><span class="string">所以 \\ 表示的字符就是 \ 。</span></span><br><span class="line"><span class="string">ASCII字符可以以 \x## 形式的十六进制表示，例如：</span></span><br><span class="line"><span class="string">&#x27;\x41&#x27;; // 完全等同于 &#x27;A&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">还可以用 \u#### 表示一个Unicode字符：</span></span><br><span class="line"><span class="string">&#x27;\u4e2d\u6587&#x27;; // 完全等同于 &#x27;中文&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多行字符串</span></span><br><span class="line"><span class="string">由于多行字符串用 \n 写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反</span></span><br><span class="line"><span class="string">引号 ``表示：</span></span><br><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`;</span></span><br><span class="line"><span class="string">注意：反引号在键盘的ESC下方，数字键1的左边：</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/09/WRoi6ra9tBZmUcL.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">模板字符串</span><br><span class="line">要把多个字符串连接起来，可以用 + 号连接：</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line">alert(message);</span><br><span class="line"></span><br><span class="line">如果有很多变量需要连接，用 + 号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行</span><br><span class="line">字符串一样，但是它会自动替换字符串中的变量：</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br><span class="line"></span><br><span class="line">操作字符串</span><br><span class="line">字符串常见的操作如下：</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">要获取字符串某个指定位置的字符，使用类似<span class="built_in">Array</span>的下标操作，索引号从<span class="number">0</span>开始：</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br><span class="line"></span><br><span class="line">需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没</span><br><span class="line">有任何效果：</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Test&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">alert(s); <span class="comment">// s仍然为&#x27;Test&#x27;</span></span><br><span class="line"></span><br><span class="line">JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返</span><br><span class="line">回一个新字符串：</span><br><span class="line"></span><br><span class="line">toUpperCase() 把一个字符串全部变为大写</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br><span class="line"></span><br><span class="line">toLowerCase() 把一个字符串全部变为小写</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">indexOf() 会搜索指定字符串出现的位置</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br><span class="line"></span><br><span class="line">substring() 返回指定索引区间的子串</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.5</span>、数组</span><br><span class="line">JavaScript的 <span class="built_in">Array</span> 可以包含任意数据类型，并通过索引来访问每个元素。</span><br><span class="line">要取得 <span class="built_in">Array</span> 的长度，直接访问 length 属性：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">请注意，直接给 <span class="built_in">Array</span> 的 length 赋一个新的值会导致 <span class="built_in">Array</span> 大小的变化：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span> 可以通过索引把对应的元素修改为新的值，因此，对 <span class="built_in">Array</span> 的索引进行赋值会直接修改这个 <span class="built_in">Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span></span><br><span class="line"></span><br><span class="line">请注意，如果通过索引赋值时，索引超过了范围，同样会引起 <span class="built_in">Array</span> 大小的变化：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br><span class="line">大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的 <span class="built_in">Array</span></span><br><span class="line">却不会有任何错误。在编写代码时，不建议直接修改 <span class="built_in">Array</span> 的大小，访问索引时要确保索引不会越</span><br><span class="line">界。</span><br><span class="line"></span><br><span class="line">常用方法</span><br><span class="line">indexOf</span><br><span class="line">与<span class="built_in">String</span>类似， <span class="built_in">Array</span> 也可以通过 indexOf() 来搜索一个指定的元素的位置：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br><span class="line">注意了，数字 <span class="number">30</span> 和字符串 <span class="string">&#x27;30&#x27;</span> 是不同的元素。</span><br><span class="line"></span><br><span class="line">slice</span><br><span class="line">slice() 就是对应<span class="built_in">String</span>的 substring() 版本，它截取 <span class="built_in">Array</span> 的部分元素，然后返回一个</span><br><span class="line">新的 <span class="built_in">Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line"></span><br><span class="line">注意到 slice() 的起止参数包括开始索引，不包括结束索引。</span><br><span class="line">如果不给 slice() 传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容</span><br><span class="line">易地复制一个 <span class="built_in">Array</span> ：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">push和pop</span><br><span class="line">push() 向 <span class="built_in">Array</span> 的末尾添加若干元素， pop() 则把 <span class="built_in">Array</span> 的最后一个元素删除掉</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">unshift和shift</span><br><span class="line">如果要往 <span class="built_in">Array</span> 的头部添加若干元素，使用 unshift() 方法， shift() 方法则把</span><br><span class="line"><span class="built_in">Array</span> 的第一个元素删掉：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">sort</span><br><span class="line">sort() 可以对当前 <span class="built_in">Array</span> 进行排序，它会直接修改当前 <span class="built_in">Array</span> 的元素位置，直接调用</span><br><span class="line">时，按照默认顺序排序</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</span><br><span class="line"></span><br><span class="line">reverse</span><br><span class="line">reverse() 把整个 <span class="built_in">Array</span> 的元素给掉个个，也就是反转</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">arr; <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br><span class="line"></span><br><span class="line">splice</span><br><span class="line">splice() 方法是修改 <span class="built_in">Array</span> 的“万能方法”，它可以从指定的索引开始删除若干元素，然后再</span><br><span class="line">从该位置添加若干元素</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;,</span></span><br><span class="line"><span class="string">&#x27;Excite&#x27;</span>]</span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line">concat</span><br><span class="line">concat() 方法把当前的 <span class="built_in">Array</span> 和另一个 <span class="built_in">Array</span> 连接起来，并返回一个新的 <span class="built_in">Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line"></span><br><span class="line">请注意， concat() 方法并没有修改当前 <span class="built_in">Array</span> ，而是返回了一个新的 <span class="built_in">Array</span> 。</span><br><span class="line">实际上， concat() 方法可以接收任意个元素和 <span class="built_in">Array</span> ，并且自动把 <span class="built_in">Array</span> 拆开，然后全</span><br><span class="line">部添加到新的 <span class="built_in">Array</span> 里：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">join</span><br><span class="line">join() 方法是一个非常实用的方法，它把当前 <span class="built_in">Array</span> 的每个元素都用指定的字符串连接起</span><br><span class="line">来，然后返回连接后的字符串：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br><span class="line">如果 <span class="built_in">Array</span> 的元素不是字符串，将自动转换为字符串后再连接。</span><br><span class="line"></span><br><span class="line">多维数组</span><br><span class="line">如果数组的某个元素又是一个 <span class="built_in">Array</span> ，则可以形成多维数组，例如：</span><br><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br><span class="line">上述 <span class="built_in">Array</span> 包含<span class="number">3</span>个元素，其中头两个元素本身也是 <span class="built_in">Array</span> 。</span><br><span class="line">练习：如何通过索引取到 <span class="number">500</span> 这个值：</span><br><span class="line"><span class="keyword">var</span> x = arr[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// x应该为500</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.6</span>、对象</span><br><span class="line">JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。</span><br><span class="line">JavaScript的对象用于描述现实世界中的某个对象。</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span>,</span><br><span class="line">school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">height: <span class="number">1.70</span>,</span><br><span class="line">weight: <span class="number">65</span>,</span><br><span class="line">score: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、定义一个对象</span><br><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">key: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">key: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">key: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、获取对象的属性</span><br><span class="line">对象.属性</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br><span class="line"></span><br><span class="line">如果我们要检测对象是否拥有某一属性，可以用 <span class="keyword">in</span> 操作符：</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span>,</span><br><span class="line">school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">height: <span class="number">1.70</span>,</span><br><span class="line">weight: <span class="number">65</span>,</span><br><span class="line">score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">不过要小心，如果用 <span class="keyword">in</span> 判断一个属性存在，这个属性不一定是 这个对象的，它可能是这个对象继承得</span><br><span class="line">到的：</span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">因为 toString 定义在 object 对象中，而所有对象最终都会在原型链上指向 object，所以xiaoming 也拥</span><br><span class="line">有 toString 属性。</span><br><span class="line">要判断一个属性是否是 xiaoming 自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法：</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.7</span>、流程控制</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 判断</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">alert(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">alert(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">&#x27;kid&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</span><br><span class="line">x = x + i;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 50005000</span></span><br><span class="line"></span><br><span class="line">遍历数组</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> i, x;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">x = arr[i];</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">无限循环</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 将无限循环下去</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 通过if判断来退出循环</span></span><br><span class="line">&#125;</span><br><span class="line">x ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ... in ， 它可以把一个对象的所有属性依次循环出来：</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line"><span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于 <span class="built_in">Array</span> 也是对象，而它的每个元素的索引被视为对象的属性，所以遍历出来是下标</span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a[i]); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">请注意， <span class="keyword">for</span> ... in 对 <span class="built_in">Array</span> 的循环得到的是 <span class="built_in">String</span> 而不是 <span class="built_in">Number</span> 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>循环</span><br><span class="line">基本操作</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">x = x + n;</span><br><span class="line">n = n - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 2500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>.....while</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">n = n + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">100</span>);</span><br><span class="line">n; <span class="comment">// 100</span></span><br><span class="line">在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。</span><br><span class="line">特别注意 i &lt; <span class="number">100</span> 和 i &lt;= <span class="number">100</span> 是不同的判断逻辑</span><br><span class="line"></span><br><span class="line"><span class="number">2.8</span>、<span class="built_in">Map</span> 和 <span class="built_in">Set</span></span><br><span class="line">JavaScript的默认对象表示方式 &#123; &#125; 可以视为其他语言中的 <span class="built_in">Map</span> 或 Dictionary 的数据结构，即一组键值</span><br><span class="line">对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上<span class="built_in">Number</span>或者其他数据类型作为</span><br><span class="line">键也是非常合理的。</span><br><span class="line">为了解决这个问题，最新的ES6规范引入了新的数据类型 <span class="built_in">Map</span> 。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span></span><br><span class="line"><span class="built_in">Map</span> 是一组键值对的结构，具有极快的查找速度。</span><br><span class="line">举个例子，假设要根据同学的名字查找对应的成绩，如果用 <span class="built_in">Array</span> 实现，需要两个 <span class="built_in">Array</span> ：</span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br><span class="line">给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，</span><br><span class="line"><span class="built_in">Array</span>越长，耗时越长。</span><br><span class="line"></span><br><span class="line">如果用<span class="built_in">Map</span>实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查</span><br><span class="line">找速度都不会变慢。用JavaScript写一个<span class="built_in">Map</span>如下：</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br><span class="line"></span><br><span class="line">初始化 <span class="built_in">Map</span> 需要一个二维数组，或者直接初始化一个空 <span class="built_in">Map</span> 。 <span class="built_in">Map</span> 具有以下方法：</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span></span><br><span class="line"><span class="built_in">Set</span> 和 <span class="built_in">Map</span> 类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在 <span class="built_in">Set</span> 中，</span><br><span class="line">没有重复的key。</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br><span class="line"></span><br><span class="line">重复元素在 <span class="built_in">Set</span> 中自动被过滤</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">注意数字 <span class="number">3</span> 和字符串 <span class="string">&#x27;3&#x27;</span> 是不同的元素。</span><br><span class="line">通过 add(key) 方法可以添加元素到 <span class="built_in">Set</span> 中，可以重复添加，但不会有效果：</span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">通过 <span class="keyword">delete</span>(key) 方法可以删除元素：</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.9</span>、Iterable</span><br><span class="line">遍历 <span class="built_in">Array</span> 可以采用下标循环，遍历<span class="built_in">Map</span> 和 <span class="built_in">Set</span> 就无法使用下标。</span><br><span class="line">为了统一集合类型，ES6标准引入了新的 iterable 类型，<span class="built_in">Array</span>，<span class="built_in">Map</span>，<span class="built_in">Set</span> 属于；</span><br><span class="line">具有 iterable 类型的集合可以通过新的 <span class="keyword">for</span> ... of 循环来遍历。</span><br><span class="line"></span><br><span class="line">遍历集合</span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">更好的方式是直接使用 iterable 内置的 forEach 方法，它接收一个函数，每次迭代就自动回调该</span><br><span class="line">函数。以 <span class="built_in">Array</span> 为例</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line"><span class="comment">// element: 指向当前元素的值</span></span><br><span class="line"><span class="comment">// index: 指向当前索引</span></span><br><span class="line"><span class="comment">// array: 指向Array对象本身</span></span><br><span class="line"><span class="built_in">console</span>.log(element + <span class="string">&#x27;, index = &#x27;</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">forEach() 方法是ES5<span class="number">.1</span>标准引入的，你需要测试浏览器是否支持。</span><br><span class="line"><span class="built_in">Set</span> 没有索引，因此回调函数的前两个参数都是元素本身：</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> 的回调函数参数依次为 value 、 key 和 map 本身：</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、函数</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span>、函数定义和调用</span><br><span class="line"><span class="number">1</span>、定义函数方式一</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">一旦执行到 <span class="keyword">return</span> 时，函数就执行完毕，并将结果返回。</span><br><span class="line">如果没有 <span class="keyword">return</span> 语句，函数执行完毕后也会返回结果，只是结果为 <span class="literal">undefined</span> 。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、第二种定义函数的方式如下</span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">在这种方式下， <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; ... &#125; 是一个匿名函数，它没有函数名。但是，这个匿名函数赋值</span><br><span class="line">给了变量 abs ，所以，通过变量 abs 就可以调用该函数。</span><br><span class="line">上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个 ; ，表示赋值语句结</span><br><span class="line">束。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、调用函数</span><br><span class="line">调用函数时，按顺序传入参数即可：</span><br><span class="line">abs(<span class="number">10</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(<span class="number">-9</span>); <span class="comment">// 返回9</span></span><br><span class="line">由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函</span><br><span class="line">数内部并不需要这些参数：</span><br><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(<span class="number">-9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br><span class="line">传入的参数比定义的少也没有问题：</span><br><span class="line">abs(); <span class="comment">// 返回NaN</span></span><br><span class="line">此时 abs(x) 函数的参数 x 将收到 <span class="literal">undefined</span> ，计算结果为 <span class="literal">NaN</span> 。</span><br><span class="line">要避免收到 <span class="literal">undefined</span> ，可以对参数进行检查：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="built_in">arguments</span></span><br><span class="line">JavaScript还有一个免费赠送的关键字 <span class="built_in">arguments</span> ，它只在函数内部起作用，并且永远指向当前函数</span><br><span class="line">的调用者传入的所有参数。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">利用 <span class="built_in">arguments</span> ，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可</span><br><span class="line">以拿到参数的值：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">abs(); <span class="comment">// 0</span></span><br><span class="line">abs(<span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line">abs(<span class="number">-9</span>); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">实际上 <span class="built_in">arguments</span> 最常用于判断传入参数的个数。你可能会看到这样的写法：</span><br><span class="line"><span class="comment">// foo(a[, b], c)</span></span><br><span class="line"><span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 实际拿到的参数是a和b，c为undefined</span></span><br><span class="line">c = b; <span class="comment">// 把b赋给c</span></span><br><span class="line">b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rest参数</span><br><span class="line">由于JavaScript函数允许接收任意个参数，于是我们就不得不用 <span class="built_in">arguments</span> 来获取所有参数：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> i, rest = [];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">rest.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line"><span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了获取除了已定义参数 a 、 b 之外的参数，我们不得不用 <span class="built_in">arguments</span> ，并且循环要从索引</span><br><span class="line"><span class="number">2</span> 开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的 rest 参数，有没有更好的方</span><br><span class="line">法？</span><br><span class="line">ES6标准引入了rest参数，上面的函数可以改写为：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line"><span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br><span class="line">rest参数只能写在最后，前面用 ... 标识，从运行结果可知，传入的参数先绑定 a 、 b ，多余的</span><br><span class="line">参数以数组形式交给变量 rest ，所以，不再需要 <span class="built_in">arguments</span> 我们就获取了全部参数。</span><br><span class="line"></span><br><span class="line"><span class="number">3.2</span>、变量作用域</span><br><span class="line"></span><br><span class="line">变量的作用域</span><br><span class="line">在JavaScript中，用 <span class="keyword">var</span> 申明的变量实际上是有作用域的。</span><br><span class="line">如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = x + <span class="number">2</span>; <span class="comment">// ReferenceError! 无法在函数体外引用变量x</span></span><br><span class="line"></span><br><span class="line">如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同</span><br><span class="line">函数内部的同名变量互相独立，互不影响：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">x = x + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果内部函数和外部函数的变量名重名怎么办？来测试一下：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x in bar() = &#x27;</span> + x); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x in foo() = &#x27;</span> + x); <span class="comment">// 1</span></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与</span><br><span class="line">外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</span><br><span class="line"></span><br><span class="line">变量提升</span><br><span class="line">JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;Hello, &#x27;</span> + y;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">结果：Hello, <span class="literal">undefined</span> ， 说明 y 的值为 <span class="literal">undefined</span>；</span><br><span class="line">这正是因为JavaScript引擎自动提升了变量 y 的声明，但不会提升变量 y 的赋值。</span><br><span class="line">对于上述 foo() 函数，JavaScript引擎看到的代码相当于：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明，此时y为undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;Hello, &#x27;</span> + y;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">y = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有</span><br><span class="line">变量”这一规则。最常见的做法是用一个 <span class="keyword">var</span> 申明函数内部用到的所有变量：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line"><span class="comment">// 其他语句:</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">全局作用域</span><br><span class="line">不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象 <span class="built_in">window</span> ，全</span><br><span class="line">局作用域的变量实际上被绑定到 <span class="built_in">window</span> 的一个属性：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> course = <span class="string">&#x27;Learn JavaScript&#x27;</span>;</span><br><span class="line">alert(course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// &#x27;Learn JavaScript</span></span><br><span class="line">因此，直接访问全局变量 course 和访问 <span class="built_in">window</span>.course 是完全一样的。</span><br><span class="line">因此，顶层函数的定义也被视为一个全局变量，并绑定到 <span class="built_in">window</span> 对象：</span><br><span class="line"></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 直接调用foo()</span></span><br><span class="line"><span class="built_in">window</span>.foo(); <span class="comment">// 通过window.foo()调用</span></span><br><span class="line"></span><br><span class="line">进一步大胆地猜测，我们每次直接调用的 alert() 函数其实也是 <span class="built_in">window</span> 的一个变量：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="string">&#x27;调用window.alert()&#x27;</span>);</span><br><span class="line"><span class="comment">// 把alert保存到另一个变量:</span></span><br><span class="line"><span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert;</span><br><span class="line"><span class="comment">// 给alert赋一个新函数:</span></span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">alert(<span class="string">&#x27;无法用alert()显示了!&#x27;</span>);</span><br><span class="line"><span class="comment">// 恢复alert:</span></span><br><span class="line"><span class="built_in">window</span>.alert = old_alert;</span><br><span class="line">alert(<span class="string">&#x27;又可以用alert()了!&#x27;</span>);</span><br><span class="line">这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用</span><br><span class="line">域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报 <span class="built_in">ReferenceError</span> 错误。</span><br><span class="line"></span><br><span class="line">全局变量会绑定到 <span class="built_in">window</span> 上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名</span><br><span class="line">字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数</span><br><span class="line">全部绑定到一个全局变量中。例如：</span><br><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">&#x27;myapp&#x27;</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">把自己的代码全部放入唯一的名字空间 MYAPP 中，会大大减少全局变量冲突的可能。</span><br><span class="line">许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</span><br><span class="line"></span><br><span class="line">局部作用域</span><br><span class="line">由于JavaScript的变量作用域实际上是函数内部，我们在 <span class="keyword">for</span> 循环等语句块中是无法定义具有局部作</span><br><span class="line">用域的变量的：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了解决块级作用域，ES6引入了新的关键字 <span class="keyword">let</span> ，用 <span class="keyword">let</span> 替代 <span class="keyword">var</span> 可以申明一个块级作用域</span><br><span class="line">的变量：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">常量</span><br><span class="line">由于 <span class="keyword">var</span> 和 <span class="keyword">let</span> 申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写</span><br><span class="line">的变量来表示“这是一个常量，不要修改它的值”：</span><br><span class="line"><span class="keyword">var</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">ES6标准引入了新的关键字 <span class="keyword">const</span> 来定义常量， <span class="keyword">const</span> 与 <span class="keyword">let</span> 都具有块级作用域：</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.3</span>、方法</span><br><span class="line">定义方法</span><br><span class="line">在一个对象中绑定函数，称为这个对象的方法。</span><br><span class="line">在JavaScript中，对象的定义是这样的：</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">但是，如果我们给 xiaoming 绑定一个函数，就可以做更多的事情。比如，写个 age() 方法，返</span><br><span class="line">回 xiaoming 的年龄：</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span>,</span><br><span class="line">age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line"><span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br><span class="line"></span><br><span class="line">绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个 <span class="built_in">this</span> 关键字，这</span><br><span class="line">个东东是什么？</span><br><span class="line">在一个方法内部， <span class="built_in">this</span> 是一个特殊变量，它始终指向当前对象，也就是 xiaoming 这个变量。所</span><br><span class="line">以， <span class="built_in">this</span>.birth 可以拿到 xiaoming 的 birth 属性。</span><br><span class="line">让我们拆开写：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line"><span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span>,</span><br><span class="line">age: getAge</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">单独调用函数 getAge() 怎么返回了 <span class="literal">NaN</span> ？请注意，我们已经进入到了JavaScript的一个大坑里。</span><br><span class="line">JavaScript的函数内部如果调用了 <span class="built_in">this</span> ，那么这个 <span class="built_in">this</span> 到底指向谁？</span><br><span class="line">答案是，视情况而定！</span><br><span class="line">如果以对象的方法形式调用，比如 xiaoming.age() ，该函数的 <span class="built_in">this</span> 指向被调用的对象，也就</span><br><span class="line">是 xiaoming ，这是符合我们预期的。</span><br><span class="line">如果单独调用函数，比如 getAge() ，此时，该函数的 <span class="built_in">this</span> 指向全局对象，也就是 <span class="built_in">window</span> 。</span><br><span class="line"></span><br><span class="line">apply</span><br><span class="line">不过，我们还是可以控制 <span class="built_in">this</span> 的指向的！</span><br><span class="line">要指定函数的 <span class="built_in">this</span> 指向哪个对象，可以用函数本身的 apply 方法，它接收两个参数，第一个参数</span><br><span class="line">就是需要绑定的 <span class="built_in">this</span> 变量，第二个参数是 <span class="built_in">Array</span> ，表示函数本身的参数。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line"><span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">birth: <span class="number">1990</span>,</span><br><span class="line">age: getAge</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、标准对象</span><br><span class="line"><span class="number">4.1</span>、标准对象</span><br><span class="line">在JavaScript的世界里，一切都是对象。</span><br><span class="line">但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用 <span class="keyword">typeof</span> 操作符获取对象的类</span><br><span class="line">型，它总是返回一个字符串：</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.2</span>、<span class="built_in">Date</span></span><br><span class="line">在JavaScript中， <span class="built_in">Date</span> 对象用来表示日期和时间。</span><br><span class="line">要获取系统当前时间，用：</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"></span><br><span class="line">注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定</span><br><span class="line">为任何值。</span><br><span class="line">时区</span><br><span class="line"><span class="built_in">Date</span> 对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调</span><br><span class="line">整后的UTC时间：</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d.toLocaleString(); <span class="comment">// &#x27;2015/6/24 下午7:49:22&#x27;，本地时间（北京时区+8:00），显示的字</span></span><br><span class="line">符串与操作系统设定的格式有关</span><br><span class="line">d.toUTCString(); <span class="comment">// &#x27;Wed, 24 Jun 2015 11:49:22 GMT&#x27;，UTC时间，与本地时间相差8小时</span></span><br><span class="line"></span><br><span class="line">那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个 number 类型的时间戳，我</span><br><span class="line">们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。</span><br><span class="line">时间戳是个什么东西？时间戳是一个自增的整数，它表示从<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日零时整的GMT时区开始的那一</span><br><span class="line">刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此</span><br><span class="line">刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</span><br><span class="line">所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就</span><br><span class="line">可以了。</span><br><span class="line">要获取当前时间戳，可以用：</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Date</span>.now) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now()); <span class="comment">// 老版本IE没有now()方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.3</span>、<span class="built_in">JSON</span></span><br><span class="line"><span class="built_in">JSON</span>(JavaScript <span class="built_in">Object</span> Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广</span><br><span class="line">泛。</span><br><span class="line">采用完全独立于编程语言的文本格式来存储和表示数据。</span><br><span class="line">简洁和清晰的层次结构使得 <span class="built_in">JSON</span> 成为理想的数据交换语言。</span><br><span class="line">易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</span><br><span class="line">在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 <span class="built_in">JSON</span> 来表示，例</span><br><span class="line">如字符串、数字、对象、数组等。看看他的要求和语法格式：</span><br><span class="line">对象表示为键值对，数据由逗号分隔</span><br><span class="line">花括号保存对象</span><br><span class="line">方括号保存数组</span><br><span class="line"><span class="built_in">JSON</span> 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组</span><br><span class="line">合中的键名写在前面并用双引号 <span class="string">&quot;&quot;</span> 包裹，使用冒号 : 分隔，然后紧接着值：</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;QinJiang&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">很多人搞不清楚 <span class="built_in">JSON</span> 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span> 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符</span><br><span class="line">串。</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;; <span class="comment">//这是一个对象，注意键名也是可以使用引号包裹</span></span><br><span class="line">的</span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>; <span class="comment">//这是一个 JSON 字符串，本质是一个</span></span><br><span class="line">字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span> 和 JavaScript 对象互转</span><br><span class="line">要实现从<span class="built_in">JSON</span>字符串转换为JavaScript 对象，使用 <span class="built_in">JSON</span>.parse() 方法：</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">要实现从JavaScript 对象转换为<span class="built_in">JSON</span>字符串，使用 <span class="built_in">JSON</span>.stringify() 方法：</span><br><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">代码测试</span><br><span class="line"><span class="number">1.</span> 新建一个 json<span class="number">-1.</span>html ， 编写测试内容</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;JSON_秦疆&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//编写一个js的对象</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">name:<span class="string">&quot;秦疆&quot;</span>,</span><br><span class="line">age:<span class="number">3</span>,</span><br><span class="line">sex:<span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将js对象转换成json字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(user);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//将json字符串转换为js对象</span></span><br><span class="line"><span class="keyword">var</span> user2 = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="built_in">console</span>.log(user2.age,user2.name,user2.sex);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="number">2.</span> 在IDEA中使用浏览器打开，查看控制台输出！</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、面向对象编程</span><br><span class="line"></span><br><span class="line">面向对象编程</span><br><span class="line">JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。如果你熟悉Java或</span><br><span class="line">C#，很好，你一定明白面向对象的两个基本概念：</span><br><span class="line"><span class="number">1.</span> 类：类是对象的类型模板，例如，定义 Student 类来表示学生，类本身是一种类型，</span><br><span class="line">Student 表示学生类型，但不表示任何具体的某个学生；</span><br><span class="line"><span class="number">2.</span> 实例：实例是根据类创建的对象，例如，根据 Student 类可以创建出 xiaoming 、</span><br><span class="line">xiaohong 、 xiaojun 等多个实例，每个实例表示一个具体的学生，他们全都属于</span><br><span class="line">Student 类型。</span><br><span class="line">所以，类和实例是大多数面向对象编程语言的基本概念。</span><br><span class="line">不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型</span><br><span class="line">（prototype）来实现面向对象编程。</span><br><span class="line">原型是指当我们想要创建 xiaoming 这个具体的学生时，我们并没有一个 Student 类型可用。那怎</span><br><span class="line">么办？恰好有这么一个现成的对象：</span><br><span class="line"><span class="keyword">var</span> robot = &#123;</span><br><span class="line">name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">height: <span class="number">1.6</span>,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">我们看这个 robot 对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！</span><br><span class="line">于是我们把它改名为 Student ，然后创建出 xiaoming ：</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">height: <span class="number">1.2</span>,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.__proto__ = Student;</span><br><span class="line"></span><br><span class="line">注意最后一行代码把 xiaoming 的原型指向了对象 Student ，看上去 xiaoming 仿佛是从</span><br><span class="line">Student 继承下来的：</span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming 有自己的 name 属性，但并没有定义 run() 方法。不过，由于小明是从 Student</span><br><span class="line">继承而来，只要 Student 有 run() 方法， xiaoming 也可以调用：</span><br><span class="line">JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系</span><br><span class="line">不过是把一个对象的原型指向另一个对象而已。</span><br><span class="line"></span><br><span class="line">如果你把 xiaoming 的原型指向其他对象：</span><br><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is flying...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.__proto__ = Bird;</span><br><span class="line"></span><br><span class="line">现在 xiaoming 已经无法 run() 了，他已经变成了一只鸟：</span><br><span class="line">xiaoming.fly(); <span class="comment">// 小明 is flying...</span></span><br><span class="line"></span><br><span class="line">在JavaScrip代码运行时期，你可以把 xiaoming 从 Student 变成 Bird ，或者变成任何对象。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 继承</span></span><br><span class="line"><span class="class">在上面的章节中我们看到了<span class="title">JavaScript</span>的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传</span></span><br><span class="line"><span class="class">统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</span></span><br><span class="line"><span class="class">有没有更简单的写法？有！</span></span><br><span class="line"><span class="class">新的关键字 <span class="title">class</span> 从<span class="title">ES6</span>开始正式被引入到<span class="title">JavaScript</span>中。 <span class="title">class</span> 的目的就是让定义类更简单。</span></span><br><span class="line"><span class="class">我们先回顾用函数实现 <span class="title">Student</span> 的方法：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">function</span> <span class="title">Student</span>(<span class="title">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在要给这个Student新增一个方法</span></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果用新的 <span class="class"><span class="keyword">class</span> 关键字来编写 <span class="title">Student</span> ，可以这样写：</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name) &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">hello() &#123;</span><br><span class="line">alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">比较一下就可以发现， <span class="class"><span class="keyword">class</span> 的定义包含了构造函数 <span class="title">constructor</span> 和定义在原型对象上的函数</span></span><br><span class="line"><span class="class"><span class="title">hello</span>() （注意没有 <span class="title">function</span> 关键字），这样就避免了 <span class="title">Student</span>.<span class="title">prototype</span>.<span class="title">hello</span> </span>=</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; 这样分散的代码。</span><br><span class="line">最后，创建一个 Student 对象代码和前面章节完全一样：</span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.hello();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>继承</span></span><br><span class="line"><span class="class">用 <span class="title">class</span> 定义对象的另一个巨大的好处是继承更方便了。想一想我们从 <span class="title">Student</span> 派生一个</span></span><br><span class="line"><span class="class"><span class="title">PrimaryStudent</span> 需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需</span></span><br><span class="line"><span class="class">要考虑了，直接通过 <span class="keyword">extends</span> 来实现：</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name, grade) &#123;</span><br><span class="line"><span class="built_in">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line"><span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">myGrade() &#123;</span><br><span class="line">alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、操作BOM</span><br><span class="line"><span class="number">6.1</span>、浏览器</span><br><span class="line">由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注</span><br><span class="line">的。</span><br><span class="line">目前主流的浏览器分这么几种：</span><br><span class="line">IE <span class="number">6</span>~<span class="number">11</span>：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</span><br><span class="line">Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于</span><br><span class="line">Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</span><br><span class="line">Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X <span class="number">10.7</span> Lion自带的<span class="number">6.1</span>版本开始</span><br><span class="line">支持ES6，目前最新的OS X <span class="number">10.11</span> El Capitan自带的Safari版本是<span class="number">9.</span>x，早已支持ES6；</span><br><span class="line">Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发</span><br><span class="line">布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</span><br><span class="line">移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两</span><br><span class="line">者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对</span><br><span class="line">JavaScript的标准支持也很好，最新版本均支持ES6。</span><br><span class="line">其他浏览器如Opera等由于市场份额太小就被自动忽略了。</span><br><span class="line">另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核</span><br><span class="line">心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。</span><br><span class="line">不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标</span><br><span class="line">准，不同的浏览器对各个特性支持也不一样。</span><br><span class="line">在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的</span><br><span class="line">浏览器中。</span><br><span class="line">JavaScript可以获取浏览器提供的很多对象，并进行操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.2</span>、<span class="built_in">window</span></span><br><span class="line"><span class="built_in">window</span> 对象不但充当全局作用域，而且表示浏览器窗口。</span><br><span class="line"><span class="built_in">window</span> 对象有 innerWidth 和 innerHeight 属性，可以获取浏览器窗口的内部宽度和高度。</span><br><span class="line">内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</span><br><span class="line">兼容性：IE&lt;=<span class="number">8</span>不支持。</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 可以调整浏览器窗口大小试试:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window inner size: &#x27;</span> + <span class="built_in">window</span>.innerWidth + <span class="string">&#x27; x &#x27;</span> +</span><br><span class="line"><span class="built_in">window</span>.innerHeight);</span><br><span class="line"></span><br><span class="line">对应的，还有一个 outerWidth 和 outerHeight 属性，可以获取浏览器窗口的整个宽高。</span><br><span class="line"></span><br><span class="line"><span class="number">6.3</span>、navigator</span><br><span class="line">navigator 对象表示浏览器的信息，最常用的属性包括：</span><br><span class="line">navigator.appName：浏览器名称；</span><br><span class="line">navigator.appVersion：浏览器版本；</span><br><span class="line">navigator.language：浏览器设置的语言；</span><br><span class="line">navigator.platform：操作系统类型；</span><br><span class="line">navigator.userAgent：浏览器设定的 User-Agent 字符串。</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;appName = &#x27;</span> + navigator.appName);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;appVersion = &#x27;</span> + navigator.appVersion);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;language = &#x27;</span> + navigator.language);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;platform = &#x27;</span> + navigator.platform);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;userAgent = &#x27;</span> + navigator.userAgent);</span><br><span class="line"></span><br><span class="line">请注意， navigator 的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很</span><br><span class="line">多初学者为了针对不同浏览器编写不同的代码，喜欢用 <span class="keyword">if</span> 判断浏览器版本，例如：</span><br><span class="line"><span class="keyword">var</span> width;</span><br><span class="line"><span class="keyword">if</span> (getIEVersion(navigator.userAgent) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">width = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">&#125;</span><br><span class="line">但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回</span><br><span class="line"><span class="literal">undefined</span> 的特性，直接用短路运算符 || 计算：</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.4</span>、screen</span><br><span class="line">screen 对象表示屏幕的信息，常用的属性有：</span><br><span class="line">screen.width：屏幕宽度，以像素为单位；</span><br><span class="line">screen.height：屏幕高度，以像素为单位；</span><br><span class="line">screen.colorDepth：返回颜色位数，如<span class="number">8</span>、<span class="number">16</span>、<span class="number">24</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Screen size = &#x27;</span> + screen.width + <span class="string">&#x27; x &#x27;</span> + screen.height);</span><br><span class="line"></span><br><span class="line"><span class="number">6.5</span>、location</span><br><span class="line">location 对象表示当前页面的URL信息。例如，一个完整的URL：</span><br><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br><span class="line"></span><br><span class="line">可以用 location.href 获取。要获得URL各个部分的值，可以这么写：</span><br><span class="line"></span><br><span class="line">location.protocol; <span class="comment">// &#x27;http&#x27;</span></span><br><span class="line">location.host; <span class="comment">// &#x27;www.example.com&#x27;</span></span><br><span class="line">location.port; <span class="comment">// &#x27;8080&#x27;</span></span><br><span class="line">location.pathname; <span class="comment">// &#x27;/path/index.html&#x27;</span></span><br><span class="line">location.search; <span class="comment">// &#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.hash; <span class="comment">// &#x27;TOP&#x27;</span></span><br><span class="line"></span><br><span class="line">要加载一个新页面，可以调用 location.assign() 。如果要重新加载当前页面，调用</span><br><span class="line">location.reload() 方法非常方便。</span><br><span class="line">location.reload();</span><br><span class="line">location.assign(<span class="string">&#x27;https://blog.kuangstudy.com/&#x27;</span>); <span class="comment">// 设置一个新的URL地址</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.6</span>、<span class="built_in">document</span></span><br><span class="line"><span class="built_in">document</span> 对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构， <span class="built_in">document</span> 对</span><br><span class="line">象就是整个DOM树的根节点。</span><br><span class="line"><span class="built_in">document</span> 的 title 属性是从HTML文档中的 xxx 读取的，但是可以动态改变：</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;狂神说Java!&#x27;</span></span><br><span class="line">请观察浏览器窗口标题的变化。</span><br><span class="line">要查找DOM树的某个节点，需要从 <span class="built_in">document</span> 对象开始查找。最常用的查找是根据ID和Tag Name。</span><br><span class="line">我们先准备HTML数据：</span><br><span class="line">&lt;dl id=<span class="string">&quot;code-menu&quot;</span> style=<span class="string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span><br><span class="line">&lt;dt&gt;Java&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;Spring&lt;/dd&gt;</span><br><span class="line">&lt;dt&gt;Python&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;Django&lt;/dd&gt;</span><br><span class="line">&lt;dt&gt;Linux&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;Docker&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">用 <span class="built_in">document</span> 对象提供的 getElementById() 和 getElementsByTagName() 可以按ID获得一个</span><br><span class="line">DOM节点和按Tag名称获得一组DOM节点：</span><br><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;code-menu&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;dt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i, s;</span><br><span class="line">s = <span class="string">&#x27;提供的饮料有:&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">s = s + drinks[i].innerHTML + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span> 对象还有一个 cookie 属性，可以获取当前页面的Cookie。</span><br><span class="line">Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个</span><br><span class="line">用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览</span><br><span class="line">器，例如 user=ABC123XYZ(加密的字符串)... ，此后，浏览器访问该网站时，会在请求头附上这个</span><br><span class="line">Cookie，服务器根据Cookie即可区分出用户。</span><br><span class="line">Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</span><br><span class="line">JavaScript可以通过 <span class="built_in">document</span>.cookie 读取到当前页面的Cookie：</span><br><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span></span><br><span class="line">由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安</span><br><span class="line">全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</span><br><span class="line">&lt;!--www.example.com--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;http://www.foo.com/jquery.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">如果引入的第三方的JavaScript中存在恶意代码，则 www.foo.com 网站将直接获取到</span><br><span class="line">www.example.com 网站的用户登录信息。</span><br><span class="line">为了解决这个问题，服务器在设置Cookie时可以使用 httpOnly ，设定了 httpOnly 的Cookie将不</span><br><span class="line">能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持 httpOnly 选项，IE从IE6 SP1开始</span><br><span class="line">支持。</span><br><span class="line">为了确保安全，服务器端在设置Cookie时，应该始终坚持使用 httpOnly 。</span><br><span class="line"></span><br><span class="line"><span class="number">6.7</span>、history</span><br><span class="line">history 对象保存了浏览器的历史记录，JavaScript可以调用 history 对象的 back() 或</span><br><span class="line">forward () ，相当于用户点击了浏览器的“后退”或“前进”按钮。</span><br><span class="line">这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调</span><br><span class="line">用 history.back() 可能会让用户感到非常愤怒。</span><br><span class="line">新手开始设计Web页面时喜欢在登录页登录成功时调用 history.back() ，试图回到登录前的页面。</span><br><span class="line">这是一种错误的方法。</span><br><span class="line">任何情况，你都不应该使用 history 这个对象了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、操作DOM</span><br><span class="line"><span class="number">7.1</span>、选择器</span><br><span class="line">由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作</span><br><span class="line">DOM。</span><br><span class="line">始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</span><br><span class="line">更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</span><br><span class="line">遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</span><br><span class="line">添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</span><br><span class="line">删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</span><br><span class="line">在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是</span><br><span class="line"><span class="built_in">document</span>.getElementById() 和 <span class="built_in">document</span>.getElementsByTagName() ，以及CSS选择器</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName() 。</span><br><span class="line">由于ID在HTML文档中是唯一的，所以 <span class="built_in">document</span>.getElementById() 可以直接定位唯一的一个DOM</span><br><span class="line">节点。 <span class="built_in">document</span>.getElementsByTagName() 和 <span class="built_in">document</span>.getElementsByClassName() 总是返</span><br><span class="line">回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</span><br><span class="line">例如：</span><br><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-table&#x27;</span>).getElementsByTagName(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;testdiv&#x27;</span>).getElementsByClassName(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br><span class="line"></span><br><span class="line">第二种方法是使用 querySelector() 和 querySelectorAll() ，需要了解selector语法，然后使</span><br><span class="line">用条件来获取节点，更加方便：</span><br><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#q1&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br><span class="line">注意：低版本的IE&lt;<span class="number">8</span>不支持 querySelector 和 querySelectorAll 。IE8仅有限支持。</span><br><span class="line"></span><br><span class="line"><span class="number">7.2</span>、更新DOM</span><br><span class="line">拿到一个DOM节点后，我们可以对它进行更新。</span><br><span class="line">可以直接修改节点的文本，方法有两种：</span><br><span class="line">一种是修改 innerHTML 属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以</span><br><span class="line">直接通过HTML片段修改DOM节点内部的子树：</span><br><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br><span class="line">用 innerHTML 时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符</span><br><span class="line">编码来避免XSS攻击。</span><br><span class="line">第二种是修改 innerText 属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标</span><br><span class="line">签：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line">修改CSS也是经常需要的操作。DOM节点的 style 属性对应所有的CSS，可以直接获取或设置。因为</span><br><span class="line">CSS允许 font-size 这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为</span><br><span class="line">驼峰式命名 fontSize ：</span><br><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">p.style.fontSize = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">&#x27;2em&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">7.3</span>、插入DOM</span><br><span class="line">appendChild</span><br><span class="line">当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？</span><br><span class="line">如果这个DOM节点是空的，例如， <span class="string">`，那么，直接使用 innerHTML = &#x27;child&#x27;`</span>就可以修改DOM节点的</span><br><span class="line">内容，相当于“插入”了新的DOM节点。</span><br><span class="line">如果这个DOM节点不是空的，那就不能这么做，因为 innerHTML 会直接替换掉原来的所有子节点。</span><br><span class="line">有两个办法可以插入新的节点。一个是使用 appendChild ，把一个子节点添加到父节点的最后一个</span><br><span class="line">子节点。例如：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;js&quot;</span>&gt;JavaScript&lt;/p&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">把 JavaScript 添加到的最后一项：</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>),</span><br><span class="line">list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.appendChild(js);</span><br><span class="line"></span><br><span class="line">现在，HTML结构变成了这样：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;js&quot;</span>&gt;JavaScript&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">因为我们插入的 js 节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入</span><br><span class="line">到新的位置。</span><br><span class="line">更多的时候我们会从零创建一个新的节点，然后插入到指定位置：</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.appendChild(haskell);</span><br><span class="line"></span><br><span class="line">这样我们就动态添加了一个新的节点：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;haskell&quot;</span>&gt;Haskell&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个</span><br><span class="line">节点，然后把它添加到 节点的末尾，这样就动态地给文档添加了新的CSS定义：</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">d.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">d.innerHTML = <span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//head 头部标签</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(d);</span><br><span class="line">可以在Chrome的控制台执行上述代码，观察页面样式的变化</span><br><span class="line"></span><br><span class="line">insertBefore</span><br><span class="line">如果我们要把子节点插入到指定的位置怎么办？可以使用</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement); ，子节点会插入到</span><br><span class="line">referenceElement 之前。</span><br><span class="line">还是以上面的HTML为例，假定我们要把 Haskell 插入到 Python 之前：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">可以这么写：</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">ref = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;python&#x27;</span>),</span><br><span class="line">haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br><span class="line"></span><br><span class="line">新的HTML结构如下：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;haskell&quot;</span>&gt;Haskell&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">7.4</span>、删除DOM</span><br><span class="line">删除一个DOM节点就比插入要容易得多。</span><br><span class="line">要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的 removeChild 把自</span><br><span class="line">己删掉：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</span><br><span class="line">当你遍历一个父节点的子节点并进行删除操作时，要注意， children 属性是一个只读属性，并且它</span><br><span class="line">在子节点变化时会实时更新。</span><br><span class="line">例如，对于如下HTML结构：</span><br><span class="line">&lt;div id=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;First&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Second&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">当我们用如下代码删除子节点时：</span><br><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">0</span>]);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">1</span>]); <span class="comment">// &lt;-- 浏览器报错</span></span><br><span class="line"></span><br><span class="line">浏览器报错： parent.children[<span class="number">1</span>] 不是一个有效的节点。原因就在于，当 First 节点被删除</span><br><span class="line">后， parent.children 的节点数量已经从<span class="number">2</span>变为了<span class="number">1</span>，索引 [<span class="number">1</span>] 已经不存在了。</span><br><span class="line">因此，删除多个节点时，要注意 children 属性时刻都在变化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、操作表单</span><br><span class="line"><span class="number">8.1</span>、回顾</span><br><span class="line">用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</span><br><span class="line">不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内</span><br><span class="line">容，或者对一个输入框设置新的内容。</span><br><span class="line">HTML表单的输入控件主要有以下几种：</span><br><span class="line">文本框，对应的 &lt;input type=<span class="string">&quot;text&quot;</span>&gt; ，用于输入文本；</span><br><span class="line">口令框，对应的 &lt;input type=<span class="string">&quot;password&quot;</span>&gt; ，用于输入口令；</span><br><span class="line">单选框，对应的 &lt;input type=<span class="string">&quot;radio&quot;</span>&gt; ，用于选择一项；</span><br><span class="line">复选框，对应的 &lt;input type=<span class="string">&quot;checkbox&quot;</span>&gt; ，用于选择多项；</span><br><span class="line">下拉框，对应的 &lt;select&gt; ，用于选择一项；</span><br><span class="line">隐藏文本，对应的 &lt;input type=<span class="string">&quot;hidden&quot;</span>&gt; ，用户不可见，但表单提交时会把隐藏文本发送到</span><br><span class="line">服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">8.2</span>、获取值</span><br><span class="line">如果我们获得了一个 &lt;input&gt; 节点的引用，就可以直接调用 value 获得对应的用户输入值：</span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value; <span class="comment">// &#x27;用户输入的值&#x27;</span></span><br><span class="line"></span><br><span class="line">这种方式可以应用于 text 、 password 、 hidden 以及 select 。但是，对于单选框和复选</span><br><span class="line">框， value 属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所</span><br><span class="line">以应该用 checked 判断：</span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt;</span></span><br><span class="line">Monday&lt;/label&gt;</span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt;</span></span><br><span class="line">Tuesday&lt;/label&gt;</span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;monday&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tuesday&#x27;</span>);</span><br><span class="line">mon.value; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">tue.value; <span class="comment">// &#x27;2&#x27;</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.3</span>、设置值</span><br><span class="line">设置值和获取值类似，对于 text 、 password 、 hidden 以及 select ，直接设置 value</span><br><span class="line">就可以：</span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value = <span class="string">&#x27;test@example.com&#x27;</span>; <span class="comment">// 文本框的内容已更新</span></span><br><span class="line">对于单选框和复选框，设置 checked 为 <span class="literal">true</span> 或 <span class="literal">false</span> 即可。</span><br><span class="line"></span><br><span class="line"><span class="number">8.4</span>、提交表单</span><br><span class="line">最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。</span><br><span class="line">方式一是通过 &lt;form&gt; 元素的 submit() 方法提交一个表单，例如，响应一个 button 的</span><br><span class="line">click 事件，在JavaScript代码中提交表单：</span><br><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;test-form&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span><br><span class="line"><span class="comment">// 可以在此修改form的input...</span></span><br><span class="line"><span class="comment">// 提交form:</span></span><br><span class="line">form.submit();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击 &lt;button type=<span class="string">&quot;submit&quot;</span>&gt; 时</span><br><span class="line">提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应 &lt;form&gt; 本身的</span><br><span class="line">onsubmit 事件，在提交form时作修改：</span><br><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;test-form&quot;</span> onsubmit=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span><br><span class="line"><span class="comment">// 可以在此修改form的input...</span></span><br><span class="line"><span class="comment">// 继续下一步:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">注意要 <span class="keyword">return</span> <span class="literal">true</span> 来告诉浏览器继续提交，如果 <span class="keyword">return</span> <span class="literal">false</span> ，浏览器将不会继续提交</span><br><span class="line">form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</span><br><span class="line">在检查和修改 &lt;input&gt; 时，要充分利用 &lt;input type=<span class="string">&quot;hidden&quot;</span>&gt; 来传递数据。</span><br><span class="line">例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是</span><br><span class="line">口令的MD5。普通JavaScript开发人员会直接修改 &lt;input&gt; ：</span><br><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;login-form&quot;</span> method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>);</span><br><span class="line"><span class="comment">// 把用户输入的明文变为MD5:</span></span><br><span class="line">pwd.value = md5(pwd.value);</span><br><span class="line"><span class="comment">// 继续下一步:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个 * 变成<span class="number">32</span>个</span><br><span class="line">* （因为MD5有<span class="number">32</span>个字符）。</span><br><span class="line">要想不改变用户的输入，可以利用 &lt;input type=<span class="string">&quot;hidden&quot;</span>&gt; 实现：</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;login-form&quot;</span> method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;input-password&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> id=<span class="string">&quot;md5-password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-password&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span><br><span class="line"><span class="comment">// 把用户输入的明文变为MD5:</span></span><br><span class="line">md5_pwd.value = md5(input_pwd.value);</span><br><span class="line"><span class="comment">// 继续下一步:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="四、JQuery"><a href="#四、JQuery" class="headerlink" title="四、JQuery"></a>四、JQuery</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9.1</span>、什么是JQuery</span><br><span class="line">你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。</span><br><span class="line">江湖传言，全世界大约有<span class="number">80</span>~<span class="number">90</span>%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，</span><br><span class="line">所以每一个入门JavaScript的前端工程师都应该了解和学习它。</span><br><span class="line">jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：</span><br><span class="line"></span><br><span class="line">消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</span><br><span class="line">简洁的操作DOM的方法：写 $(<span class="string">&#x27;#test&#x27;</span>) 肯定比 <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>) 来得简洁；</span><br><span class="line">轻松实现动画、修改CSS等各种操作。</span><br><span class="line"></span><br><span class="line">jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</span><br><span class="line">官网：https:<span class="comment">//jquery.com/</span></span><br><span class="line">jQuery只是一个 jquery-xxx.js 文件，但你会看到有compressed（已压缩）和uncompressed（未</span><br><span class="line">压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。</span><br><span class="line">使用jQuery只需要在页面的 head 引入jQuery文件即可：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a id=<span class="string">&quot;test-link&quot;</span> href=<span class="string">&quot;#0&quot;</span>&gt;点我试试&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 获取超链接的jQuery对象:</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;#test-link&#x27;</span>);</span><br><span class="line">a.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">公式： $(selector).action()</span><br><span class="line">美元符号定义 jQuery</span><br><span class="line">选择符（selector）<span class="string">&quot;查询&quot;</span>和<span class="string">&quot;查找&quot;</span> HTML 元素</span><br><span class="line">jQuery 的 action() 执行对元素的操作</span><br><span class="line"></span><br><span class="line"><span class="number">9.2</span>、选择器</span><br><span class="line"></span><br><span class="line">了解</span><br><span class="line">选择器是jQuery的核心。</span><br><span class="line">为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码：</span><br><span class="line"><span class="comment">// 按ID查找：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;dom-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 按tag查找：</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 查找&lt;p class=&quot;red&quot;&gt;：</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 过滤出class=&quot;red&quot;:</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">// 查找&lt;table class=&quot;green&quot;&gt;里面的所有&lt;tr&gt;：</span></span><br><span class="line"><span class="keyword">var</span> table = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;table.children; i++) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 过滤出&lt;tr&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">这些代码实在太繁琐了！</span><br><span class="line">jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。</span><br><span class="line"></span><br><span class="line">按ID查找</span><br><span class="line">如果某个DOM节点有 id 属性，利用jQuery查找如下：</span><br><span class="line"><span class="comment">// 查找&lt;div id=&quot;abc&quot;&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">按tag查找</span><br><span class="line">按tag查找只需要写上tag名称就可以了：</span><br><span class="line"><span class="keyword">var</span> ps = $(<span class="string">&#x27;p&#x27;</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br><span class="line"></span><br><span class="line">按<span class="class"><span class="keyword">class</span>查找</span></span><br><span class="line"><span class="class">按<span class="title">class</span>查找注意在<span class="title">class</span>名称前加一个 . ：</span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">a</span> </span>= $(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 所有节点包含`class=&quot;red&quot;`都将返回</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line">按属性查找</span><br><span class="line">一个DOM节点除了 id 和 <span class="class"><span class="keyword">class</span> 外还可以有很多属性，很多时候按属性查找会非常方便，比如在一</span></span><br><span class="line"><span class="class">个表单中按属性来查找：</span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">email</span> </span>= $(<span class="string">&#x27;[name=email]&#x27;</span>); <span class="comment">// 找出&lt;??? name=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">&#x27;[type=password]&#x27;</span>); <span class="comment">// 找出&lt;??? type=&quot;password&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;[items=&quot;A B&quot;]&#x27;</span>); <span class="comment">// 找出&lt;??? items=&quot;A B&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">当属性的值包含空格等特殊字符时，需要用双引号括起来。</span><br><span class="line">按属性查找还可以使用前缀查找或者后缀查找：</span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">&#x27;[name^=icon]&#x27;</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">&#x27;[name$=with]&#x27;</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.3</span>、操作DOM</span><br><span class="line">修改Text和HTML</span><br><span class="line">jQuery对象的 text() 和 html() 方法分别获取节点的文本和原始HTML文本，例如，如下的HTML</span><br><span class="line">结构：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;ul id=<span class="string">&quot;test-ul&quot;</span>&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;js&quot;</span>&gt;JavaScript&lt;/li&gt;</span><br><span class="line">&lt;li name=<span class="string">&quot;book&quot;</span>&gt;Java &amp;amp; JavaScript&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">分别获取文本和HTML：</span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=book]&#x27;</span>).text(); <span class="comment">// &#x27;Java &amp; JavaScript&#x27;</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=book]&#x27;</span>).html(); <span class="comment">// &#x27;Java &amp;amp; JavaScript&#x27;</span></span><br><span class="line"></span><br><span class="line">如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用 text() 是获取文本，传入参数就变</span><br><span class="line">成设置文本，HTML也是类似操作，自己动手试试：</span><br><span class="line"><span class="keyword">var</span> j1 = $(<span class="string">&#x27;#test-ul li.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> j2 = $(<span class="string">&#x27;#test-ul li[name=book]&#x27;</span>);</span><br><span class="line">j1.html(<span class="string">&#x27;&lt;span style=&quot;color: red&quot;&gt;JavaScript&lt;/span&gt;&#x27;</span>);</span><br><span class="line">j2.text(<span class="string">&#x27;JavaScript &amp; ECMAScript&#x27;</span>);</span><br><span class="line"></span><br><span class="line">一个jQuery对象可以包含<span class="number">0</span>个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在</span><br><span class="line">上面的例子中试试：</span><br><span class="line">$(<span class="string">&#x27;#test-ul li&#x27;</span>).text(<span class="string">&#x27;JS&#x27;</span>); <span class="comment">// 是不是两个节点都变成了JS？</span></span><br><span class="line"></span><br><span class="line">修改CSS</span><br><span class="line">jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：</span><br><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;ul id=<span class="string">&quot;test-css&quot;</span>&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang dy&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang dy&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang dy&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">要高亮显示动态语言，调用jQuery对象的 css(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;value&#x27;</span>) 方法，我们用一行语句实现：</span><br><span class="line">$(<span class="string">&#x27;#test-css li.dy&gt;span&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;#ffd351&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行</span><br><span class="line">链式调用，非常方便。</span><br><span class="line">jQuery对象的 css() 方法可以这么用：</span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.css(<span class="string">&#x27;color&#x27;</span>); <span class="comment">// &#x27;#000033&#x27;, 获取CSS属性</span></span><br><span class="line">div.css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;#336699&#x27;</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 清除CSS属性</span></span><br><span class="line"></span><br><span class="line">css() 方法将作用于DOM节点的 style 属性，具有最高优先级。如果要修改 <span class="class"><span class="keyword">class</span> 属性，可</span></span><br><span class="line"><span class="class">以用<span class="title">jQuery</span>提供的下列方法：</span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">div</span> </span>= $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.hasClass(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// false， class是否包含highlight</span></span><br><span class="line">div.addClass(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// 添加highlight这个class</span></span><br><span class="line">div.removeClass(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// 删除highlight这个class</span></span><br><span class="line"></span><br><span class="line">显示和隐藏DOM</span><br><span class="line">要隐藏一个DOM，我们可以设置CSS的 display 属性为 none ，利用 css() 方法就可以实现。</span><br><span class="line">不过，要显示这个DOM就需要恢复原有的 display 属性，这就得先记下来原有的 display 属性到</span><br><span class="line">底是 block 还是 inline 还是别的值。</span><br><span class="line">考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供 show() 和 hide() 方法，我们不用关</span><br><span class="line">心它是如何修改 display 属性的，总之它能正常工作：</span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;a[target=_blank]&#x27;</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示</span></span><br><span class="line">注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同</span><br><span class="line">的。</span><br><span class="line"></span><br><span class="line">获取DOM信息</span><br><span class="line">利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代</span><br><span class="line">码：</span><br><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="built_in">window</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">window</span>).height(); <span class="comment">// 600</span></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="built_in">document</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">document</span>).height(); <span class="comment">// 3500</span></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.width(); <span class="comment">// 600</span></span><br><span class="line">div.height(); <span class="comment">// 300</span></span><br><span class="line">div.width(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.height(<span class="string">&#x27;200px&#x27;</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br><span class="line"></span><br><span class="line">attr() 和 removeAttr() 方法用于操作DOM节点的属性：</span><br><span class="line"><span class="comment">// &lt;div id=&quot;test-div&quot; name=&quot;Test&quot; start=&quot;1&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.attr(<span class="string">&#x27;data&#x27;</span>); <span class="comment">// undefined, 属性不存在</span></span><br><span class="line">div.attr(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// &#x27;Test&#x27;</span></span><br><span class="line">div.attr(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// div的name属性变为&#x27;Hello&#x27;</span></span><br><span class="line">div.removeAttr(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 删除name属性</span></span><br><span class="line">div.attr(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">操作表单</span><br><span class="line">对于表单元素，jQuery对象统一提供 val() 方法获取和设置对应的 value 属性：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;input id=&quot;test-input&quot; name=&quot;email&quot; value=&quot;&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;test-select&quot; name=&quot;city&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;option value=&quot;SZ&quot;&gt;Shenzhen&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br><span class="line"><span class="comment">&lt;textarea id=&quot;test-textarea&quot;&gt;Hello&lt;/textarea&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">input = $(<span class="string">&#x27;#test-input&#x27;</span>),</span><br><span class="line">select = $(<span class="string">&#x27;#test-select&#x27;</span>),</span><br><span class="line">textarea = $(<span class="string">&#x27;#test-textarea&#x27;</span>);</span><br><span class="line">input.val(); <span class="comment">// &#x27;test&#x27;</span></span><br><span class="line">input.val(<span class="string">&#x27;abc@example.com&#x27;</span>); <span class="comment">// 文本框的内容已变为abc@example.com</span></span><br><span class="line">select.val(); <span class="comment">// &#x27;BJ&#x27;</span></span><br><span class="line">select.val(<span class="string">&#x27;SH&#x27;</span>); <span class="comment">// 选择框已变为Shanghai</span></span><br><span class="line">textarea.val(); <span class="comment">// &#x27;Hello&#x27;</span></span><br><span class="line">textarea.val(<span class="string">&#x27;Hi&#x27;</span>); <span class="comment">// 文本区域已更新为&#x27;Hi&#x27;</span></span><br><span class="line"></span><br><span class="line">可见，一个 val() 就统一了各种输入框的取值和赋值的问题。</span><br><span class="line"></span><br><span class="line">添加DOM</span><br><span class="line">要添加新的DOM节点，除了通过jQuery的 html() 这种暴力方法外，还可以用 append() 方法，例</span><br><span class="line">如：</span><br><span class="line">&lt;div id=<span class="string">&quot;test-div&quot;</span>&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">如何向列表新增一个语言？首先要拿到 &lt;ul&gt; 节点：</span><br><span class="line"><span class="keyword">var</span> ul = $(<span class="string">&#x27;#test-div&gt;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">然后，调用 append() 传入HTML片段：</span><br><span class="line">ul.append(<span class="string">&#x27;&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">append() 把DOM添加到最后， prepend() 则把DOM添加到最前。</span><br><span class="line">如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然</span><br><span class="line">后用 after() 方法：</span><br><span class="line"><span class="keyword">var</span> js = $(<span class="string">&#x27;#test-div&gt;ul&gt;li:first-child&#x27;</span>);</span><br><span class="line">js.after(<span class="string">&#x27;&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;&#x27;</span>);</span><br><span class="line">也就是说，同级节点可以用 after() 或者 before() 方法。</span><br><span class="line"></span><br><span class="line">删除节点</span><br><span class="line">要删除DOM节点，拿到jQuery对象后直接调用 remove() 方法就可以了。如果jQuery对象包含若干</span><br><span class="line">DOM节点，实际上可以一次删除多个DOM节点：</span><br><span class="line"><span class="keyword">var</span> li = $(<span class="string">&#x27;#test-div&gt;ul&gt;li&#x27;</span>);</span><br><span class="line">li.remove(); <span class="comment">// 所有&lt;li&gt;全被删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">9.4</span>、事件</span><br><span class="line">jQuery能够绑定的事件主要包括：</span><br><span class="line">鼠标事件</span><br><span class="line">click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：</span><br><span class="line">鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函</span><br><span class="line">数，相当于mouseenter加上mouseleave。</span><br><span class="line">键盘事件</span><br><span class="line">键盘事件仅作用在当前焦点的DOM上，通常是 和 。</span><br><span class="line">keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。</span><br><span class="line">其他事件</span><br><span class="line">focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当 、 或 的内容改变时</span><br><span class="line">触发； submit：当 提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。</span><br><span class="line"></span><br><span class="line">初始化事件</span><br><span class="line">我们自己的初始化代码必须放到 <span class="built_in">document</span> 对象的 ready 事件中，保证DOM已完成初始化：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;ready&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">&#x27;#testForm).on(&#x27;</span>submit<span class="string">&#x27;, function () &#123;</span></span><br><span class="line"><span class="string">alert(&#x27;</span>submit!<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;form id=&quot;testForm&quot;&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。</span></span><br><span class="line"><span class="string">由于 ready 事件使用非常普遍，所以可以这样简化：</span></span><br><span class="line"><span class="string">$(document).ready(function () &#123;</span></span><br><span class="line"><span class="string">// on(&#x27;</span>submit<span class="string">&#x27;, function)也可以简化:</span></span><br><span class="line">$(&#x27;#testForm).submit(function () &#123;</span><br><span class="line">alert(<span class="string">&#x27;submit!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">甚至还可以再简化为：</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// init...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">事件参数</span><br><span class="line">有些事件，如 mousemove 和 keypress ，我们需要获取鼠标位置和按键的值，否则监听这些事件就</span><br><span class="line">没什么意义了。所有事件都会传入 Event 对象作为参数，可以从 Event 对象上获取到更多的信息：</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#testMouseMoveDiv&#123;</span><br><span class="line">width: <span class="number">300</span>px;</span><br><span class="line">height: <span class="number">300</span>px;</span><br><span class="line">border: <span class="number">1</span>px solid black;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">mousemove: <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;testMouseMoveSpan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">&quot;testMouseMoveDiv&quot;</span>&gt;</span><br><span class="line">在此区域移动鼠标试试</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">&#x27;#testMouseMoveDiv&#x27;</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">$(<span class="string">&#x27;#testMouseMoveSpan&#x27;</span>).text(<span class="string">&#x27;pageX = &#x27;</span> + e.pageX + <span class="string">&#x27;, pageY = &#x27;</span></span><br><span class="line">+ e.pageY);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>docker初学习</title>
    <url>/2021/03/11/docker%E5%88%9D%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="docker镜像构建"><a href="#docker镜像构建" class="headerlink" title="docker镜像构建"></a>docker镜像构建</h1><h2 id="1-虚拟机准备"><a href="#1-虚拟机准备" class="headerlink" title="1. 虚拟机准备"></a>1. 虚拟机准备</h2><h3 id="1-1-安装vmware"><a href="#1-1-安装vmware" class="headerlink" title="1.1 安装vmware"></a>1.1 安装vmware</h3><h3 id="1-2-安装虚拟机镜像"><a href="#1-2-安装虚拟机镜像" class="headerlink" title="1.2 安装虚拟机镜像"></a>1.2 安装虚拟机镜像</h3><h4 id="打开虚拟机镜像"><a href="#打开虚拟机镜像" class="headerlink" title="打开虚拟机镜像"></a>打开虚拟机镜像</h4><p>​    点击<strong>打开虚拟机</strong>，选择虚拟机镜像</p>
<a id="more"></a>

<h4 id="设置虚拟机"><a href="#设置虚拟机" class="headerlink" title="设置虚拟机"></a>设置虚拟机</h4><p>虚拟机网络模式设置为<strong>NAT</strong></p>
<ol>
<li><p>root 用户登录，密码1234</p>
</li>
<li><p>设置静态ip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">----------------</span><br><span class="line">IPADDR=192.168.134.101</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">GATEWAY=192.168.134.2</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="comment"># 以上参数设置根据各自的vmnet8的地址改变</span></span><br></pre></td></tr></table></figure>

<p>重启虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot now</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h2><h3 id="2-1-配置yum安装源"><a href="#2-1-配置yum安装源" class="headerlink" title="2.1 配置yum安装源"></a>2.1 配置yum安装源</h3><p>访问阿里云获取docker安装源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># Step 4: 设置docker自启动和开启</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span></span><br><span class="line"><span class="comment"># vim /etc/yum.repos.d/docker-ee.repo</span></span><br><span class="line"><span class="comment">#   将[docker-ce-test]下方的enabled=0修改为enabled=1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="comment"># yum list docker-ce.x86_64 --showduplicates | sort -r</span></span><br><span class="line"><span class="comment">#   Loading mirror speeds from cached hostfile</span></span><br><span class="line"><span class="comment">#   Loaded plugins: branch, fastestmirror, langpacks</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   Available Packages</span></span><br><span class="line"><span class="comment"># Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)</span></span><br><span class="line"><span class="comment"># sudo yum -y install docker-ce-[VERSION]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-配置docker镜像加速器"><a href="#2-2-配置docker镜像加速器" class="headerlink" title="2.2 配置docker镜像加速器"></a>2.2 配置docker镜像加速器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir -p /etc/docker</span><br><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="2-3-配置iptables"><a href="#2-3-配置iptables" class="headerlink" title="2.3 配置iptables"></a>2.3 配置iptables</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /etc/sysctl.conf &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">$ sysctl -p</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="3-纯手动部署docker项目"><a href="#3-纯手动部署docker项目" class="headerlink" title="3. 纯手动部署docker项目"></a>3. 纯手动部署docker项目</h2><p>​    在实际生产环境中，我们需要依赖于容器编排工具来实现动态扩容、服务发现、运行监测等工作。还需要通过工具来实现持续集成和持续部署，因此纯手动的方式几乎是不可能满足生产环境中庞大的运维工作的，因此，这里只是作为演示，并且通过手动搭建掌握docker基本概念和命令。</p>
<h3 id="docker安装并且运行mysql"><a href="#docker安装并且运行mysql" class="headerlink" title="docker安装并且运行mysql"></a>docker安装并且运行mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -p 3307:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">                     虚拟机：容器的</span><br></pre></td></tr></table></figure>

<p>mysql:5.7 确定了当前容器所基于的镜像</p>
<p>mysql:5.7镜像文件是从dockerhub中获取的（通过阿里云镜像加速器获取）</p>
<h4 id="docker-run命令"><a href="#docker-run命令" class="headerlink" title="docker run命令"></a>docker run命令</h4><p>run命令：</p>
<ol>
<li>创建并且启动容器</li>
<li>尝试访问容器基于的镜像，如果镜像存在，就直接根据镜像创建容器，否则，会从远程仓库中获取镜像的定义文件</li>
</ol>
<h3 id="docker-registry-服务"><a href="#docker-registry-服务" class="headerlink" title="docker registry 服务"></a>docker registry 服务</h3><ul>
<li><p>一个registry服务可以有多个仓库</p>
</li>
<li><p>一个仓库可以有多个标签，每一个标签对应一个镜像，以mysql为例：标签同时代表了mysql的版本号，根据不同的标签我们就可以获取不同mysql版本的镜像。</p>
<blockquote>
<p>特殊的版本： latest一般代表最新的标签，最新版</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>去远程registry服务下载镜像：三要素：</p>
<ol>
<li>registry地址：如果不指定registry地址，默认使用docker官方的docker-registry，也就是docker-hub</li>
<li>仓库名称</li>
<li>tag标签。如果不指定tag标签，默认使用latest标签。</li>
</ol>
<p>比如：<code> sudo docker pull registry.cn-hangzhou.aliyuncs.com/zhaoqianli/myapp:v1</code></p>
<p>v.cn-hangzhou.aliyuncs.com/zhaoqianli:registry服务地址</p>
<p>myapp：仓库地址</p>
<p>v1:tag标签</p>
</blockquote>
<h3 id="docker-pull命令"><a href="#docker-pull命令" class="headerlink" title="docker pull命令"></a>docker pull命令</h3><p>用来下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line">             可选的参数 镜像名  标签（可选，默认用latest）</span><br></pre></td></tr></table></figure>

<h3 id="docker-image命令"><a href="#docker-image命令" class="headerlink" title="docker image命令"></a>docker image命令</h3><p>用于管理镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls //列出镜像</span><br><span class="line">docker image rm  [image id](image name) </span><br><span class="line">//rm 如果要删除的镜像已经有对应的容器存在，那么镜像不能删除，除非指定强制删除的参数-f</span><br><span class="line">//即使强制删除，但是只要有容器在运行，只是删除了镜像的仓库名称和tag而已，镜像仍然会以匿名的形式存在于docker引擎当中</span><br></pre></td></tr></table></figure>





<h3 id="docker-批量操作容器"><a href="#docker-批量操作容器" class="headerlink" title="docker 批量操作容器"></a>docker 批量操作容器</h3><p>docker中 启动所有的容器命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker start $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>docker中    关闭所有的容器命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>docker中 删除所有的容器命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>docker中    删除所有的镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> |tail -n +<span class="number">2</span>)</span><br></pre></td></tr></table></figure>





<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx  <span class="comment">#设定基础镜像</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="comment">#RUN指令在容器创建启动之时会执行其中定义的命令</span></span><br><span class="line"><span class="comment"># /usr/share/nginx/html/index .html 指的是容器内部的文件系统的路径，代表ngnix的首页</span></span><br></pre></td></tr></table></figure>



<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t mynginx:1.0 .  </span><br><span class="line"><span class="comment"># -t 指定镜像的名称和tag</span></span><br><span class="line"><span class="comment"># . 指定上下文环境</span></span><br></pre></td></tr></table></figure>

<h4 id="自启动命令"><a href="#自启动命令" class="headerlink" title="自启动命令"></a>自启动命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redi s-5.0.3.tar.gz&quot;</span> </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis RUN make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \ </span></span><br><span class="line">&amp;&amp; apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y $buildDeps \ </span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/r edis-5.0.3.tar.gz&quot;</span> \ </span><br><span class="line">&amp;&amp; mkdir -p /usr/src/redis \ </span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-component s=<span class="number">1</span> \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis \ </span><br><span class="line">&amp;&amp; make -C /usr/src/redis install \ </span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* \ </span><br><span class="line">&amp;&amp; rm redis.tar.gz \ </span><br><span class="line">&amp;&amp; rm -r /usr/src/redis \ </span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<h3 id="Copy指令"><a href="#Copy指令" class="headerlink" title="Copy指令"></a>Copy指令</h3><p>将上下文目录中的文件拷贝到容器对应的位置</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br><span class="line"><span class="comment">#将上下文目录中的json文件考培到容器/usr/src/app目录之下</span></span><br></pre></td></tr></table></figure>



<h3 id="RUN-CMD-ENTRYPOINT-区别"><a href="#RUN-CMD-ENTRYPOINT-区别" class="headerlink" title="RUN CMD ENTRYPOINT    区别"></a>RUN CMD ENTRYPOINT    区别</h3><p>RUN: 单纯的执行命令       写多个RUN指令</p>
<p>CMD: 会覆盖基础镜像的默认的启动命令         CMD只能出现一次</p>
<h3 id="Volume挂载卷"><a href="#Volume挂载卷" class="headerlink" title="Volume挂载卷"></a>Volume挂载卷</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过卷的挂载，我们可以将数据和容器进行分离，让动态的数据保存在宿主机或者是分布式的文件系统当中，即使容器挂掉了，数据得以保留</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8082:80 -v /opt/mynginx/html/:/usr/share/nginx/html/ mynginx:4.0</span><br><span class="line"><span class="comment"># /opt/mynginx/html/ 宿主机的真实目录</span></span><br><span class="line"><span class="comment"># /usr/share/nginx/html/ 虚拟机的被挂载的目录</span></span><br></pre></td></tr></table></figure>





<h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create &lt;网络名称&gt;</span><br></pre></td></tr></table></figure>



<h3 id="mysql容器的初始化"><a href="#mysql容器的初始化" class="headerlink" title="mysql容器的初始化"></a>mysql容器的初始化</h3><ol>
<li><p>在虚拟机下创建一个文件夹，用于存储mysql容器生产的动态数据,挂载到<code>/var/lib/mysql</code>路径下</p>
</li>
<li><p>将初始化sql挂载到容器的<code>/docker-entrypoint-initdb.d</code>路径下</p>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name his-db -d -p 3306:3306 -v /opt/his-db/datas:/var/lib/mysql -v /opt/his-db/drug.sql:/docker-entrypoint-initdb.d/init.sql mysql:5.7</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp   &lt;源文件&gt;     &lt;目标位置&gt;</span><br><span class="line">scp   &#x2F;drug.sql   root@192.168.134.160:&#x2F;opt&#x2F;his-db&#x2F;</span><br><span class="line">scp -r &#x2F;dir1       root@xxxxxx:&#x2F;opt&#x2F;  # -r 递归拷贝文件夹和文件夹中的内容</span><br></pre></td></tr></table></figure>



<h3 id="docker-logs命令"><a href="#docker-logs命令" class="headerlink" title="docker logs命令"></a>docker logs命令</h3><p>用于检查容器的日志信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs [options] CONTAINER_NAME/CONTIANER_ID</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试相关(网络整理)</title>
    <url>/2021/03/09/java%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86)/</url>
    <content><![CDATA[ <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">包含的模块</span><br><span class="line">本文分为十九个模块，分别是： Java 基础、容器、多线程、反射、对象拷贝、Java Web 、</span><br><span class="line">异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、</span><br><span class="line">MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如下图所示：</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">模块图:</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/10/UFEJLqmZBrwDGCo.png"></p>
<h3 id="剑指offer题解https-www-cnblogs-com-dockerchen-p-11924939-html"><a href="#剑指offer题解https-www-cnblogs-com-dockerchen-p-11924939-html" class="headerlink" title="剑指offer题解https://www.cnblogs.com/dockerchen/p/11924939.html"></a>剑指offer题解<a href="https://www.cnblogs.com/dockerchen/p/11924939.html">https://www.cnblogs.com/dockerchen/p/11924939.html</a></h3><h3 id="来源整理-博客园https-www-cnblogs-com-51ma-p-12462688-html-自己添加修改"><a href="#来源整理-博客园https-www-cnblogs-com-51ma-p-12462688-html-自己添加修改" class="headerlink" title="来源整理(博客园https://www.cnblogs.com/51ma/p/12462688.html)自己添加修改"></a>来源整理(博客园<a href="https://www.cnblogs.com/51ma/p/12462688.html)%E8%87%AA%E5%B7%B1%E6%B7%BB%E5%8A%A0%E4%BF%AE%E6%94%B9">https://www.cnblogs.com/51ma/p/12462688.html)自己添加修改</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java 基础</span><br><span class="line"><span class="number">1.</span> JDK 和 JRE 有什么区别？</span><br><span class="line">JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</span><br><span class="line">JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</span><br><span class="line">具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> == 和 equals 的区别是什么？</span><br><span class="line">== 解读</span><br><span class="line"></span><br><span class="line">对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</span><br><span class="line"></span><br><span class="line">基本类型：比较的是值是否相同；</span><br><span class="line">引用类型：比较的是引用是否相同；</span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br><span class="line">代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 <span class="keyword">true</span>，而 <span class="keyword">new</span> String()方法则重写开辟了内存空间，所以 == 结果为 <span class="keyword">false</span>，而 equals 比较的一直是值，所以结果都为 <span class="keyword">true</span>。</span><br><span class="line"></span><br><span class="line">equals 解读</span><br><span class="line"></span><br><span class="line">equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</span><br><span class="line"></span><br><span class="line">首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</span><br><span class="line"></span><br><span class="line">classCat&#123;</span><br><span class="line">    publicCat(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoidsetName(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br><span class="line">输出结果出乎我们的意料，竟然是 <span class="keyword">false</span>？这是怎么回事，看了 equals 源码就知道了，源码如下：</span><br><span class="line"></span><br><span class="line">publicbooleanequals(Object obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line">原来 equals 本质上就是 ==。</span><br><span class="line"></span><br><span class="line">那问题来了，两个相同值的 String 对象，为什么返回的是 <span class="keyword">true</span>？代码如下：</span><br><span class="line"></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</span><br><span class="line"></span><br><span class="line">publicbooleanequals(Object anObject)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</span><br><span class="line"></span><br><span class="line">总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 两个对象的 hashCode() 相同，则 equals() 也一定为 <span class="keyword">true</span>，对吗？</span><br><span class="line">不对，两个对象的 hashCode() 相同，equals() 不一定 <span class="keyword">true</span>。</span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br><span class="line">执行的结果：</span><br><span class="line"></span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 <span class="keyword">false</span>，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">final</span> 在 Java 中有什么作用？</span><br><span class="line"><span class="keyword">final</span> 修饰的类叫最终类，该类不能被继承。</span><br><span class="line"><span class="keyword">final</span> 修饰的方法不能被重写。</span><br><span class="line"><span class="keyword">final</span> 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</span><br><span class="line"><span class="number">5.</span> Java 中的 Math. round(-<span class="number">1.</span> <span class="number">5</span>) 等于多少？</span><br><span class="line">等于 -<span class="number">1</span>，因为在数轴上取值时，中间值（<span class="number">0.5</span>）向右取整，所以正 <span class="number">0.5</span> 是往上取整，负 <span class="number">0.5</span> 是直接舍弃。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> String 属于基础的数据类型吗？</span><br><span class="line">String 不属于基础类型，基础类型有 <span class="number">8</span> 种：<span class="keyword">byte</span>、<span class="keyword">boolean</span>、<span class="keyword">char</span>、<span class="keyword">short</span>、<span class="keyword">int</span>、<span class="keyword">float</span>、<span class="keyword">long</span>、<span class="keyword">double</span>，而 String 属于对象。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Java 中操作字符串都有哪些类？它们之间有什么区别？</span><br><span class="line">操作字符串的类有：String、StringBuffer、StringBuilder。</span><br><span class="line"></span><br><span class="line">String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</span><br><span class="line"></span><br><span class="line">StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> String str=<span class="string">&quot;i&quot;</span>与 String str=<span class="keyword">new</span> String(<span class="string">&quot;i&quot;</span>)一样吗？</span><br><span class="line">不一样，因为内存的分配方式不一样。String str=<span class="string">&quot;i&quot;</span>的方式，Java 虚拟机会将其分配到常量池中；而 String str=<span class="keyword">new</span> String(<span class="string">&quot;i&quot;</span>) 则会被分到堆内存中。</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 如何将字符串反转？</span><br><span class="line">使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="number">10.</span> String 类的常用方法都有那些？</span><br><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 <span class="keyword">byte</span> 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br><span class="line"><span class="number">11.</span> 抽象类必须要有抽象方法吗？</span><br><span class="line">不需要，抽象类不一定非要有抽象方法。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> classCat&#123;</span><br><span class="line">    publicstaticvoidsayHi()&#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码，抽象类并没有抽象方法但完全可以正常运行。</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 普通类和抽象类有哪些区别？</span><br><span class="line">普通类不能包含抽象方法，抽象类可以包含抽象方法。</span><br><span class="line">抽象类不能直接实例化，普通类可以直接实例化。</span><br><span class="line"><span class="number">13.</span> 抽象类能使用 <span class="keyword">final</span> 修饰吗？</span><br><span class="line">不能，定义抽象类就是让其他类继承的，如果定义为 <span class="keyword">final</span> 该类就不能被继承，这样彼此就会产生矛盾，所以 <span class="keyword">final</span> 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</span><br><span class="line"></span><br><span class="line">编译器保存图</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/10/LsaZ4loENckiu3h.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14.</span> 接口和抽象类有什么区别？</span><br><span class="line">实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</span><br><span class="line">构造函数：抽象类可以有构造函数；接口不能有。</span><br><span class="line">实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</span><br><span class="line">访问修饰符：接口中的方法默认使用 <span class="keyword">public</span> 修饰；抽象类中的方法可以是任意访问修饰符。</span><br><span class="line"><span class="number">15.</span> Java 中 IO 流分为几种？</span><br><span class="line">按功能来分：输入流（input）、输出流（output）。</span><br><span class="line"></span><br><span class="line">按类型来分：字节流和字符流。</span><br><span class="line"></span><br><span class="line">字节流和字符流的区别是：字节流按 <span class="number">8</span> 位传输以字节为单位输入输出数据，字符流按 <span class="number">16</span> 位传输以字符为单位输入输出数据。</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> BIO、NIO、AIO 有什么区别？</span><br><span class="line">BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</span><br><span class="line">NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</span><br><span class="line">AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</span><br><span class="line"><span class="number">17.</span> Files的常用方法都有哪些？</span><br><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br><span class="line">容器</span><br><span class="line"><span class="number">18.</span> Java 容器都有哪些？</span><br><span class="line">Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</span><br><span class="line"></span><br><span class="line">Collection</span><br><span class="line">List</span><br><span class="line">ArrayList</span><br><span class="line">LinkedList</span><br><span class="line">Vector</span><br><span class="line">Stack</span><br><span class="line">Set</span><br><span class="line">HashSet</span><br><span class="line">LinkedHashSet</span><br><span class="line">TreeSet</span><br><span class="line">Map</span><br><span class="line">HashMap</span><br><span class="line">LinkedHashMap</span><br><span class="line">TreeMap</span><br><span class="line">ConcurrentHashMap</span><br><span class="line">Hashtable</span><br><span class="line"><span class="number">19.</span> Collection 和 Collections 有什么区别？</span><br><span class="line">Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</span><br><span class="line">Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</span><br><span class="line"><span class="number">20.</span> List、Set、Map 之间的区别是什么？</span><br><span class="line">List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</span><br><span class="line"></span><br><span class="line">三者之间的区别，如下表：</span><br><span class="line"></span><br><span class="line">区别图</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/10/KZXR4mCQk2f6Ewn.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21.</span> HashMap 和 Hashtable 有什么区别？</span><br><span class="line">存储：HashMap 运行 key 和 value 为 <span class="keyword">null</span>，而 Hashtable 不允许。</span><br><span class="line">线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</span><br><span class="line">推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</span><br><span class="line"><span class="number">22.</span> 如何决定使用 HashMap 还是 TreeMap？</span><br><span class="line">对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</span><br><span class="line"></span><br><span class="line"><span class="number">23.</span> 说一下 HashMap 的实现原理？</span><br><span class="line">HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</span><br><span class="line"></span><br><span class="line"><span class="number">24.</span> 说一下 HashSet 的实现原理？</span><br><span class="line">HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</span><br><span class="line"></span><br><span class="line"><span class="number">25.</span> ArrayList 和 LinkedList 的区别是什么？</span><br><span class="line">数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</span><br><span class="line">随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</span><br><span class="line">增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</span><br><span class="line">综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</span><br><span class="line"></span><br><span class="line"><span class="number">26.</span> 如何实现数组和 List 之间的转换？</span><br><span class="line">数组转 List：使用 Arrays. asList(array) 进行转换。</span><br><span class="line">List 转数组：使用 List 自带的 toArray() 方法。</span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">list. add(<span class="string">&quot;的博客&quot;</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;王磊&quot;</span>,<span class="string">&quot;的博客&quot;</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br><span class="line"><span class="number">27.</span> ArrayList 和 Vector 的区别是什么？</span><br><span class="line">线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</span><br><span class="line">性能：ArrayList 在性能方面要优于 Vector。</span><br><span class="line">扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 <span class="number">1</span> 倍，而 ArrayList 只会增加 <span class="number">50</span>%。</span><br><span class="line"><span class="number">28.</span> Array 和 ArrayList 有何区别？</span><br><span class="line">Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</span><br><span class="line">Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</span><br><span class="line">Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</span><br><span class="line"><span class="number">29.</span> 在 Queue 中 poll()和 remove()有什么区别？</span><br><span class="line">相同点：都是返回第一个元素，并在队列中删除返回的对象。</span><br><span class="line">不同点：如果没有元素 poll()会返回 <span class="keyword">null</span>，而 remove()会直接抛出 NoSuchElementException 异常。</span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br><span class="line"><span class="number">30.</span> 哪些集合类是线程安全的？</span><br><span class="line">Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK <span class="number">1.5</span> 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</span><br><span class="line"></span><br><span class="line"><span class="number">31.</span> 迭代器 Iterator 是什么？</span><br><span class="line">Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</span><br><span class="line"></span><br><span class="line"><span class="number">32.</span> Iterator 怎么使用？有什么特点？</span><br><span class="line">Iterator 使用代码如下：</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br><span class="line">Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</span><br><span class="line"></span><br><span class="line"><span class="number">33.</span> Iterator 和 ListIterator 有什么区别？</span><br><span class="line">Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</span><br><span class="line">Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</span><br><span class="line">ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</span><br><span class="line"><span class="number">34.</span> 怎么确保一个集合不能被修改？</span><br><span class="line">可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</span><br><span class="line"></span><br><span class="line">示例代码如下：</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br><span class="line">多线程</span><br><span class="line"><span class="number">35.</span> 并行和并发有什么区别？</span><br><span class="line">并行：多个处理器或多核处理器同时处理多个任务。</span><br><span class="line">并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</span><br><span class="line">如下图：</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/10/Zl2cyQk89K3MtuD.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">并发和并行</span><br><span class="line"></span><br><span class="line">并发 = 两个队列和一台咖啡机。</span><br><span class="line"></span><br><span class="line">并行 = 两个队列和两台咖啡机。</span><br><span class="line"></span><br><span class="line"><span class="number">36.</span> 线程和进程的区别？</span><br><span class="line">一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</span><br><span class="line"></span><br><span class="line"><span class="number">37.</span> 守护线程是什么？</span><br><span class="line">守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</span><br><span class="line"></span><br><span class="line"><span class="number">38.</span> 创建线程有哪几种方式？</span><br><span class="line">创建线程有三种方式：</span><br><span class="line"></span><br><span class="line">继承 Thread 重写 run 方法；</span><br><span class="line">实现 Runnable 接口；</span><br><span class="line">实现 Callable 接口。</span><br><span class="line"><span class="number">39.</span> 说一下 runnable 和 callable 有什么区别？</span><br><span class="line">runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</span><br><span class="line"></span><br><span class="line"><span class="number">40.</span> 线程有哪些状态？</span><br><span class="line">线程的状态：</span><br><span class="line"></span><br><span class="line">NEW 尚未启动</span><br><span class="line">RUNNABLE 正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</span><br><span class="line">WAITING 永久等待状态</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态</span><br><span class="line">TERMINATED 执行完成</span><br><span class="line"><span class="number">41.</span> sleep() 和 wait() 有什么区别？</span><br><span class="line">类的不同：sleep() 来自 Thread，wait() 来自 Object。</span><br><span class="line">释放锁：sleep() 不释放锁；wait() 释放锁。</span><br><span class="line">用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</span><br><span class="line"><span class="number">42.</span> notify()和 notifyAll()有什么区别？</span><br><span class="line">notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</span><br><span class="line"></span><br><span class="line"><span class="number">43.</span> 线程的 run() 和 start() 有什么区别？</span><br><span class="line">start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</span><br><span class="line"></span><br><span class="line"><span class="number">44.</span> 创建线程池有哪几种方式？</span><br><span class="line">线程池创建有七种方式，最核心的是最后一种：</span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 <span class="number">1</span>，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</span><br><span class="line"></span><br><span class="line">newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 <span class="number">60</span> 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</span><br><span class="line"></span><br><span class="line">newFixedThreadPool(<span class="keyword">int</span> nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</span><br><span class="line"></span><br><span class="line">newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</span><br><span class="line"></span><br><span class="line">newScheduledThreadPool(<span class="keyword">int</span> corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</span><br><span class="line"></span><br><span class="line">newWorkStealingPool(<span class="keyword">int</span> parallelism)：这是一个经常被人忽略的线程池，Java <span class="number">8</span> 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor()：是最原始的线程池创建，上面<span class="number">1</span>-<span class="number">3</span>创建方式都是对ThreadPoolExecutor的封装。</span><br><span class="line"></span><br><span class="line"><span class="number">45.</span> 线程池都有哪些状态？</span><br><span class="line">RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</span><br><span class="line">SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</span><br><span class="line">STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</span><br><span class="line">TIDYING：所有的任务都销毁了，workCount 为 <span class="number">0</span>，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</span><br><span class="line">TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</span><br><span class="line"><span class="number">46.</span> 线程池中 submit() 和 execute() 方法有什么区别？</span><br><span class="line">execute()：只能执行 Runnable 类型的任务。</span><br><span class="line">submit()：可以执行 Runnable 和 Callable 类型的任务。</span><br><span class="line">Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</span><br><span class="line"></span><br><span class="line"><span class="number">47.</span> 在 Java 程序中怎么保证多线程的运行安全？</span><br><span class="line">方法一：使用安全类，比如 Java. util. concurrent 下的类。</span><br><span class="line">方法二：使用自动锁 <span class="keyword">synchronized</span>。</span><br><span class="line">方法三：使用手动锁 Lock。</span><br><span class="line">手动锁 Java 示例代码如下：</span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">48.</span> 多线程中 <span class="keyword">synchronized</span> 锁升级的原理是什么？</span><br><span class="line"><span class="keyword">synchronized</span> 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 <span class="keyword">synchronized</span> 锁的升级。</span><br><span class="line"></span><br><span class="line">锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java <span class="number">6</span> 之后优化 <span class="keyword">synchronized</span> 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</span><br><span class="line"></span><br><span class="line"><span class="number">49.</span> 什么是死锁？</span><br><span class="line">当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</span><br><span class="line"></span><br><span class="line"><span class="number">50.</span> 怎么防止死锁？</span><br><span class="line">尽量使用 tryLock(<span class="keyword">long</span> timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</span><br><span class="line">尽量使用 Java. util. concurrent 并发类代替自己手写锁。</span><br><span class="line">尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</span><br><span class="line">尽量减少同步的代码块。</span><br><span class="line"><span class="number">51.</span> ThreadLocal 是什么？有哪些使用场景？</span><br><span class="line">ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</span><br><span class="line"></span><br><span class="line">ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</span><br><span class="line"></span><br><span class="line"><span class="number">52.</span> 说一下 <span class="keyword">synchronized</span> 底层实现原理？</span><br><span class="line"><span class="keyword">synchronized</span> 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java <span class="number">6</span> 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java <span class="number">6</span> 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</span><br><span class="line"></span><br><span class="line"><span class="number">53.</span> <span class="keyword">synchronized</span> 和 <span class="keyword">volatile</span> 的区别是什么？</span><br><span class="line"><span class="keyword">volatile</span> 是变量修饰符；<span class="keyword">synchronized</span> 是修饰类、方法、代码段。</span><br><span class="line"><span class="keyword">volatile</span> 仅能实现变量的修改可见性，不能保证原子性；而 <span class="keyword">synchronized</span> 则可以保证变量的修改可见性和原子性。</span><br><span class="line"><span class="keyword">volatile</span> 不会造成线程的阻塞；<span class="keyword">synchronized</span> 可能会造成线程的阻塞。</span><br><span class="line"><span class="number">54.</span> <span class="keyword">synchronized</span> 和 Lock 有什么区别？</span><br><span class="line"><span class="keyword">synchronized</span> 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</span><br><span class="line"><span class="keyword">synchronized</span> 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</span><br><span class="line">通过 Lock 可以知道有没有成功获取锁，而 <span class="keyword">synchronized</span> 却无法办到。</span><br><span class="line"><span class="number">55.</span> <span class="keyword">synchronized</span> 和 ReentrantLock 区别是什么？</span><br><span class="line"><span class="keyword">synchronized</span> 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java <span class="number">6</span> 中对 <span class="keyword">synchronized</span> 进行了非常多的改进。</span><br><span class="line"></span><br><span class="line">主要区别如下：</span><br><span class="line"></span><br><span class="line">ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</span><br><span class="line">ReentrantLock 必须手动获取与释放锁，而 <span class="keyword">synchronized</span> 不需要手动释放和开启锁；</span><br><span class="line">ReentrantLock 只适用于代码块锁，而 <span class="keyword">synchronized</span> 可用于修饰方法、代码块等。</span><br><span class="line"><span class="number">56.</span> 说一下 atomic 的原理？</span><br><span class="line">atomic 主要利用 CAS (Compare And Wwap) 和 <span class="keyword">volatile</span> 和 <span class="keyword">native</span> 方法来保证原子操作，从而避免 <span class="keyword">synchronized</span> 的高开销，执行效率大为提升。</span><br><span class="line"></span><br><span class="line">反射</span><br><span class="line"><span class="number">57.</span> 什么是反射？</span><br><span class="line">反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</span><br><span class="line"></span><br><span class="line"><span class="number">58.</span> 什么是 Java 序列化？什么情况下需要序列化？</span><br><span class="line">Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</span><br><span class="line"></span><br><span class="line">以下情况需要使用 Java 序列化：</span><br><span class="line"></span><br><span class="line">想把的内存中的对象状态保存到一个文件中或者数据库中时候；</span><br><span class="line">想用套接字在网络上传送对象的时候；</span><br><span class="line">想通过RMI（远程方法调用）传输对象的时候。</span><br><span class="line"><span class="number">59.</span> 动态代理是什么？有哪些应用？</span><br><span class="line">动态代理是运行时动态生成代理类。</span><br><span class="line"></span><br><span class="line">动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</span><br><span class="line"></span><br><span class="line"><span class="number">60.</span> 怎么实现动态代理？</span><br><span class="line">JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</span><br><span class="line"></span><br><span class="line">对象拷贝</span><br><span class="line"><span class="number">61.</span> 为什么要使用克隆？</span><br><span class="line">克隆的对象可能包含一些已经修改过的属性，而 <span class="keyword">new</span> 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</span><br><span class="line"></span><br><span class="line"><span class="number">62.</span> 如何实现对象克隆？</span><br><span class="line">实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</span><br><span class="line">实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</span><br><span class="line"><span class="number">63.</span> 深拷贝和浅拷贝区别是什么？</span><br><span class="line">浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</span><br><span class="line">深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</span><br><span class="line">Java Web</span><br><span class="line"><span class="number">64.</span> JSP 和 servlet 有什么区别？</span><br><span class="line">JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</span><br><span class="line"></span><br><span class="line"><span class="number">65.</span> JSP 有哪些内置对象？作用分别是什么？</span><br><span class="line">JSP 有 <span class="number">9</span> 大内置对象：</span><br><span class="line"></span><br><span class="line">request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</span><br><span class="line">response：封装服务器对客户端的响应；</span><br><span class="line">pageContext：通过该对象可以获取其他对象；</span><br><span class="line">session：封装用户会话的对象；</span><br><span class="line">application：封装服务器运行环境的对象；</span><br><span class="line">out：输出服务器响应的输出流对象；</span><br><span class="line">config：Web 应用的配置对象；</span><br><span class="line">page：JSP 页面本身（相当于 Java 程序中的 <span class="keyword">this</span>）；</span><br><span class="line">exception：封装页面抛出异常的对象。</span><br><span class="line"><span class="number">66.</span> 说一下 JSP 的 <span class="number">4</span> 种作用域？</span><br><span class="line">page：代表与一个页面相关的对象和属性。</span><br><span class="line">request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</span><br><span class="line">session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</span><br><span class="line">application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</span><br><span class="line"><span class="number">67.</span> session 和 cookie 有什么区别？</span><br><span class="line">存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</span><br><span class="line">安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</span><br><span class="line">容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</span><br><span class="line">存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</span><br><span class="line"><span class="number">68.</span> 说一下 session 的工作原理？</span><br><span class="line">session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</span><br><span class="line"></span><br><span class="line"><span class="number">69.</span> 如果客户端禁止 cookie 能实现 session 还能用吗？</span><br><span class="line">可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</span><br><span class="line"></span><br><span class="line"><span class="number">70.</span> spring mvc 和 struts 的区别是什么？</span><br><span class="line">拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</span><br><span class="line">数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</span><br><span class="line">拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</span><br><span class="line">对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 <span class="meta">@ResponseBody</span> 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</span><br><span class="line"><span class="number">71.</span> 如何避免 SQL 注入？</span><br><span class="line">使用预处理 PreparedStatement。</span><br><span class="line">使用正则表达式过滤掉字符中的特殊字符。</span><br><span class="line"><span class="number">72.</span> 什么是 XSS 攻击，如何避免？</span><br><span class="line">XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</span><br><span class="line"></span><br><span class="line">预防 XSS 的核心是必须对输入的数据做过滤处理。</span><br><span class="line"></span><br><span class="line"><span class="number">73.</span> 什么是 CSRF 攻击，如何避免？</span><br><span class="line">CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</span><br><span class="line"></span><br><span class="line">防御手段：</span><br><span class="line"></span><br><span class="line">验证请求来源地址；</span><br><span class="line">关键操作添加验证码；</span><br><span class="line">在请求地址添加 token 并验证。</span><br><span class="line">异常</span><br><span class="line"><span class="number">74.</span> <span class="keyword">throw</span> 和 <span class="keyword">throws</span> 的区别？</span><br><span class="line"><span class="keyword">throw</span>：是真实抛出一个异常。</span><br><span class="line"><span class="keyword">throws</span>：是声明可能会抛出一个异常。</span><br><span class="line"><span class="number">75.</span> <span class="keyword">final</span>、<span class="keyword">finally</span>、finalize 有什么区别？</span><br><span class="line"><span class="keyword">final</span>：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</span><br><span class="line"><span class="keyword">finally</span>：是 <span class="keyword">try</span>&#123;&#125; <span class="keyword">catch</span>&#123;&#125; <span class="keyword">finally</span>&#123;&#125; 最后一部分，表示不论发生任何情况都会执行，<span class="keyword">finally</span> 部分可以省略，但如果 <span class="keyword">finally</span> 部分存在，则一定会执行 <span class="keyword">finally</span> 里面的代码。</span><br><span class="line">finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</span><br><span class="line"><span class="number">76.</span> <span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span> 中哪个部分可以省略？</span><br><span class="line"><span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span> 其中 <span class="keyword">catch</span> 和 <span class="keyword">finally</span> 都可以被省略，但是不能同时省略，也就是说有 <span class="keyword">try</span> 的时候，必须后面跟一个 <span class="keyword">catch</span> 或者 <span class="keyword">finally</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">77.</span> <span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span> 中，如果 <span class="keyword">catch</span> 中 <span class="keyword">return</span> 了，<span class="keyword">finally</span> 还会执行吗？</span><br><span class="line"><span class="keyword">finally</span> 一定会执行，即使是 <span class="keyword">catch</span> 中 <span class="keyword">return</span> 了，<span class="keyword">catch</span> 中的 <span class="keyword">return</span> 会等 <span class="keyword">finally</span> 中的代码执行完之后，才会执行。</span><br><span class="line"></span><br><span class="line"><span class="number">78.</span> 常见的异常类有哪些？</span><br><span class="line">NullPointerException 空指针异常</span><br><span class="line">ClassNotFoundException 指定类不存在</span><br><span class="line">NumberFormatException 字符串转换为数字异常</span><br><span class="line">IndexOutOfBoundsException 数组下标越界异常</span><br><span class="line">ClassCastException 数据类型转换异常</span><br><span class="line">FileNotFoundException 文件未找到异常</span><br><span class="line">NoSuchMethodException 方法不存在异常</span><br><span class="line">IOException IO 异常</span><br><span class="line">SocketException Socket 异常</span><br><span class="line">网络</span><br><span class="line"><span class="number">79.</span> http 响应码 <span class="number">301</span> 和 <span class="number">302</span> 代表的是什么？有什么区别？</span><br><span class="line"><span class="number">301</span>：永久重定向。</span><br><span class="line"></span><br><span class="line"><span class="number">302</span>：暂时重定向。</span><br><span class="line"></span><br><span class="line">它们的区别是，<span class="number">301</span> 对搜索引擎优化（SEO）更加有利；<span class="number">302</span> 有被提示为网络拦截的风险。</span><br><span class="line"></span><br><span class="line"><span class="number">80.</span> forward 和 redirect 的区别？</span><br><span class="line">forward 是转发 和 redirect 是重定向：</span><br><span class="line"></span><br><span class="line">地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</span><br><span class="line">数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</span><br><span class="line">效率：forward 比 redirect 效率高。</span><br><span class="line"><span class="number">81.</span> 简述 tcp 和 udp的区别？</span><br><span class="line">tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</span><br><span class="line"></span><br><span class="line">两者的区别大致如下：</span><br><span class="line"></span><br><span class="line">tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</span><br><span class="line">tcp 提供可靠的服务（数据传输），udp 无法保证；</span><br><span class="line">tcp 面向字节流，udp 面向报文；</span><br><span class="line">tcp 数据传输慢，udp 数据传输快；</span><br><span class="line"><span class="number">82.</span> tcp 为什么要三次握手，两次不行吗？为什么？</span><br><span class="line">如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">83.</span> 说一下 tcp 粘包是怎么产生的？</span><br><span class="line">tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</span><br><span class="line"></span><br><span class="line">发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</span><br><span class="line">接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</span><br><span class="line"><span class="number">84.</span> OSI 的七层模型都有哪些？</span><br><span class="line">物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</span><br><span class="line">数据链路层：负责建立和管理节点间的链路。</span><br><span class="line">网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</span><br><span class="line">传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</span><br><span class="line">会话层：向两个实体的表示层提供建立和使用连接的方法。</span><br><span class="line">表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</span><br><span class="line">应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</span><br><span class="line"><span class="number">85.</span> get 和 post 请求有哪些区别？</span><br><span class="line">get 请求会被浏览器主动缓存，而 post 不会。</span><br><span class="line">get 传递参数有大小限制，而 post 没有。</span><br><span class="line">post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</span><br><span class="line"><span class="number">86.</span> 如何实现跨域？</span><br><span class="line">实现跨域有以下几种方案：</span><br><span class="line"></span><br><span class="line">服务器端运行跨域 设置 CORS 等于 *；</span><br><span class="line">在单个接口使用注解 <span class="meta">@CrossOrigin</span> 运行跨域；</span><br><span class="line">使用 jsonp 跨域；</span><br><span class="line"><span class="number">87.</span> 说一下 JSONP 实现原理？</span><br><span class="line">jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</span><br><span class="line"></span><br><span class="line">设计模式</span><br><span class="line"><span class="number">88.</span> 说一下你熟悉的设计模式？</span><br><span class="line">单例模式：保证被创建一次，节省系统开销。</span><br><span class="line">工厂模式（简单工厂、抽象工厂）：解耦代码。</span><br><span class="line">观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</span><br><span class="line">外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</span><br><span class="line">模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</span><br><span class="line">状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</span><br><span class="line"><span class="number">89.</span> 简单工厂和抽象工厂有什么区别？</span><br><span class="line">简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</span><br><span class="line">工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</span><br><span class="line">抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</span><br><span class="line">Spring/Spring MVC</span><br><span class="line"><span class="number">90.</span> 为什么要使用 spring？</span><br><span class="line">spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</span><br><span class="line">spring 提供了事务支持，使得事务操作变的更加方便。</span><br><span class="line">spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</span><br><span class="line">更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</span><br><span class="line"><span class="number">91.</span> 解释一下什么是 aop？</span><br><span class="line">aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</span><br><span class="line"></span><br><span class="line">简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</span><br><span class="line"></span><br><span class="line"><span class="number">92.</span> 解释一下什么是 ioc？</span><br><span class="line">ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</span><br><span class="line"></span><br><span class="line">简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</span><br><span class="line"></span><br><span class="line"><span class="number">93.</span> spring 有哪些主要模块？</span><br><span class="line">spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</span><br><span class="line">spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</span><br><span class="line">spring dao：Data Access Object 提供了JDBC的抽象层。</span><br><span class="line">spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</span><br><span class="line">spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</span><br><span class="line">spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</span><br><span class="line"><span class="number">94.</span> spring 常用的注入方式有哪些？</span><br><span class="line">setter 属性注入</span><br><span class="line">构造方法注入</span><br><span class="line">注解方式注入</span><br><span class="line"><span class="number">95.</span> spring 中的 bean 是线程安全的吗？</span><br><span class="line">spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</span><br><span class="line"></span><br><span class="line">实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 <span class="keyword">new</span> Bean()了，所以就可以保证线程安全了。</span><br><span class="line"></span><br><span class="line">有状态就是有数据存储功能。</span><br><span class="line">无状态就是不会保存数据。</span><br><span class="line"><span class="number">96.</span> spring 支持几种 bean 的作用域？</span><br><span class="line">spring 支持 <span class="number">5</span> 种作用域，如下：</span><br><span class="line"></span><br><span class="line">singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</span><br><span class="line">prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 <span class="keyword">new</span> Bean()操作；</span><br><span class="line">Web 环境下的作用域：</span><br><span class="line">request：每次 http 请求都会创建一个 bean；</span><br><span class="line">session：同一个 http session 共享一个 bean 实例；</span><br><span class="line">global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</span><br><span class="line">注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</span><br><span class="line"></span><br><span class="line"><span class="number">97.</span> spring 自动装配 bean 有哪些方式？</span><br><span class="line">no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</span><br><span class="line">byName：它根据 bean 的名称注入对象依赖项。</span><br><span class="line">byType：它根据类型注入对象依赖项。</span><br><span class="line">构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</span><br><span class="line">autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</span><br><span class="line"><span class="number">98.</span> spring 事务实现方式有哪些？</span><br><span class="line">声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 <span class="meta">@Transaction</span> 注解）。</span><br><span class="line">编码方式：提供编码的形式管理和维护事务。</span><br><span class="line"><span class="number">99.</span> 说一下 spring 的事务隔离？</span><br><span class="line">spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</span><br><span class="line"></span><br><span class="line">ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</span><br><span class="line"></span><br><span class="line">ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</span><br><span class="line"></span><br><span class="line">ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</span><br><span class="line"></span><br><span class="line">ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</span><br><span class="line"></span><br><span class="line">ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</span><br><span class="line"></span><br><span class="line">脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</span><br><span class="line"></span><br><span class="line">不可重复读 ：是指在一个事务内，多次读同一数据。</span><br><span class="line"></span><br><span class="line">幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+<span class="number">1</span> 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</span><br><span class="line"></span><br><span class="line"><span class="number">100.</span> 说一下 spring mvc 运行流程？</span><br><span class="line">spring mvc 先将请求发送给 DispatcherServlet。</span><br><span class="line">DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</span><br><span class="line">DispatcherServlet 再把请求提交到对应的 Controller。</span><br><span class="line">Controller 进行业务逻辑处理后，会返回一个ModelAndView。</span><br><span class="line">Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</span><br><span class="line">视图对象负责渲染返回给客户端。</span><br><span class="line"><span class="number">101.</span> spring mvc 有哪些组件？</span><br><span class="line">前置控制器 DispatcherServlet。</span><br><span class="line">映射控制器 HandlerMapping。</span><br><span class="line">处理器 Controller。</span><br><span class="line">模型和视图 ModelAndView。</span><br><span class="line">视图解析器 ViewResolver。</span><br><span class="line"><span class="number">102.</span> <span class="meta">@RequestMapping</span> 的作用是什么？</span><br><span class="line">将 http 请求映射到相应的类/方法上。</span><br><span class="line"></span><br><span class="line"><span class="number">103.</span> <span class="meta">@Autowired</span> 的作用是什么？</span><br><span class="line"><span class="meta">@Autowired</span> 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过<span class="meta">@Autowired</span> 的使用来消除 set/get 方法。</span><br><span class="line"></span><br><span class="line">Spring Boot/Spring Cloud</span><br><span class="line"><span class="number">104.</span> 什么是 spring boot？</span><br><span class="line">spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</span><br><span class="line"></span><br><span class="line"><span class="number">105.</span> 为什么要用 spring boot？</span><br><span class="line">配置简单</span><br><span class="line">独立运行</span><br><span class="line">自动装配</span><br><span class="line">无代码生成和 xml 配置</span><br><span class="line">提供应用监控</span><br><span class="line">易上手</span><br><span class="line">提升开发效率</span><br><span class="line"><span class="number">106.</span> spring boot 核心配置文件是什么？</span><br><span class="line">spring boot 核心的两个配置文件：</span><br><span class="line"></span><br><span class="line">bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</span><br><span class="line">application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</span><br><span class="line"><span class="number">107.</span> spring boot 配置文件有哪几种类型？它们有什么区别？</span><br><span class="line">配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</span><br><span class="line"></span><br><span class="line">. properties 配置如下：</span><br><span class="line"></span><br><span class="line">spring. RabbitMQ. port=<span class="number">5672</span></span><br><span class="line">. yml 配置如下：</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    RabbitMQ:</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">. yml 格式不支持 <span class="meta">@PropertySource</span> 注解导入。</span><br><span class="line"></span><br><span class="line"><span class="number">108.</span> spring boot 有哪些方式可以实现热部署？</span><br><span class="line">使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 <span class="keyword">true</span>；</span><br><span class="line">使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</span><br><span class="line"><span class="number">109.</span> jpa 和 hibernate 有什么区别？</span><br><span class="line">jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</span><br><span class="line"></span><br><span class="line"><span class="number">110.</span> 什么是 spring cloud？</span><br><span class="line">spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</span><br><span class="line"></span><br><span class="line"><span class="number">111.</span> spring cloud 断路器的作用是什么？</span><br><span class="line">在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</span><br><span class="line"></span><br><span class="line"><span class="number">112.</span> spring cloud 的核心组件有哪些？</span><br><span class="line">Eureka：服务注册于发现。</span><br><span class="line">Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</span><br><span class="line">Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</span><br><span class="line">Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</span><br><span class="line">Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</span><br><span class="line">Hibernate</span><br><span class="line"><span class="number">113.</span> 为什么要使用 hibernate？</span><br><span class="line">hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</span><br><span class="line">hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</span><br><span class="line">可以很方便的进行数据库的移植工作。</span><br><span class="line">提供了缓存机制，是程序执行更改的高效。</span><br><span class="line"><span class="number">114.</span> 什么是 ORM 框架？</span><br><span class="line">ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</span><br><span class="line"></span><br><span class="line">使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</span><br><span class="line"></span><br><span class="line"><span class="number">115.</span> hibernate 中如何在控制台查看打印的 SQL 语句？</span><br><span class="line">在 Config 里面把 hibernate. show_SQL 设置为 <span class="keyword">true</span> 就可以。但不建议开启，开启之后会降低程序的运行效率。</span><br><span class="line"></span><br><span class="line"><span class="number">116.</span> hibernate 有几种查询方式？</span><br><span class="line">三种：hql、原生 SQL、条件查询 Criteria。</span><br><span class="line"></span><br><span class="line"><span class="number">117.</span> hibernate 实体类可以被定义为 <span class="keyword">final</span> 吗？</span><br><span class="line">实体类可以定义为 <span class="keyword">final</span> 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 <span class="keyword">final</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">118.</span> 在 hibernate 中使用 Integer 和 <span class="keyword">int</span> 做映射有什么区别？</span><br><span class="line">Integer 类型为对象，它的值允许为 <span class="keyword">null</span>，而 <span class="keyword">int</span> 属于基础数据类型，值不能为 <span class="keyword">null</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">119.</span> hibernate 是如何工作的？</span><br><span class="line">读取并解析配置文件。</span><br><span class="line">读取并解析映射文件，创建 SessionFactory。</span><br><span class="line">打开 Session。</span><br><span class="line">创建事务。</span><br><span class="line">进行持久化操作。</span><br><span class="line">提交事务。</span><br><span class="line">关闭 Session。</span><br><span class="line">关闭 SessionFactory。</span><br><span class="line"><span class="number">120.</span> get()和 load()的区别？</span><br><span class="line">数据查询时，没有 OID 指定的对象，get() 返回 <span class="keyword">null</span>；load() 返回一个代理对象。</span><br><span class="line">load()支持延迟加载；get() 不支持延迟加载。</span><br><span class="line"><span class="number">121.</span> 说一下 hibernate 的缓存机制？</span><br><span class="line">hibernate 常用的缓存有一级缓存和二级缓存：</span><br><span class="line"></span><br><span class="line">一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</span><br><span class="line"></span><br><span class="line">二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</span><br><span class="line"></span><br><span class="line"><span class="number">122.</span> hibernate 对象有哪些状态？</span><br><span class="line">临时/瞬时状态：直接 <span class="keyword">new</span> 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</span><br><span class="line">持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</span><br><span class="line">游离状态：Session 关闭之后对象就是游离状态。</span><br><span class="line"><span class="number">123.</span> 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</span><br><span class="line">getCurrentSession 会绑定当前线程，而 openSession 则不会。</span><br><span class="line">getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</span><br><span class="line"><span class="number">124.</span> hibernate 实体类必须要有无参构造函数吗？为什么？</span><br><span class="line">hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</span><br><span class="line"></span><br><span class="line">MyBatis</span><br><span class="line">125. MyBatis 中 #&#123;&#125;和 $&#123;&#125;的区别是什么？</span><br><span class="line">\#&#123;&#125;是预编译处理，$&#123;&#125;是字符替换。 在使用 #&#123;&#125;时，MyBatis 会将 SQL 中的 #&#123;&#125;替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</span><br><span class="line"></span><br><span class="line"><span class="number">126.</span> MyBatis 有几种分页方式？</span><br><span class="line">分页方式：逻辑分页和物理分页。</span><br><span class="line"></span><br><span class="line">逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</span><br><span class="line"></span><br><span class="line">物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</span><br><span class="line"></span><br><span class="line"><span class="number">127.</span> RowBounds 是一次性查询全部结果吗？为什么？</span><br><span class="line">RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 <span class="number">10000</span> 元，但取款机每次最多能取 <span class="number">2500</span> 元，所以你要取 <span class="number">4</span> 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</span><br><span class="line"></span><br><span class="line">Fetch Size 官方相关文档：http:<span class="comment">//t. cn/EfSE2g3</span></span><br><span class="line"></span><br><span class="line"><span class="number">128.</span> MyBatis 逻辑分页和物理分页的区别是什么？</span><br><span class="line">逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</span><br><span class="line">物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</span><br><span class="line"><span class="number">129.</span> MyBatis 是否支持延迟加载？延迟加载的原理是什么？</span><br><span class="line">MyBatis 支持延迟加载，设置 lazyLoadingEnabled=<span class="keyword">true</span> 即可。</span><br><span class="line"></span><br><span class="line">延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 <span class="keyword">null</span>，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</span><br><span class="line"></span><br><span class="line"><span class="number">130.</span> 说一下 MyBatis 的一级缓存和二级缓存？</span><br><span class="line">一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</span><br><span class="line">二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</span><br><span class="line">开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</span><br><span class="line"></span><br><span class="line">缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</span><br><span class="line"></span><br><span class="line"><span class="number">131.</span> MyBatis 和 hibernate 的区别有哪些？</span><br><span class="line">灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</span><br><span class="line">可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</span><br><span class="line">学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</span><br><span class="line">二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</span><br><span class="line"><span class="number">132.</span> MyBatis 有哪些执行器（Executor）？</span><br><span class="line">MyBatis 有三种基本的Executor执行器：</span><br><span class="line"></span><br><span class="line">SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</span><br><span class="line">ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</span><br><span class="line">BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</span><br><span class="line"><span class="number">133.</span> MyBatis 分页插件的实现原理是什么？</span><br><span class="line">分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</span><br><span class="line"></span><br><span class="line"><span class="number">134.</span> MyBatis 如何编写一个自定义插件？</span><br><span class="line">自定义插件实现原理</span><br><span class="line"></span><br><span class="line">MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</span><br><span class="line"></span><br><span class="line">Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</span><br><span class="line">StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</span><br><span class="line">ParameterHandler：拦截参数的处理；</span><br><span class="line">ResultSetHandler：拦截结果集的处理。</span><br><span class="line">自定义插件实现关键</span><br><span class="line"></span><br><span class="line">MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interfaceInterceptor&#123;   </span><br><span class="line">   <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span><span class="keyword">throws</span> Throwable</span>;       </span><br><span class="line">   <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;    </span><br><span class="line">   voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br><span class="line">setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</span><br><span class="line">plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：<span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>)；</span><br><span class="line">intercept 方法就是要进行拦截的时候要执行的方法。</span><br><span class="line">自定义插件实现示例</span><br><span class="line"></span><br><span class="line">官方插件实现：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = Executor. class, method= &quot;query&quot;,</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class&#125;)&#125;)</span></span><br><span class="line">publicclassTestInterceptorimplementsInterceptor&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">     Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">     Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">     <span class="comment">// do something . . . . . .  方法拦截前执行代码块</span></span><br><span class="line">     Object result = invocation. proceed();</span><br><span class="line">     <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">RabbitMQ</span><br><span class="line"><span class="number">135.</span> RabbitMQ 的使用场景有哪些？</span><br><span class="line">抢购活动，削峰填谷，防止系统崩塌。</span><br><span class="line">延迟信息处理，比如 <span class="number">10</span> 分钟之后给下单未付款的用户发送邮件提醒。</span><br><span class="line">解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</span><br><span class="line"><span class="number">136.</span> RabbitMQ 有哪些重要的角色？</span><br><span class="line">RabbitMQ 中重要的角色有：生产者、消费者和代理：</span><br><span class="line"></span><br><span class="line">生产者：消息的创建者，负责创建和推送数据到消息服务器；</span><br><span class="line">消费者：消息的接收方，用于处理数据和确认消息；</span><br><span class="line">代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</span><br><span class="line"><span class="number">137.</span> RabbitMQ 有哪些重要的组件？</span><br><span class="line">ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</span><br><span class="line">Channel（信道）：消息推送使用的通道。</span><br><span class="line">Exchange（交换器）：用于接受、分配消息。</span><br><span class="line">Queue（队列）：用于存储生产者的消息。</span><br><span class="line">RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</span><br><span class="line">BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</span><br><span class="line"><span class="number">138.</span> RabbitMQ 中 vhost 的作用是什么？</span><br><span class="line">vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</span><br><span class="line"></span><br><span class="line"><span class="number">139.</span> RabbitMQ 的消息是怎么发送的？</span><br><span class="line">首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</span><br><span class="line"></span><br><span class="line"><span class="number">140.</span> RabbitMQ 怎么保证消息的稳定性？</span><br><span class="line">提供了事务的功能。</span><br><span class="line">通过将 channel 设置为 confirm（确认）模式。</span><br><span class="line"><span class="number">141.</span> RabbitMQ 怎么避免消息丢失？</span><br><span class="line">把消息持久化磁盘，保证服务器重启消息不丢失。</span><br><span class="line">每个集群中至少有一个物理磁盘，保证消息落入磁盘。</span><br><span class="line"><span class="number">142.</span> 要保证消息持久化成功的条件有哪些？</span><br><span class="line">声明队列必须设置持久化 durable 设置为 <span class="keyword">true</span>.</span><br><span class="line">消息推送投递模式必须设置持久化，deliveryMode 设置为 <span class="number">2</span>（持久）。</span><br><span class="line">消息已经到达持久化交换器。</span><br><span class="line">消息已经到达持久化队列。</span><br><span class="line">以上四个条件都满足才能保证消息持久化成功。</span><br><span class="line"></span><br><span class="line"><span class="number">143.</span> RabbitMQ 持久化有什么缺点？</span><br><span class="line">持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</span><br><span class="line"></span><br><span class="line"><span class="number">144.</span> RabbitMQ 有几种广播类型？</span><br><span class="line">direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</span><br><span class="line">headers：与 direct 类似，只是性能很差，此类型几乎用不到。</span><br><span class="line">fanout：分发模式，把消费分发给所有订阅者。</span><br><span class="line">topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</span><br><span class="line"><span class="number">145.</span> RabbitMQ 怎么实现延迟消息队列？</span><br><span class="line">延迟队列的实现有两种方式：</span><br><span class="line"></span><br><span class="line">通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</span><br><span class="line">使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</span><br><span class="line"><span class="number">146.</span> RabbitMQ 集群有什么用？</span><br><span class="line">集群主要有以下两个用途：</span><br><span class="line"></span><br><span class="line">高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</span><br><span class="line">高容量：集群可以承载更多的消息量。</span><br><span class="line"><span class="number">147.</span> RabbitMQ 节点的类型有哪些？</span><br><span class="line">磁盘节点：消息会存储到磁盘。</span><br><span class="line">内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</span><br><span class="line"><span class="number">148.</span> RabbitMQ 集群搭建需要注意哪些问题？</span><br><span class="line">各节点之间使用“--link”连接，此属性不能忽略。</span><br><span class="line">各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</span><br><span class="line">整个集群中必须包含一个磁盘节点。</span><br><span class="line"><span class="number">149.</span> RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</span><br><span class="line">不是，原因有以下两个：</span><br><span class="line"></span><br><span class="line">存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</span><br><span class="line">性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</span><br><span class="line"><span class="number">150.</span> RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</span><br><span class="line">如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</span><br><span class="line"></span><br><span class="line">不能创建队列</span><br><span class="line">不能创建交换器</span><br><span class="line">不能创建绑定</span><br><span class="line">不能添加用户</span><br><span class="line">不能更改权限</span><br><span class="line">不能添加和删除集群节点</span><br><span class="line">唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</span><br><span class="line"></span><br><span class="line"><span class="number">151.</span> RabbitMQ 对集群节点停止顺序有要求吗？</span><br><span class="line">RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</span><br><span class="line"></span><br><span class="line">Kafka</span><br><span class="line"><span class="number">152.</span> kafka 可以脱离 zookeeper 单独使用吗？为什么？</span><br><span class="line">kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">153.</span> kafka 有几种数据保留的策略？</span><br><span class="line">kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</span><br><span class="line"></span><br><span class="line"><span class="number">154.</span> kafka 同时设置了 <span class="number">7</span> 天和 <span class="number">10</span>G 清除数据，到第五天的时候消息达到了 <span class="number">10</span>G，这个时候 kafka 将如何处理？</span><br><span class="line">这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</span><br><span class="line"></span><br><span class="line"><span class="number">155.</span> 什么情况会导致 kafka 运行变慢？</span><br><span class="line">cpu 性能瓶颈</span><br><span class="line">磁盘读写瓶颈</span><br><span class="line">网络瓶颈</span><br><span class="line"><span class="number">156.</span> 使用 kafka 集群需要注意什么？</span><br><span class="line">集群的数量不是越多越好，最好不要超过 <span class="number">7</span> 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</span><br><span class="line">集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</span><br><span class="line">Zookeeper</span><br><span class="line"><span class="number">157.</span> zookeeper 是什么？</span><br><span class="line">zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</span><br><span class="line"></span><br><span class="line"><span class="number">158.</span> zookeeper 都有哪些功能？</span><br><span class="line">集群管理：监控节点存活状态、运行请求等。</span><br><span class="line">主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</span><br><span class="line">分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</span><br><span class="line">命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</span><br><span class="line"><span class="number">159.</span> zookeeper 有几种部署模式？</span><br><span class="line">zookeeper 有三种部署模式：</span><br><span class="line"></span><br><span class="line">单机部署：一台集群上运行；</span><br><span class="line">集群部署：多台集群运行；</span><br><span class="line">伪集群部署：一台集群启动多个 zookeeper 实例运行。</span><br><span class="line"><span class="number">160.</span> zookeeper 怎么保证主从节点的状态同步？</span><br><span class="line">zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</span><br><span class="line"></span><br><span class="line"><span class="number">161.</span> 集群中为什么要有主节点？</span><br><span class="line">在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</span><br><span class="line"></span><br><span class="line"><span class="number">162.</span> 集群中有 <span class="number">3</span> 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</span><br><span class="line">可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</span><br><span class="line"></span><br><span class="line"><span class="number">163.</span> 说一下 zookeeper 的通知机制？</span><br><span class="line">客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</span><br><span class="line"></span><br><span class="line">MySQL</span><br><span class="line"><span class="number">164.</span> 数据库的三范式是什么？</span><br><span class="line">第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</span><br><span class="line">第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</span><br><span class="line">第三范式：任何非主属性不依赖于其它非主属性。</span><br><span class="line"><span class="number">165.</span> 一张自增表里面总共有 <span class="number">7</span> 条数据，删除了最后 <span class="number">2</span> 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</span><br><span class="line">表类型如果是 MyISAM ，那 id 就是 <span class="number">8</span>。</span><br><span class="line">表类型如果是 InnoDB，那 id 就是 <span class="number">6</span>。</span><br><span class="line">InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</span><br><span class="line"></span><br><span class="line"><span class="number">166.</span> 如何获取当前数据库版本？</span><br><span class="line">使用 <span class="function">select <span class="title">version</span><span class="params">()</span> 获取当前 MySQL 数据库版本。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">167. 说一下 ACID 是什么？</span></span><br><span class="line"><span class="function">Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</span></span><br><span class="line"><span class="function">Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</span></span><br><span class="line"><span class="function">Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</span></span><br><span class="line"><span class="function">Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    168. <span class="keyword">char</span> 和 varchar 的区别是什么？</span></span><br><span class="line"><span class="function"><span class="title">char</span><span class="params">(n)</span> ：固定长度类型，比如订阅 <span class="title">char</span><span class="params">(<span class="number">10</span>)</span>，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</span></span><br><span class="line"><span class="function">chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 <span class="keyword">char</span> 非常合适。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">varchar</span><span class="params">(n)</span> ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</span></span><br><span class="line"><span class="function">所以，从空间上考虑 varcahr 比较合适；从效率上考虑 <span class="keyword">char</span> 比较合适，二者使用需要权衡。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">169. <span class="keyword">float</span> 和 <span class="keyword">double</span> 的区别是什么？</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</span></span><br><span class="line"><span class="function">170. MySQL 的内连接、左连接、右连接有什么区别？</span></span><br><span class="line"><span class="function">内连接关键字：inner join；左连接：left join；右连接：right join。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">171. MySQL 索引是怎么实现的？</span></span><br><span class="line"><span class="function">索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">172. 怎么验证 MySQL 的索引是否满足需求？</span></span><br><span class="line"><span class="function">使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">explain 语法：explain select * from table where type</span>=<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">173.</span> 说一下数据库的事务隔离？</span><br><span class="line">MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</span><br><span class="line"></span><br><span class="line">transaction-isolation = REPEATABLE-READ</span><br><span class="line"></span><br><span class="line">可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</span><br><span class="line"></span><br><span class="line">READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</span><br><span class="line">READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</span><br><span class="line">REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</span><br><span class="line">SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</span><br><span class="line">脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</span><br><span class="line"></span><br><span class="line">不可重复读 ：是指在一个事务内，多次读同一数据。</span><br><span class="line"></span><br><span class="line">幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+<span class="number">1</span> 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</span><br><span class="line"></span><br><span class="line"><span class="number">174.</span> 说一下 MySQL 常用的引擎？</span><br><span class="line">InnoDB 引擎：mysql <span class="number">5.1</span> 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 <span class="function">select <span class="title">count</span><span class="params">(*)</span> from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select <span class="title">count</span><span class="params">(*)</span> from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">175. 说一下 MySQL 的行锁和表锁？</span></span><br><span class="line"><span class="function">MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</span></span><br><span class="line"><span class="function">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</span></span><br><span class="line"><span class="function">176. 说一下乐观锁和悲观锁？</span></span><br><span class="line"><span class="function">乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</span></span><br><span class="line"><span class="function">悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</span></span><br><span class="line"><span class="function">数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">177. MySQL 问题排查都有哪些手段？</span></span><br><span class="line"><span class="function">使用 show processlist 命令查看当前所有连接信息。</span></span><br><span class="line"><span class="function">使用 explain 命令查询 SQL 语句执行计划。</span></span><br><span class="line"><span class="function">开启慢查询日志，查看慢查询的 SQL。</span></span><br><span class="line"><span class="function">178. 如何做 MySQL 的性能优化？</span></span><br><span class="line"><span class="function">为搜索字段创建索引。</span></span><br><span class="line"><span class="function">避免使用 select *，列出需要查询的字段。</span></span><br><span class="line"><span class="function">垂直分割分表。</span></span><br><span class="line"><span class="function">选择正确的存储引擎。</span></span><br><span class="line"><span class="function">Redis</span></span><br><span class="line"><span class="function">179. Redis 是什么？都有哪些使用场景？</span></span><br><span class="line"><span class="function">Redis 是一个使用 C 语言开发的高速缓存数据库。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Redis 使用场景：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">记录帖子点赞数、点击数、评论数；</span></span><br><span class="line"><span class="function">缓存近期热帖；</span></span><br><span class="line"><span class="function">缓存文章详情信息；</span></span><br><span class="line"><span class="function">记录用户会话信息。</span></span><br><span class="line"><span class="function">180. Redis 有哪些功能？</span></span><br><span class="line"><span class="function">数据缓存功能</span></span><br><span class="line"><span class="function">分布式锁的功能</span></span><br><span class="line"><span class="function">支持数据持久化</span></span><br><span class="line"><span class="function">支持事务</span></span><br><span class="line"><span class="function">支持消息队列</span></span><br><span class="line"><span class="function">181. Redis 和 memcache 有什么区别？</span></span><br><span class="line"><span class="function">存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</span></span><br><span class="line"><span class="function">数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</span></span><br><span class="line"><span class="function">使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</span></span><br><span class="line"><span class="function">value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</span></span><br><span class="line"><span class="function">182. Redis 为什么是单线程的？</span></span><br><span class="line"><span class="function">因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">183. 什么是缓存穿透？怎么解决？</span></span><br><span class="line"><span class="function">缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">184. Redis 支持的数据类型有哪些？</span></span><br><span class="line"><span class="function">Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">185. Redis 支持的 Java 客户端都有哪些？</span></span><br><span class="line"><span class="function">支持的 Java 客户端有 Redisson、jedis、lettuce 等。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">186. jedis 和 Redisson 有哪些区别？</span></span><br><span class="line"><span class="function">jedis：提供了比较全面的 Redis 命令的支持。</span></span><br><span class="line"><span class="function">Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</span></span><br><span class="line"><span class="function">187. 怎么保证缓存和数据库数据的一致性？</span></span><br><span class="line"><span class="function">合理设置缓存的过期时间。</span></span><br><span class="line"><span class="function">新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</span></span><br><span class="line"><span class="function">188. Redis 持久化有几种方式？</span></span><br><span class="line"><span class="function">Redis 的持久化有两种方式，或者说有两种策略：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</span></span><br><span class="line"><span class="function">AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</span></span><br><span class="line"><span class="function">189. Redis 怎么实现分布式锁？</span></span><br><span class="line"><span class="function">Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">占坑一般使用 <span class="title">setnx</span><span class="params">(set <span class="keyword">if</span> not exists)</span>指令，只允许被一个程序占有，使用完调用 del 释放锁。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">190. Redis 分布式锁有什么缺陷？</span></span><br><span class="line"><span class="function">Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">191. Redis 如何做内存优化？</span></span><br><span class="line"><span class="function">尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">192. Redis 淘汰策略有哪些？</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span>-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span>-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span>-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">no-enviction（驱逐）：禁止驱逐数据。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">193. Redis 常见的性能问题有哪些？该如何解决？</span></span><br><span class="line"><span class="function">主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</span></span><br><span class="line"><span class="function">Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</span></span><br><span class="line"><span class="function">JVM</span></span><br><span class="line"><span class="function">194. 说一下 JVM 的主要组成部分？及其作用？</span></span><br><span class="line"><span class="function">类加载器（ClassLoader）</span></span><br><span class="line"><span class="function">运行时数据区（Runtime Data Area）</span></span><br><span class="line"><span class="function">执行引擎（Execution Engine）</span></span><br><span class="line"><span class="function">本地库接口（Native Interface）</span></span><br><span class="line"><span class="function">组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">195. 说一下 JVM 运行时数据区？</span></span><br><span class="line"><span class="function">不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">196. 说一下堆栈的区别？</span></span><br><span class="line"><span class="function">功能方面：堆是用来存放对象的，栈是用来执行程序的。</span></span><br><span class="line"><span class="function">共享性：堆是线程共享的，栈是线程私有的。</span></span><br><span class="line"><span class="function">空间大小：堆大小远远大于栈。</span></span><br><span class="line"><span class="function">197. 队列和栈是什么？有什么区别？</span></span><br><span class="line"><span class="function">队列和栈都是被用来预存储数据的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">栈和队列很相似，但它运行对元素进行后进先出进行检索。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">198. 什么是双亲委派模型？</span></span><br><span class="line"><span class="function">在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">类加载器分类：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</span></span><br><span class="line"><span class="function">其他类加载器：</span></span><br><span class="line"><span class="function">扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style</span>=<span class="string">&quot;box-sizing: border-box; outline: 0px !important;&quot;</span>&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</span><br><span class="line">应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</span><br><span class="line">双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</span><br><span class="line"></span><br><span class="line"><span class="number">199.</span> 说一下类装载的执行过程？</span><br><span class="line">类装载分为以下 <span class="number">5</span> 个步骤：</span><br><span class="line"></span><br><span class="line">加载：根据查找路径找到相应的 <span class="class"><span class="keyword">class</span> 文件然后导入；</span></span><br><span class="line"><span class="class">检查：检查加载的 <span class="title">class</span> 文件的正确性；</span></span><br><span class="line"><span class="class">准备：给类中的静态变量分配内存空间；</span></span><br><span class="line"><span class="class">解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</span></span><br><span class="line"><span class="class">初始化：对静态变量和静态代码块执行初始化工作。</span></span><br><span class="line"><span class="class">200. 怎么判断对象是否可以被回收？</span></span><br><span class="line"><span class="class">一般有两种方法来判断：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</span></span><br><span class="line"><span class="class">可达性分析：从 <span class="title">GC</span> <span class="title">Roots</span> 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 <span class="title">GC</span> <span class="title">Roots</span> 没有任何引用链相连时，则证明此对象是可以被回收的。</span></span><br><span class="line"><span class="class">201. <span class="title">Java</span> 中都有哪些引用类型？</span></span><br><span class="line"><span class="class">强引用：发生 <span class="title">gc</span> 的时候不会被回收。</span></span><br><span class="line"><span class="class">软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</span></span><br><span class="line"><span class="class">弱引用：有用但不是必须的对象，在下一次<span class="title">GC</span>时会被回收。</span></span><br><span class="line"><span class="class">虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 <span class="title">PhantomReference</span> 实现虚引用，虚引用的用途是在 <span class="title">gc</span> 时返回一个通知。</span></span><br><span class="line"><span class="class">202. 说一下 <span class="title">JVM</span> 有哪些垃圾回收算法？</span></span><br><span class="line"><span class="class">标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</span></span><br><span class="line"><span class="class">标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</span></span><br><span class="line"><span class="class">复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</span></span><br><span class="line"><span class="class">分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</span></span><br><span class="line"><span class="class">203. 说一下 <span class="title">JVM</span> 有哪些垃圾回收器？</span></span><br><span class="line"><span class="class"><span class="title">Serial</span>：最早的单线程串行垃圾回收器。</span></span><br><span class="line"><span class="class"><span class="title">Serial</span> <span class="title">Old</span>：<span class="title">Serial</span> 垃圾回收器的老年版本，同样也是单线程的，可以作为 <span class="title">CMS</span> 垃圾回收器的备选预案。</span></span><br><span class="line"><span class="class"><span class="title">ParNew</span>：是 <span class="title">Serial</span> 的多线程版本。</span></span><br><span class="line"><span class="class"><span class="title">Parallel</span> 和 <span class="title">ParNew</span> 收集器类似是多线程的，但 <span class="title">Parallel</span> 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</span></span><br><span class="line"><span class="class"><span class="title">Parallel</span> <span class="title">Old</span> 是 <span class="title">Parallel</span> 老生代版本，<span class="title">Parallel</span> 使用的是复制的内存回收算法，<span class="title">Parallel</span> <span class="title">Old</span> 使用的是标记-整理的内存回收算法。</span></span><br><span class="line"><span class="class"><span class="title">CMS</span>：一种以获得最短停顿时间为目标的收集器，非常适用 <span class="title">B</span>/<span class="title">S</span> 系统。</span></span><br><span class="line"><span class="class"><span class="title">G1</span>：一种兼顾吞吐量和停顿时间的 <span class="title">GC</span> 实现，是 <span class="title">JDK</span> 9 以后的默认 <span class="title">GC</span> 选项。</span></span><br><span class="line"><span class="class">204. 详细介绍一下 <span class="title">CMS</span> 垃圾回收器？</span></span><br><span class="line">CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</span><br><span class="line"></span><br><span class="line">CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</span><br><span class="line"></span><br><span class="line"><span class="number">205.</span> 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</span><br><span class="line">新生代回收器：Serial、ParNew、Parallel Scavenge</span><br><span class="line">老年代回收器：Serial Old、Parallel Old、CMS</span><br><span class="line">整堆回收器：G1</span><br><span class="line">新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</span><br><span class="line"></span><br><span class="line"><span class="number">206.</span> 简述分代垃圾回收器是怎么工作的？</span><br><span class="line">分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 <span class="number">1</span>/<span class="number">3</span>，老生代的默认占比是 <span class="number">2</span>/<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">新生代使用的是复制算法，新生代里有 <span class="number">3</span> 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 <span class="number">8</span>:<span class="number">1</span>:<span class="number">1</span>，它的执行流程如下：</span><br><span class="line"></span><br><span class="line">把 Eden + From Survivor 存活的对象放入 To Survivor 区；</span><br><span class="line">清空 Eden 和 From Survivor 分区；</span><br><span class="line">From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</span><br><span class="line">每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +<span class="number">1</span>，当年龄到达 <span class="number">15</span>（默认配置是 <span class="number">15</span>）时，升级为老生代。大对象也会直接进入老生代。</span><br><span class="line"></span><br><span class="line">老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</span><br><span class="line"></span><br><span class="line"><span class="number">207.</span> 说一下 JVM 调优的工具？</span><br><span class="line">JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</span><br><span class="line"></span><br><span class="line">jconsole：用于对 JVM 中的内存、线程和类等进行监控；</span><br><span class="line">jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</span><br><span class="line"><span class="number">208.</span> 常用的 JVM 调优的参数都有哪些？</span><br><span class="line">-Xms2g：初始化推大小为 <span class="number">2</span>g；</span><br><span class="line">-Xmx2g：堆最大内存为 <span class="number">2</span>g；</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>：设置年轻的和老年代的内存比例为 <span class="number">1</span>:<span class="number">4</span>；</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>：设置新生代 Eden 和 Survivor 比例为 <span class="number">8</span>:<span class="number">2</span>；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>his医院信息系统项目总结</title>
    <url>/2020/11/01/%E5%8C%BB%E9%99%A2his%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong><em>前言:此篇文章只为理清项目思路,复盘用到的技术</em></strong></p>
<a id="more"></a>

<hr>
<h3 id="项目概要"><a href="#项目概要" class="headerlink" title="项目概要"></a>项目概要</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统结构拓扑图</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/13/XgONv4PctiUWfQr.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统模块</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/13/4oOEbVXRWImpFMr.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">业务流程图</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/13/SOzfaXy28voAK9R.png"></p>
<hr>
<h3 id="项目表结构"><a href="#项目表结构" class="headerlink" title="项目表结构"></a>项目表结构</h3><p><img src="https://i.loli.net/2021/03/13/OTVxIRqlEejL1XN.png"></p>
<p><strong>1 depart_info</strong></p>
<p>​    科室信息表，应该包含科室的名称，编码等科室的基本信息，以及表的更新时间和逻辑删除标记位</p>
<p><strong>2 drug_info</strong></p>
<p>​    药品信息表，应该包含药品编码，药品名称，药品单位，药品价格等药品的基本信息，以及表的更新时间和逻辑删除标记位</p>
<p><strong>3 employee_info</strong></p>
<p>​    雇员信息表，应该包含雇员的昵称，密码，姓名，科室id，手机号等基本时间，以及更新时间和逻辑删除标记位</p>
<p><strong>4 mr_drug</strong></p>
<p>   病例表，应该包含患者id，药品id，药品数量</p>
<p><strong>5 medical_record</strong></p>
<p>   患者就医记录表，应该包含患者姓名，患者性别，挂号的专家，患者年龄，挂号的科室，医保状态，支付状态，支付时间，医疗的id，付款的金额，自己承担的挂号费用等基本信息，以及更新时间和逻辑删除标记位</p>
<p><strong>6 prescription</strong></p>
<p>   就诊信息表，应该包含关联的病历表，描述病情，医生id，开处方的医生id，逻辑删除标记位</p>
<hr>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">步骤</span><br><span class="line">1.vmvare虚拟机克隆一个linux系统,配置镜像源配置网络</span><br><span class="line">2.docker安装mysql</span><br><span class="line">3.scp指令把sql数据库文件上传到虚拟机中,挂载到指定目录下</span><br><span class="line">4.下载navicat,连接数据库,主机名为虚拟机的地址</span><br><span class="line">5.连接查看是否导入数据库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql放进docker的好处:</span><br><span class="line">节省硬件资源</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="java后端"><a href="#java后端" class="headerlink" title="java后端"></a>java后端</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.创建一个maven项目</span><br><span class="line">2.添加依赖  热更新、spring web、mysql driver、mybatis</span><br><span class="line">3.maven目录结构:</span><br><span class="line">java</span><br><span class="line"> - service:接口实现类</span><br><span class="line"> - dao:实体类接口,基本方法</span><br><span class="line"> - controller: 接受请求   Java对象数据通过消息转换器转换为json直接给客户端 不需要jsp视图解析器</span><br><span class="line"> - model:实体类[基本属性]</span><br><span class="line">resources:通过properties配置文件[jdbc]  ----不使用</span><br><span class="line">pom.xml:导入依赖</span><br><span class="line"></span><br><span class="line">4.创建application.xml文件配置ssm框架:</span><br><span class="line">server:</span><br><span class="line">port</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    datasource</span><br><span class="line">    url:</span><br><span class="line">    usename:</span><br><span class="line">    password:</span><br><span class="line">    </span><br><span class="line">    mvc:</span><br><span class="line">    format:</span><br><span class="line">    </span><br><span class="line">    jackson:</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">    mapper-locations:</span><br><span class="line">    </span><br><span class="line">5.添加lombocl插件:通过注解自动生成get set tostring等方法</span><br><span class="line"></span><br><span class="line">6,创建一个test.http:请求测试  </span><br><span class="line">http请求分成4个部分:</span><br><span class="line"> - 请求头[键值对]</span><br><span class="line"> - 请求行</span><br><span class="line"> - 空行</span><br><span class="line"> - 请求体[表单数据]</span><br><span class="line"> </span><br><span class="line">7.springboot写sql语句的两种方式:</span><br><span class="line"> - 第一种是通过注解</span><br><span class="line"> - 第二种是通过xml写sql</span><br><span class="line"> </span><br><span class="line">8.resource下创建一个mappper文件夹,写对应dao的xml文件[11对应]</span><br><span class="line"></span><br><span class="line">9.http常用请求:get post put delete</span><br><span class="line"></span><br><span class="line">10.实现sql的动态更新[针对个别数据修改,防止其他数据一起变动]:</span><br><span class="line">set标签,sql语句加上条件判断</span><br><span class="line">  </span><br><span class="line">11.resultmap实现简单查询.关联查询1对1实现用association,1对多实现用collection</span><br><span class="line">病例-处方-药品-药品信息的4表联查</span><br><span class="line"></span><br><span class="line">12.sql语句大量重复,用include标签抽象sql重复语句</span><br><span class="line"></span><br><span class="line">13.sql条件查询,原理基本等同于动态更新</span><br><span class="line"></span><br><span class="line">14.sql语句用limit实现分页,springboot用导入pagehelpher依赖实现分页,</span><br><span class="line">好处是自动检测数据库实现分页[不需要更绝mysql或者是oracle重新写]lian</span><br><span class="line"></span><br><span class="line">15.写后台登录请求,解决域名端口号不一样跨域问题,实现反向代理,消除跨域问题改为两次请求</span><br><span class="line"></span><br><span class="line">16.处理登录请求,根据用户名和密码查询数据库是否对应,设置响应状态码</span><br><span class="line"></span><br><span class="line">17.用token来实现后端服务器拦截器,导入jwtutil工具类</span><br><span class="line"></span><br><span class="line">18.配置yml端口号为18080[防止与8080端口号冲突]</span><br><span class="line"></span><br><span class="line">19.后端根据请求把查询数据传给前端,实现前后端数据交互</span><br><span class="line"></span><br><span class="line">20.前后端权限拦截器,防止跳过登录进入界面[安全性]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="vue前端"><a href="#vue前端" class="headerlink" title="vue前端"></a>vue前端</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.安装vue cli  [搭建前后端分离必备的js框架]</span><br><span class="line"></span><br><span class="line">2.template标签里面写html javascript里面写javascript style里面写css</span><br><span class="line"></span><br><span class="line">3.了解懒加载,访问了才加载,不访问不加载  节省资源</span><br><span class="line"></span><br><span class="line">4.下载第三方组件库element-ui:</span><br><span class="line"> - 添加依赖 npm i element-ui</span><br><span class="line"> - 安装vue插件 extensions或者是vetur Install</span><br><span class="line"> </span><br><span class="line">5.views下写一个login.vue的登录界面</span><br><span class="line"></span><br><span class="line">6.配置index.js 根据路径映射到组件login.vue上</span><br><span class="line"></span><br><span class="line">7.用ajax发送请求,在export default里写method方法</span><br><span class="line"></span><br><span class="line">8.安装插件 vue add axios</span><br><span class="line"></span><br><span class="line">9.根目录下创建vue.config js文件</span><br><span class="line"></span><br><span class="line">10.views下新疆index.vue  index.js配置index.vue</span><br><span class="line"></span><br><span class="line">11.重写login,防止直接在浏览器访问index界面,写axios拦截器</span><br><span class="line"></span><br><span class="line">12.添加cookieutils.js</span><br><span class="line"></span><br><span class="line">13.写条件查询,把请求传给后端</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>idea个人设置与快捷操作速记</title>
    <url>/2020/10/04/idea%E4%B8%AA%E4%BA%BA%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%E9%80%9F%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">便捷快捷键:</span><br><span class="line"></span><br><span class="line">ctrl+shift+alt：多行操作   </span><br><span class="line">psvm：生成main()方法；</span><br><span class="line">fori：生成<span class="keyword">for</span>循环；</span><br><span class="line">Ctrl+Alt+v：自动补齐返回值类型</span><br><span class="line">ctrl+o：覆写方法</span><br><span class="line">ctrl+i：实现接口中的方法</span><br><span class="line">ctrl+shift+u：大小写转换</span><br><span class="line">CTRL+SHIFT+Z：取消撤销</span><br><span class="line">Alt＋Insert：生成构造方法、getter、setter  ctrl或者shift多选</span><br><span class="line">ctrl+y：删除当前行</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctrl+Shift+J：将选中的行合并成一行</span><br><span class="line">ctrl+g：定位到某一行</span><br><span class="line">Ctrl+Shitft+向下箭头：将光标所在的代码块向下整体移动</span><br><span class="line">Ctrl+Shift+向上箭头：将光标所在的代码块向上整体移动</span><br><span class="line">Alt+Shift+向下箭头：将行向下移动</span><br><span class="line">Alt+Shift+向上箭头：将行向上移动</span><br><span class="line">sout: 快速输出</span><br><span class="line">ctrl d:快速复制</span><br><span class="line">Ctrl+F：在当前文件中查找</span><br><span class="line">Ctrl+R：替换字符串</span><br><span class="line">Ctrl+Shift+F:在全局文件中查找字符串</span><br><span class="line">Ctrl+Shift+R：在全局中替换字符串</span><br><span class="line">Ctrl+Shift+Enter：自动补齐&#123;&#125;或者分号;</span><br><span class="line">Shift+Enter：在当前行的下方开始新行</span><br><span class="line">Ctrl+Alt+Enter：在当前行的上方插入新行</span><br><span class="line">Ctrl+Delete：删除光标所在至单词结尾处的所有字符</span><br><span class="line"></span><br><span class="line">web开发</span><br><span class="line">ctrl+/快捷注释</span><br><span class="line">    </span><br><span class="line">持续更新- 设置背景,hack字体,打包设置等便捷操作</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>事物</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>事半功倍</tag>
      </tags>
  </entry>
  <entry>
    <title>合理健身,从心肺做起</title>
    <url>/2020/09/08/%E5%90%88%E7%90%86%E5%81%A5%E8%BA%AB,%E4%BB%8E%E5%BF%83%E8%82%BA%E5%81%9A%E8%B5%B7/</url>
    <content><![CDATA[<h3 id="减少脂肪的有效方法"><a href="#减少脂肪的有效方法" class="headerlink" title="减少脂肪的有效方法"></a>减少脂肪的有效方法</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">大一大二在足球队到现在已经过去了两年了,脱离了系统性日复一日的训练、不健康的生活作息,</span><br><span class="line">我能够明显的感觉到自己处在一个亚健康的状态,某一天猛地惊醒想努力摆脱这个状态,这是现状.</span><br><span class="line"></span><br><span class="line">但是减脂增肌不是一蹴而就的行的,在youtube 搜索muscle 了解原理知识后,我掌握了3个好的方法</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.启动自身的内燃机.我们把燃烧脂肪的身体自耗叫做内燃机,得益于进步的社会,我们平时身体几乎</span><br><span class="line">没有使用内燃机的机会.基本以消耗糖分、蛋白质为主,所以第一步的做法是身体进食时间分成8+16,</span><br><span class="line">8个小时的时间里吃完一天三餐,留下16小时的时间给内燃机启动反应的机会,并且8个小时里面多吃优质蛋白.</span><br><span class="line"></span><br><span class="line">2.多做无氧训练,与一般认知不一样的是不做有氧而做无氧运动.相比于有氧,无氧运动消耗更多的卡路里,</span><br><span class="line">更关键的是他可以帮助我们长肌肉,肌肉是一个好东西,帮助我们24小时都在不断消耗能量,更大的新陈快谢率.</span><br><span class="line"></span><br><span class="line">3.多睡觉,有一个好作息的效果远大于一两个小时的锻炼.</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">掌握了瘦身的方法,但其实相比知道上面这些原理更重要的是,一个久未锻炼的人,应该是先从锻炼心肺能力</span><br><span class="line">开始做起的.</span><br><span class="line"></span><br><span class="line">锻炼心肺能力有很多适合的运动,因为疫情场地的限制我选择跳绳开始锻炼自己的心肺能力.</span><br><span class="line"></span><br><span class="line">首先你要有一根趁手的跳绳,其次你要掌握一点点跳绳的技巧</span><br><span class="line"></span><br><span class="line">我亲身体会总结的跳绳技巧有:</span><br><span class="line">1.最重要的是多跳,熟能生巧</span><br><span class="line">2.合理的绳子长度(单脚踩绳,绳柄末端查不到在胸口位置)</span><br><span class="line">3.膝盖弯曲,避免完全受力受伤</span><br><span class="line">4.手肘贴近,前脚掌起地着地</span><br><span class="line"></span><br><span class="line">掌握了以上的方法,就可以开始跳绳的训练了.</span><br><span class="line"></span><br><span class="line">目前进度:</span><br><span class="line">从刚开始20分钟500下很喘流一身汗到现在已经能做到30分钟3000下了</span><br><span class="line">下一个目标是把3000下时间压缩到20分钟,当成是无氧运动前的热身</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/2020/08/30/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>写在开头:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">​&#96;&#96;&#96;t</span><br><span class="line">防止Markdown自编译,可以在这个代码块里写语法</span><br></pre></td></tr></table></figure>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下:"></a>效果如下:</h3><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-1"><a href="#效果如下-1" class="headerlink" title="效果如下:"></a>效果如下:</h3><p><strong>HelloWorld</strong><br><em>HelloWorld</em><br><strong><em>HelloWorld</em></strong><br><del>HelloWorld</del></p>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-2"><a href="#效果如下-2" class="headerlink" title="效果如下:"></a>效果如下:</h3><blockquote>
<p>Hello World</p>
<blockquote>
<p>Hello World</p>
</blockquote>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-3"><a href="#效果如下-3" class="headerlink" title="效果如下:"></a>效果如下:</h3><hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">![]()括号里面放的是链接,可以使用本地和外链</span><br><span class="line">外链得学习图床相关知识</span><br><span class="line">举例:![](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;08&#x2F;30&#x2F;nlUkbAXOoxzyc4d.jpg)</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-4"><a href="#效果如下-4" class="headerlink" title="效果如下:"></a>效果如下:</h3><p><img src="https://i.loli.net/2020/08/30/nlUkbAXOoxzyc4d.jpg"></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">[](&quot;&quot;)</span><br><span class="line">举例:[百度](&quot;http:&#x2F;&#x2F;baidu.com&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-5"><a href="#效果如下-5" class="headerlink" title="效果如下:"></a>效果如下:</h3><p><a href="%22http://baidu.com%22">百度</a></p>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">有序列表:</span><br><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br><span class="line"></span><br><span class="line">无序列表:</span><br><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="效果如下-6"><a href="#效果如下-6" class="headerlink" title="效果如下:"></a>效果如下:</h3><ol>
<li>有序列表</li>
<li>列表内容   </li>
<li>列表内容</li>
</ol>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">鼠标右键点击空白区选择插入表格比较方便.</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-7"><a href="#效果如下-7" class="headerlink" title="效果如下:"></a>效果如下:</h3><table>
<thead>
<tr>
<th align="left"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h1 id="九、代码块"><a href="#九、代码块" class="headerlink" title="九、代码块"></a>九、代码块</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">​~~~加上你选择的语言</span><br><span class="line">用java举例:</span><br><span class="line">​~~~java</span><br></pre></td></tr></table></figure>

<h3 id="效果如下-8"><a href="#效果如下-8" class="headerlink" title="效果如下:"></a>效果如下:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客知识</title>
    <url>/2020/08/27/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><ul>
<li><p>解决从github clone文件或者是仓库过慢的问题:</p>
<p>只需要将 <a href="https://link.zhihu.com/?target=http://www.github.com/">www.github.com</a>/后面为代码库 改为</p>
<p><a href="https://link.zhihu.com/?target=http://xn--www-c88d846h.github.com.cnpmjs.org/%E5%90%8E%E9%9D%A2%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%BA%93%E5%9C%B0%E5%9D%80">www.github.com.cnpmjs.org/后面为代码库地址</a> 就可以实现一键式加速。</p>
</li>
</ul>
<a id="more"></a>

<p>打开git -bash窗口:</p>
<ul>
<li>首先进入blog所在的磁盘 cd  f :/blog</li>
<li>hexo s  -g   打开本地博客页面</li>
<li>hexo clean 清楚缓存,方便查看更改</li>
<li>配置主题改blog下的.config.yml</li>
<li>配置主题的界面更改主题下的.config.yml</li>
<li>修改完本地上传到远端 hexo d (远端指的是github)</li>
<li>配置ssh免密如果是https格式的网址开头记得修改成:<a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:XosinChen/XosinChen.github.io.git</li>
<li>修改主题文件夹为nest就会是初始的界面</li>
<li>用picgo部署图床</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">部署图床的作用,给图片外链以便上传博客让别人访问,不然图片只存在你的客户端只有你自己才能访问.</span><br></pre></td></tr></table></figure>

<ul>
<li>使用git快速写博客</li>
</ul>
<p><img src="https://i.loli.net/2021/03/10/dGHjM1sVCm64Ryp.png"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">写一个小js 让git访问本地的markdown就行啦</span><br></pre></td></tr></table></figure>

<ul>
<li>将部署在github的博客域名改为个人域名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.阿里云买一个域名</span><br><span class="line">2.解析域名,并且本地ping 个人仓库的博客网址例如(xosinchen.github.io)得到ip地址,根据ip地址修改解析的结果</span><br><span class="line">3.在blog\source中新建CNAME记事本，内容输入www.xosinchen.cn【个人域名】，保存关闭。</span><br><span class="line">4.进入github 博客项目 项目setting中绑定域名 (勾选https 选择是否打开)</span><br><span class="line">5.访问个人域名显示界面即绑定成功</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br><span class="line">可以用来显示展现在博客首页内容,剩下的内容得点开打开全文才能看到</span><br></pre></td></tr></table></figure>

<ul>
<li>基础优化设置例如评论,与博主对话还在完善,持续更新~</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>事半功倍物品分享</title>
    <url>/2020/08/20/%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D%E7%89%A9%E5%93%81%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="分享推荐"><a href="#分享推荐" class="headerlink" title="分享推荐:"></a>分享推荐:</h3><p>pc端:</p>
<p>1.everything 查找文件很快(建议把东西分区存放,c盘不放东西,下载多一个心眼看是否默认在c盘,开发项目jar包、配置文件放在一起)</p>
<p>2.网易云音乐 听歌</p>
<p>3.xmind  每隔一段时间都很有必要做一次思维导图</p>
<a id="more"></a>

<p>4.potplayer 看视频的好工具</p>
<p>5.ccleaner  很多编程软件有下载安装失败的问题,往往是注册表有问题,它能帮你很好的删除无用注册表,防止出错</p>
<p>6.smartdefrag 类似电脑管家,比电脑自带的强大一点</p>
<p>7.onenote 记笔记很好用,理清日常规划    </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">使用举例</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/10/1Gw9S8vDdmsfBV3.png"></p>
<p>8.sumatrapdf 阅读github开源的pdf文件很好用,是学习的好帮手</p>
<p>安卓手机:</p>
<p>1.onenote手机端电脑端互通</p>
<p>2.cuto、pinterest 对背景图、图片有需求的好帮手(前端抠图利器)</p>
<p>3.filpclock 让手机变成时钟,提高工作学习效率</p>
<p>4.snapseed 强大的处理图片工具</p>
<h3 id="持续更新"><a href="#持续更新" class="headerlink" title="持续更新~"></a>持续更新~</h3>]]></content>
      <categories>
        <category>事物</category>
      </categories>
      <tags>
        <tag>事倍功半</tag>
      </tags>
  </entry>
</search>
